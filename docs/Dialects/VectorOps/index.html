<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Dialect 'vector' definition - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.64.1"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/VectorOps/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/llvm-project/mlir>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/master/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/master/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li></ul></nav></div><div class=content-container><main><h1>Dialect 'vector' definition</h1><p><nav id=TableOfContents><ul><li><a href=#operation-definition>Operation definition</a><ul><li><a href=#vectorbroadcast-vectorbroadcastop>vector.broadcast (vector::BroadcastOp)</a></li><li><a href=#vectorconstant_mask-vectorconstantmaskop>vector.constant_mask (vector::ConstantMaskOp)</a></li><li><a href=#vectorcontract-vectorcontractionop>vector.contract (vector::ContractionOp)</a></li><li><a href=#vectorcreate_mask-vectorcreatemaskop>vector.create_mask (vector::CreateMaskOp)</a></li><li><a href=#vectorextractelement-vectorextractelementop>vector.extractelement (vector::ExtractElementOp)</a></li><li><a href=#vectorextract-vectorextractop>vector.extract (vector::ExtractOp)</a></li><li><a href=#vectorextract_slices-vectorextractslicesop>vector.extract_slices (vector::ExtractSlicesOp)</a></li><li><a href=#vectorfma-vectorfmaop>vector.fma (vector::FMAOp)</a></li><li><a href=#vectorinsertelement-vectorinsertelementop>vector.insertelement (vector::InsertElementOp)</a></li><li><a href=#vectorinsert-vectorinsertop>vector.insert (vector::InsertOp)</a></li><li><a href=#vectorinsert_slices-vectorinsertslicesop>vector.insert_slices (vector::InsertSlicesOp)</a></li><li><a href=#vectorinsert_strided_slice-vectorinsertstridedsliceop>vector.insert_strided_slice (vector::InsertStridedSliceOp)</a></li><li><a href=#vectormatrix_multiply-vectormatmulop>vector.matrix_multiply (vector::MatmulOp)</a></li><li><a href=#vectorouterproduct-vectorouterproductop>vector.outerproduct (vector::OuterProductOp)</a></li><li><a href=#vectorprint-vectorprintop>vector.print (vector::PrintOp)</a></li><li><a href=#vectorreduction-vectorreductionop>vector.reduction (vector::ReductionOp)</a></li><li><a href=#vectorreshape-vectorreshapeop>vector.reshape (vector::ReshapeOp)</a></li><li><a href=#vectorshape_cast-vectorshapecastop>vector.shape_cast (vector::ShapeCastOp)</a></li><li><a href=#vectorshuffle-vectorshuffleop>vector.shuffle (vector::ShuffleOp)</a></li><li><a href=#vectorstrided_slice-vectorstridedsliceop>vector.strided_slice (vector::StridedSliceOp)</a></li><li><a href=#vectortransfer_read-vectortransferreadop>vector.transfer_read (vector::TransferReadOp)</a></li><li><a href=#vectortransfer_write-vectortransferwriteop>vector.transfer_write (vector::TransferWriteOp)</a></li><li><a href=#vectortuple_get-vectortuplegetop>vector.tuple_get (vector::TupleGetOp)</a></li><li><a href=#vectortuple-vectortupleop>vector.tuple (vector::TupleOp)</a></li><li><a href=#vectortype_cast-vectortypecastop>vector.type_cast (vector::TypeCastOp)</a></li></ul></li></ul></nav><h2 id=operation-definition>Operation definition</h2><h3 id=vectorbroadcast-vectorbroadcastop>vector.broadcast (vector::BroadcastOp)</h3><p>broadcast operation</p><h4 id=description>Description:</h4><p>Broadcasts the scalar or k-D vector value in the source operand
to a n-D result vector such that the broadcast makes sense, i.e.,
the source operand is duplicated to match the given rank and sizes
in the result vector. The legality rules are:</p><ul><li>the source operand must have the same element type as the result type</li><li>a k-D vector &lt;s_1 x .. x s_k x type> can be broadcast to
a n-D vector &lt;t_1 x .. x t_n x type> if<ul><li>k &lt;= n, and</li><li>the sizes in the trailing dimensions n-k &lt; i &lt;= n with j=i+k-n
match exactly as s_j = t_i or s_j = 1:</li></ul><pre><code>    t_1 x   ..  t_n-k x t_n-k+1 x .. x t_i x .. x t_n
                        s_1     x .. x s_j x .. x s_k
        &lt;duplication&gt;         &lt;potential stretch&gt;
</code></pre></li></ul><p>The source operand is duplicated over all the missing leading dimensions
and stretched over the trailing dimensions where the source has a non-equal
dimension of 1. These rules imply that any scalar broadcast (k=0) to any
shaped vector with the same element type is always legal.</p><p>Examples:</p><pre><code>  %0 = constant 0.0 : f32
  %1 = vector.broadcast %0 : f32 to vector&lt;16xf32&gt;
  %2 = vector.broadcast %1 : vector&lt;16xf32&gt; to vector&lt;4x16xf32&gt;
</code></pre><h4 id=operands>Operands:</h4><ol><li><code>source</code>: any type</li></ol><h4 id=attributes>Attributes:</h4><h4 id=results>Results:</h4><ol><li><code>vector</code>: vector of any type values</li></ol><h3 id=vectorconstant_mask-vectorconstantmaskop>vector.constant_mask (vector::ConstantMaskOp)</h3><p>creates a constant vector mask</p><h4 id=description-1>Description:</h4><p>Creates and returns a vector mask where elements of the result vector
are set to &lsquo;0&rsquo; or &lsquo;1&rsquo;, based on whether the element indices are contained
within a hyper-rectangular region specified by the &lsquo;mask_dim_sizes&rsquo;
array attribute argument. Each element of the &lsquo;mask_dim_sizes&rsquo; array,
specifies an exclusive upper bound [0, mask-dim-size-element-value)
for a unique dimension in the vector result. The conjunction of the ranges
define a hyper-rectangular region within which elements values are set to 1
(otherwise element values are set to 0).</p><p>Example: create a constant vector mask of size 4x3xi1 with elements in range
0 &lt;= row &lt;= 2 and 0 &lt;= col &lt;= 1 are set to 1 (others to 0).</p><p>%1 = vector.constant_mask [3, 2] : vector&lt;4x3xi1></p><p>print %1
columns
0 1 2
|&mdash;&mdash;&mdash;&mdash;
0 | 1 1 0
rows 1 | 1 1 0
2 | 1 1 0
3 | 0 0 0</p><h4 id=operands-1>Operands:</h4><h4 id=attributes-1>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>mask_dim_sizes</code></td><td align=center><code>ArrayAttr</code></td><td>64-bit integer array attribute attribute</td></tr></tbody></table><h4 id=results-1>Results:</h4><ol><li>«unnamed»: vector of 1-bit signless integer values</li></ol><h3 id=vectorcontract-vectorcontractionop>vector.contract (vector::ContractionOp)</h3><p>vector contraction operation</p><h4 id=description-2>Description:</h4><p>Computes the sum of products of vector elements along contracting
dimension pairs from 2 vectors of rank M and N respectively, adds this
intermediate result to the accumulator argument of rank K, and returns a
vector result of rank K (where K = num_lhs_free_dims + num_rhs_free_dims +
num_batch_dims (see dimension type descriptions below)). For K = 0 (no
free or batch dimensions), the accumulator and output are a scalar.</p><p>Optional vector mask arguments (produced by CreateMaskOp or ConstantMaskOp)
specify the dynamic dimension sizes of valid data within the lhs/rhs vector
arguments.</p><p>An iterator type attribute list must be specified, where each element of
the list represents an iterator with one of the following types:</p><p>*) &ldquo;reduction&rdquo;: reduction dimensions are present in the lhs and rhs
arguments but not in the output (and accumulator
argument). These are the dimensions along which the vector
contraction op computes the sum of products, and
contracting dimension pair dimension sizes must match
between lhs/rhs.
*) &ldquo;parallel&rdquo;: Batch dimensions are iterator type &ldquo;parallel&rdquo;, and
are non-contracting dimensions present in the lhs, rhs and
output. The lhs/rhs co-iterate along the batch dimensions,
which should be expressed in their indexing maps.</p><pre><code>           Free dimensions are iterator type &quot;parallel&quot;, and are
           non-contraction, non-batch dimensions accessed by either the
           lhs or rhs (but not both). The lhs and rhs free dimensions
           are unrelated to each other and do not co-iterate, which
           should be expressed in their indexing maps.
</code></pre><p>An indexing map attribute list must be specified with an entry for lhs, rhs
and acc arguments. An indexing map attribute specifies a mapping from each
iterator in the iterator type list, to each dimension of an N-D vector.</p><p>Examples:</p><p>// Simple dot product (K = 0).
#contraction_accesses = [
affine_map&lt;(i) -> (i)>,
affine_map&lt;(i) -> (i)>,
affine_map&lt;(i) -> ()>
]
#contraction_trait = {
indexing_maps = #contraction_accesses,
iterator_types = [&ldquo;reduction&rdquo;]
}
%3 = vector.contract #contraction_trait %0, %1, %2
: vector&lt;10xf32>, vector&lt;10xf32> into f32</p><p>// 2D vector contraction with one contracting dimension (matmul, K = 2).
#contraction_accesses = [
affine_map&lt;(i, j, k) -> (i, k)>,
affine_map&lt;(i, j, k) -> (k, j)>,
affine_map&lt;(i, j, k) -> (i, j)>
]
#contraction_trait = {
indexing_maps = #contraction_accesses,
iterator_types = [&ldquo;parallel&rdquo;, &ldquo;parallel&rdquo;, &ldquo;reduction&rdquo;]
}</p><p>%3 = vector.contract #contraction_trait %0, %1, %2
: vector&lt;4x3xf32>, vector&lt;3x7xf32> into vector&lt;4x7xf32></p><p>// 4D to 3D vector contraction with two contracting dimensions and
// one batch dimension (K = 3).
#contraction_accesses = [
affine_map&lt;(b0, f0, f1, c0, c1) -> (c0, b0, c1, f0)>,
affine_map&lt;(b0, f0, f1, c0, c1) -> (b0, c1, c0, f1)>,
affine_map&lt;(b0, f0, f1, c0, c1) -> (b0, f0, f1)>
]
#contraction_trait = {
indexing_maps = #contraction_accesses,
iterator_types = [&ldquo;parallel&rdquo;, &ldquo;parallel&rdquo;, &ldquo;parallel&rdquo;,
&ldquo;reduction&rdquo;, &ldquo;reduction&rdquo;]
}</p><p>%4 = vector.contract #contraction_trait %0, %1, %2
: vector&lt;7x8x16x15xf32>, vector&lt;8x16x7x5xf32> into vector&lt;8x15x5xf32></p><p>// 4D vector contraction with two contracting dimensions and optional
// vector mask arguments.
%lhs_mask = vector.constant_mask [7, 8, 16, 15] : vector&lt;7x8x16x15xi1>
%rhs_mask = vector.constant_mask [8, 16, 7, 5] : vector&lt;8x16x7x5xi1></p><p>%5 = vector.contract #contraction_trait %0, %1, %2, %lhs_mask, %rhs_mask
: vector&lt;7x8x16x15xf32>, vector&lt;8x16x7x5xf32> into vector&lt;8x15x8x5xf32></p><h4 id=operands-2>Operands:</h4><ol><li><code>lhs</code>: vector of any type values</li><li><code>rhs</code>: vector of any type values</li><li><code>acc</code>: any type</li><li><code>masks</code>: vector of 1-bit signless integer values</li></ol><h4 id=attributes-2>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>indexing_maps</code></td><td align=center><code>ArrayAttr</code></td><td>AffineMap array attribute attribute</td></tr><tr><td align=center><code>iterator_types</code></td><td align=center><code>ArrayAttr</code></td><td>array attribute attribute</td></tr></tbody></table><h4 id=results-2>Results:</h4><ol><li>«unnamed»: any type</li></ol><h3 id=vectorcreate_mask-vectorcreatemaskop>vector.create_mask (vector::CreateMaskOp)</h3><p>creates a vector mask</p><h4 id=description-3>Description:</h4><p>Creates and returns a vector mask where elements of the result vector
are set to &lsquo;0&rsquo; or &lsquo;1&rsquo;, based on whether the element indices are contained
within a hyper-rectangular region specified by the operands. Specifically,
each operand specifies a range [0, operand-value) for a unique dimension in
the vector result. The conjunction of the operand ranges define a
hyper-rectangular region within which elements values are set to 1
(otherwise element values are set to 0).</p><p>Example: create a vector mask of size 4x3xi1 where elements in range
0 &lt;= row &lt;= 2 and 0 &lt;= col &lt;= 1 are set to 1 (others to 0).</p><p>%1 = vector.create_mask %c3, %c2 : vector&lt;4x3xi1></p><p>print %1
columns
0 1 2
|&mdash;&mdash;&mdash;&mdash;
0 | 1 1 0
rows 1 | 1 1 0
2 | 1 1 0
3 | 0 0 0</p><h4 id=operands-3>Operands:</h4><ol><li><code>operands</code>: index</li></ol><h4 id=attributes-3>Attributes:</h4><h4 id=results-3>Results:</h4><ol><li>«unnamed»: vector of 1-bit signless integer values</li></ol><h3 id=vectorextractelement-vectorextractelementop>vector.extractelement (vector::ExtractElementOp)</h3><p>extractelement operation</p><h4 id=description-4>Description:</h4><p>Takes an 1-D vector and a dynamic index position and extracts the
scalar at that position. Note that this instruction resembles
vector.extract, but is restricted to 1-D vectors and relaxed
to dynamic indices. It is meant to be closer to LLVM&rsquo;s version:
<a href=https://llvm.org/docs/LangRef.html#extractelement-instruction>https://llvm.org/docs/LangRef.html#extractelement-instruction</a></p><p>Example:</p><pre><code>  %c = constant 15 : i32
  %1 = vector.extractelement %0[%c : i32]: vector&lt;16xf32&gt;
</code></pre><h4 id=operands-4>Operands:</h4><ol><li><code>vector</code>: vector of any type values</li><li><code>position</code>: signless integer</li></ol><h4 id=attributes-4>Attributes:</h4><h4 id=results-4>Results:</h4><ol><li><code>result</code>: any type</li></ol><h3 id=vectorextract-vectorextractop>vector.extract (vector::ExtractOp)</h3><p>extract operation</p><h4 id=description-5>Description:</h4><p>Takes an n-D vector and a k-D position and extracts the (n-k)-D vector at
the proper position. Degenerates to an element type in the 0-D case.</p><p>Examples:</p><pre><code>  %1 = vector.extract %0[3]: vector&lt;4x8x16xf32&gt;
  %2 = vector.extract %0[3, 3, 3]: vector&lt;4x8x16xf32&gt;
</code></pre><h4 id=operands-5>Operands:</h4><ol><li><code>vector</code>: vector of any type values</li></ol><h4 id=attributes-5>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>position</code></td><td align=center><code>ArrayAttr</code></td><td>64-bit integer array attribute attribute</td></tr></tbody></table><h4 id=results-5>Results:</h4><ol><li>«unnamed»: any type</li></ol><h3 id=vectorextract_slices-vectorextractslicesop>vector.extract_slices (vector::ExtractSlicesOp)</h3><p>vector extract slices operation</p><h4 id=description-6>Description:</h4><p>Takes an N-d vector and returns a tuple of vector slices of &lsquo;vector&rsquo;,
based on &lsquo;sizes&rsquo; and &lsquo;strides&rsquo; parameters.</p><p>The arguments &lsquo;sizes&rsquo; and &lsquo;strides&rsquo; represent a specification for
generating the unrolling of &lsquo;vector&rsquo; shape, which has all slices of shape
&lsquo;sizes&rsquo; except for slices at dimension boundaries when &lsquo;vector&rsquo; dimension
sizes are not a multiple of &lsquo;sizes&rsquo;.</p><p>Each slice is returned at the tuple element index corresponding to the
linear index of the slice w.r.t the unrolling scheme represented by &lsquo;sizes&rsquo;.
Currently, only unit strides are supported.</p><p>Examples:</p><pre><code>  %0 = vector.transfer_read ...: vector&lt;4x2xf32&gt;

  %1 = vector.extract_slices %0, [2, 2], [1, 1]
    : vector&lt;4x2xf32&gt; into tuple&lt;vector&lt;2x2xf32&gt;, vector&lt;2x2xf32&gt;&gt;

  // Example with partial slices at dimension boundaries.
  %2 = vector.transfer_read ...: vector&lt;4x3xf32&gt;

  %3 = vector.extract_slices %2, [2, 2], [1, 1]
    : vector&lt;4x3xf32&gt; into tuple&lt;vector&lt;2x2xf32&gt;, vector&lt;2x1xf32&gt;,
                                 vector&lt;2x2xf32&gt;, vector&lt;2x1xf32&gt;&gt;
</code></pre><h4 id=operands-6>Operands:</h4><ol><li><code>vector</code>: vector of any type values</li></ol><h4 id=attributes-6>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>sizes</code></td><td align=center><code>ArrayAttr</code></td><td>64-bit integer array attribute attribute</td></tr><tr><td align=center><code>strides</code></td><td align=center><code>ArrayAttr</code></td><td>64-bit integer array attribute attribute</td></tr></tbody></table><h4 id=results-6>Results:</h4><ol><li>«unnamed»: tuple with any combination of vector of any type values values</li></ol><h3 id=vectorfma-vectorfmaop>vector.fma (vector::FMAOp)</h3><p>vector fused multiply-add</p><h4 id=description-7>Description:</h4><p>Multiply-add expressions operate on n-D vectors and compute a fused
pointwise multiply-and-accumulate: <code>$result = </code>$lhs * $rhs + $acc<code>. All operands and result have the same vector type. The semantics of the operation correspond to those of the </code>llvm.fma<code>[intrinsic](https://llvm.org/docs/LangRef.html#int-fma). In the particular case of lowering to LLVM, this is guaranteed to lower to the </code>llvm.fma.*` intrinsic.</p><p>Example:</p><pre><code>  %3 = vector.fma %0, %1, %2: vector&lt;8x16xf32&gt;
</code></pre><h4 id=operands-7>Operands:</h4><ol><li><code>lhs</code>: vector of any type values</li><li><code>rhs</code>: vector of any type values</li><li><code>acc</code>: vector of any type values</li></ol><h4 id=attributes-7>Attributes:</h4><h4 id=results-7>Results:</h4><ol><li><code>result</code>: vector of any type values</li></ol><h3 id=vectorinsertelement-vectorinsertelementop>vector.insertelement (vector::InsertElementOp)</h3><p>insertelement operation</p><h4 id=description-8>Description:</h4><p>Takes a scalar source, an 1-D destination vector and a dynamic index
position and inserts the source into the destination at the proper
position. Note that this instruction resembles vector.insert, but
is restricted to 1-D vectors and relaxed to dynamic indices. It is
meant to be closer to LLVM&rsquo;s version:
<a href=https://llvm.org/docs/LangRef.html#insertelement-instruction>https://llvm.org/docs/LangRef.html#insertelement-instruction</a></p><p>Example:</p><pre><code>  %c = constant 15 : i32
  %f = constant 0.0f : f32
  %1 = vector.insertelement %f, %0[%c : i32]: vector&lt;16xf32&gt;
</code></pre><h4 id=operands-8>Operands:</h4><ol><li><code>source</code>: any type</li><li><code>dest</code>: vector of any type values</li><li><code>position</code>: signless integer</li></ol><h4 id=attributes-8>Attributes:</h4><h4 id=results-8>Results:</h4><ol><li><code>result</code>: vector of any type values</li></ol><h3 id=vectorinsert-vectorinsertop>vector.insert (vector::InsertOp)</h3><p>insert operation</p><h4 id=description-9>Description:</h4><p>Takes an n-D source vector, an (n+k)-D destination vector and a k-D position
and inserts the n-D source into the (n+k)-D destination at the proper
position. Degenerates to a scalar source type when n = 0.</p><p>Examples:</p><pre><code>  %2 = vector.insert %0, %1[3]:
    vector&lt;8x16xf32&gt; into vector&lt;4x8x16xf32&gt;
  %5 = vector.insert %3, %4[3, 3, 3]:
    f32 into vector&lt;4x8x16xf32&gt;
</code></pre><h4 id=operands-9>Operands:</h4><ol><li><code>source</code>: any type</li><li><code>dest</code>: vector of any type values</li></ol><h4 id=attributes-9>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>position</code></td><td align=center><code>ArrayAttr</code></td><td>64-bit integer array attribute attribute</td></tr></tbody></table><h4 id=results-9>Results:</h4><ol><li><code>res</code>: vector of any type values</li></ol><h3 id=vectorinsert_slices-vectorinsertslicesop>vector.insert_slices (vector::InsertSlicesOp)</h3><p>vector insert slices operation</p><h4 id=description-10>Description:</h4><p>Takes a tuple of vector slices and inserts them into the vector result
according to the &lsquo;sizes&rsquo; and &lsquo;strides&rsquo; parameters.</p><p>The arguments &lsquo;sizes&rsquo; and &lsquo;strides&rsquo; represent a specification for
generating the unrolling of &lsquo;vector&rsquo; shape, which has all slices of shape
&lsquo;sizes&rsquo; except for slices at dimension boundaries when &lsquo;vector&rsquo; dimension
sizes are not a multiple of &lsquo;sizes&rsquo;.</p><p>Each slice in &lsquo;vectors&rsquo; is at the tuple element index corresponding to the
linear index of the slice w.r.t the unrolling scheme represented by &lsquo;sizes&rsquo;.
Currently, only unit strides are supported.</p><p>Examples:</p><pre><code>  %0 = vector.extract_slices %0, [2, 2], [1, 1]
    : vector&lt;4x2xf32&gt; into tuple&lt;vector&lt;2x2xf32&gt;, vector&lt;2x2xf32&gt;&gt;

  %1 = vector.insert_slices %0, [2, 2], [1, 1]
    : tuple&lt;vector&lt;2x2xf32&gt;, vector&lt;2x2xf32&gt;&gt; into vector&lt;4x2xf32&gt;

  // Example with partial slices at dimension boundaries.
  %3 = vector.extract_slices %2, [2, 2], [1, 1]
    : vector&lt;4x3xf32&gt; into tuple&lt;vector&lt;2x2xf32&gt;, vector&lt;2x1xf32&gt;,
                                 vector&lt;2x2xf32&gt;, vector&lt;2x1xf32&gt;&gt;

  %4 = vector.insert_slices %3, [2, 2], [1, 1]
    : tuple&lt;vector&lt;2x2xf32&gt;, vector&lt;2x1xf32&gt;,
            vector&lt;2x2xf32&gt;, vector&lt;2x1xf32&gt;&gt; into vector&lt;4x3xf32&gt;
</code></pre><h4 id=operands-10>Operands:</h4><ol><li><code>vectors</code>: tuple with any combination of vector of any type values values</li></ol><h4 id=attributes-10>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>sizes</code></td><td align=center><code>ArrayAttr</code></td><td>64-bit integer array attribute attribute</td></tr><tr><td align=center><code>strides</code></td><td align=center><code>ArrayAttr</code></td><td>64-bit integer array attribute attribute</td></tr></tbody></table><h4 id=results-10>Results:</h4><ol><li>«unnamed»: vector of any type values</li></ol><h3 id=vectorinsert_strided_slice-vectorinsertstridedsliceop>vector.insert_strided_slice (vector::InsertStridedSliceOp)</h3><p>strided_slice operation</p><h4 id=description-11>Description:</h4><p>Takes a k-D source vector, an n-D destination vector (n >= k), n-sized
<code>offsets</code> integer array attribute, a k-sized <code>strides</code> integer array attribute
and inserts the k-D source vector as a strided subvector at the proper offset
into the n-D destination vector.</p><p>At the moment strides must contain only 1s.</p><p>Returns an n-D vector that is a copy of the n-D destination vector in which
the last k-D dimensions contain the k-D source vector elements strided at
the proper location as specified by the offsets.</p><p>Examples:</p><pre><code>  %2 = vector.insert_strided_slice %0, %1
      {offsets = [0, 0, 2], strides = [1, 1]}:
    vector&lt;2x4xf32&gt; into vector&lt;16x4x8xf32&gt;
</code></pre><h4 id=operands-11>Operands:</h4><ol><li><code>source</code>: vector of any type values</li><li><code>dest</code>: vector of any type values</li></ol><h4 id=attributes-11>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>offsets</code></td><td align=center><code>ArrayAttr</code></td><td>64-bit integer array attribute attribute</td></tr><tr><td align=center><code>strides</code></td><td align=center><code>ArrayAttr</code></td><td>64-bit integer array attribute attribute</td></tr></tbody></table><h4 id=results-11>Results:</h4><ol><li><code>res</code>: vector of any type values</li></ol><h3 id=vectormatrix_multiply-vectormatmulop>vector.matrix_multiply (vector::MatmulOp)</h3><p>Vector matrix multiplication op that operates on flattened 1-D MLIR vectors</p><h4 id=description-12>Description:</h4><p>This is the counterpart of llvm.matrix.multiply in MLIR. It serves the
purposes of more progressive lowering and localized type conversion.</p><p>The ‘vector.matrix_multiply’ op treats <code>lhs</code> as matrix with &lt;lhs_rows> rows
and &lt;lhs_columns> columns, <code>rhs</code> as matrix with &lt;lhs_columns> rows and
&lt;rhs_columns> and multiplies them. The result matrix is returned embedded in
the result vector.</p><p>Example:</p><pre><code>  %C = vector.matrix_multiply %A, %B
    { lhs_rows = 4: i32, lhs_columns = 16: i32 , rhs_columns = 3: i32 } :
    (vector&lt;64xf64&gt;, vector&lt;48xf64&gt;) -&gt; vector&lt;12xf64&gt;
</code></pre><h4 id=operands-12>Operands:</h4><ol><li><code>lhs</code>: vector of signless integer or signed integer or floating-point values of ranks 1</li><li><code>rhs</code>: vector of signless integer or signed integer or floating-point values of ranks 1</li></ol><h4 id=attributes-12>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs_rows</code></td><td align=center><code>IntegerAttr</code></td><td>32-bit signless integer attribute attribute</td></tr><tr><td align=center><code>lhs_columns</code></td><td align=center><code>IntegerAttr</code></td><td>32-bit signless integer attribute attribute</td></tr><tr><td align=center><code>rhs_columns</code></td><td align=center><code>IntegerAttr</code></td><td>32-bit signless integer attribute attribute</td></tr></tbody></table><h4 id=results-12>Results:</h4><ol><li><code>res</code>: vector of signless integer or signed integer or floating-point values of ranks 1</li></ol><h3 id=vectorouterproduct-vectorouterproductop>vector.outerproduct (vector::OuterProductOp)</h3><p>vector outerproduct with optional fused add</p><h4 id=description-13>Description:</h4><p>Takes 2 1-D vectors and returns the 2-D vector containing the outer-product.</p><p>An optional extra 2-D vector argument may be specified in which case the
operation returns the sum of the outer-product and the extra vector. In this
multiply-accumulate scenario, the rounding mode is that obtained by
guaranteeing that a fused-multiply add operation is emitted. When lowered to
the LLVMIR dialect, this form emits <code>llvm.intr.fma</code>, which is guaranteed to
lower to actual <code>fma</code> instructions on x86.</p><p>Examples:</p><pre><code>  %2 = vector.outerproduct %0, %1: vector&lt;4xf32&gt;, vector&lt;8xf32&gt;
  return %2: vector&lt;4x8xf32&gt;

  %3 = vector.outerproduct %0, %1, %2:
    vector&lt;4xf32&gt;, vector&lt;8xf32&gt;, vector&lt;4x8xf32&gt;
  return %3: vector&lt;4x8xf32&gt;
</code></pre><h4 id=operands-13>Operands:</h4><ol><li><code>lhs</code>: vector of any type values</li><li><code>rhs</code>: vector of any type values</li><li><code>acc</code>: vector of any type values</li></ol><h4 id=attributes-13>Attributes:</h4><h4 id=results-13>Results:</h4><ol><li>«unnamed»: vector of any type values</li></ol><h3 id=vectorprint-vectorprintop>vector.print (vector::PrintOp)</h3><p>print operation (for testing and debugging)</p><h4 id=description-14>Description:</h4><p>Prints the source vector (or scalar) to stdout in human readable
format (for testing and debugging). No return value.</p><p>Examples:</p><pre><code>  %0 = constant 0.0 : f32
  %1 = vector.broadcast %0 : f32 to vector&lt;4xf32&gt;
  vector.print %1 : vector&lt;4xf32&gt;

  when lowered to LLVM, the vector print is unrolled into
  elementary printing method calls that at runtime will yield

  ( 0.0, 0.0, 0.0, 0.0 )

  on stdout when linked with a small runtime support library,
  which only needs to provide a few printing methods (single
  value for all data types, opening/closing bracket, comma,
  newline).
</code></pre><h4 id=operands-14>Operands:</h4><ol><li><code>source</code>: any type</li></ol><h4 id=attributes-14>Attributes:</h4><h4 id=results-14>Results:</h4><h3 id=vectorreduction-vectorreductionop>vector.reduction (vector::ReductionOp)</h3><p>reduction operation</p><h4 id=description-15>Description:</h4><p>Reduces an 1-D vector &ldquo;horizontally&rdquo; into a scalar using the given
operation (add/mul/min/max for int/fp and and/or/xor for int only).
Some reductions (add/mul for fp) also allow an optional fused
accumulator.</p><p>Note that these operations are restricted to 1-D vectors to remain
close to the corresponding LLVM intrinsics:</p><p><a href=http://llvm.org/docs/LangRef.html#experimental-vector-reduction-intrinsics>http://llvm.org/docs/LangRef.html#experimental-vector-reduction-intrinsics</a></p><p>Examples:</p><pre><code>  %1 = vector.reduction &quot;add&quot;, %0 : vector&lt;16xf32&gt; into f32

  %3 = vector.reduction &quot;xor&quot;, %2 : vector&lt;4xi32&gt; into i32

  %4 = vector.reduction &quot;mul&quot;, %0, %1 : vector&lt;16xf32&gt; into f32
</code></pre><h4 id=operands-15>Operands:</h4><ol><li><code>vector</code>: vector of any type values</li><li><code>acc</code>: any type</li></ol><h4 id=attributes-15>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>kind</code></td><td align=center><code>StringAttr</code></td><td>string attribute attribute</td></tr></tbody></table><h4 id=results-15>Results:</h4><ol><li><code>dest</code>: any type</li></ol><h3 id=vectorreshape-vectorreshapeop>vector.reshape (vector::ReshapeOp)</h3><p>vector reshape operation</p><h4 id=description-16>Description:</h4><p>Reshapes its vector operand from &lsquo;input_shape&rsquo; to &lsquo;output_shape&rsquo; maintaining
fixed vector dimension &lsquo;fixed_vector_sizes&rsquo; on the innermost vector
dimensions.</p><p>The parameters &lsquo;input_shape&rsquo; and &lsquo;output_shape&rsquo; represent valid data shapes
across fixed vector shapes. For example, if a vector has a valid data
shape [6] with fixed vector size [8], then the valid data elements are
assumed to be stored at the beginning of the vector with the remaining
vector elements undefined.</p><p>In the examples below, valid data elements are represented by an alphabetic
character, and undefined data elements are represented by &lsquo;-'.</p><p>Example</p><p>vector&lt;1x8xf32> with valid data shape [6], fixed vector sizes [8]</p><pre><code>        input: [a, b, c, d, e, f]

   layout map: (d0) -&gt; (d0 floordiv 8, d0 mod 8)

vector layout: [a, b, c, d, e, f, -, -]
</code></pre><p>Example</p><p>vector&lt;2x8xf32> with valid data shape [10], fixed vector sizes [8]</p><pre><code>        input: [a, b, c, d, e, f, g, h, i, j]

   layout map: (d0) -&gt; (d0 floordiv 8, d0 mod 8)

vector layout: [[a, b, c, d, e, f, g, h],
                [i, j, -, -, -, -, -, -]]
</code></pre><p>Example</p><p>vector&lt;2x2x2x3xf32> with valid data shape [3, 5], fixed vector sizes
[2, 3]</p><pre><code>        input: [[a, b, c, d, e],
                [f, g, h, i, j],
                [k, l, m, n, o]]

   layout map: (d0, d1) -&gt; (d0 floordiv 3, d1 floordiv 5,
                            d0 mod 3, d1 mod 5)

vector layout: [[[[a, b, c],
                  [f, g, h]]
                 [[d, e, -],
                  [i, j, -]]],
                [[[k, l, m],
                  [-, -, -]]
                 [[n, o, -],
                  [-, -, -]]]]
</code></pre><p>Example</p><p>%1 = vector.reshape %0, [%c3, %c6], [%c2, %c9], [4]
: vector&lt;3x2x4xf32> to vector&lt;2x3x4xf32></p><pre><code>     input: [[a, b, c, d, e, f],
             [g, h, i, j, k, l],
             [m, n, o, p, q, r]]

layout map: (d0, d1) -&gt; (d0, d1 floordiv 4, d1 mod 4)
</code></pre><p>Input vector: [[[a, b, c, d],
[e, f, -, -]],
[[g, h, i, j],
[k, l, -, -]],
[[m, n, o, p],
[q, r, -, -]]]</p><p>Output vector: [[[a, b, c, d],
[e, f, g, h],
[i, -, -, -]],
[[j, k, l, m],
[n, o, p, q],
[r, -, -, -]]]</p><h4 id=operands-16>Operands:</h4><ol><li><code>vector</code>: vector of any type values</li><li><code>input_shape</code>: index</li><li><code>output_shape</code>: index</li></ol><h4 id=attributes-16>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>fixed_vector_sizes</code></td><td align=center><code>ArrayAttr</code></td><td>64-bit integer array attribute attribute</td></tr></tbody></table><h4 id=results-16>Results:</h4><ol><li><code>result</code>: vector of any type values</li></ol><h3 id=vectorshape_cast-vectorshapecastop>vector.shape_cast (vector::ShapeCastOp)</h3><p>shape_cast casts between vector shapes</p><h4 id=description-17>Description:</h4><p>The shape_cast operation casts between an n-D source vector shape and
a k-D result vector shape (the element type remains the same).</p><p>If reducing rank (n > k), result dimension sizes must be a product
of contiguous source dimension sizes.
If expanding rank (n &lt; k), source dimensions must factor into a
contiguous sequence of destination dimension sizes.
Each source dim is expanded (or contiguous sequence of source dims combined)
in source dimension list order (i.e. 0 &lt;= i &lt; n), to produce a contiguous
sequence of result dims (or a single result dim), in result dimension list
order (i.e. 0 &lt;= j &lt; k). The product of all source dimension sizes and all
result dimension sizes must match.</p><p>If the source/result types are a tuple of vectors, the casting operation
described above is applied to each source/result tuple element pair.</p><p>It is currently assumed that this operation does not require moving data,
and that it will be folded away before lowering vector operations.</p><p>There is an exception to the folding expectation when targeting
llvm.intr.matrix operations. We need a type conversion back and forth from a
2-D MLIR vector to a 1-D flattened LLVM vector.shape_cast lowering to LLVM
is supported in that particular case, for now.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Example casting to a lower vector rank.
</span><span class=c></span><span class=nv>%1</span> <span class=p>=</span> <span class=kt>vector</span><span class=p>.</span>shape_cast <span class=nv>%0</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>5x1x4x3x</span><span class=k>f32</span><span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;</span><span class=m>20x3x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Example casting to a higher vector rank.
</span><span class=c></span><span class=nv>%3</span> <span class=p>=</span> <span class=kt>vector</span><span class=p>.</span>shape_cast <span class=nv>%2</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>10x12x8x</span><span class=k>f32</span><span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;</span><span class=m>5x2x3x4x8x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Example casting a tuple of vectors of same rank, where tuple elements
</span><span class=c></span><span class=c>// may have different shapes.
</span><span class=c></span><span class=nv>%5</span> <span class=p>=</span> <span class=kt>vector</span><span class=p>.</span>shape_cast <span class=nv>%4</span> <span class=p>:</span> tuple<span class=p>&lt;</span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x4x2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x3x2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>&gt;</span> to
                            tuple<span class=p>&lt;</span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>12x2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>9x2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-17>Operands:</h4><ol><li><code>source</code>: vector of any type values or tuple with any combination of vector of any type values values</li></ol><h4 id=attributes-17>Attributes:</h4><h4 id=results-17>Results:</h4><ol><li><code>result</code>: vector of any type values or tuple with any combination of vector of any type values values</li></ol><h3 id=vectorshuffle-vectorshuffleop>vector.shuffle (vector::ShuffleOp)</h3><p>shuffle operation</p><h4 id=description-18>Description:</h4><p>The shuffle operation constructs a permutation (or duplication) of elements
from two input vectors, returning a vector with the same element type as
the input and a length that is the same as the shuffle mask. The two input
vectors must have the same element type, rank, and trailing dimension sizes
and shuffles their values in the leading dimension (which may differ in size)
according to the given mask. The legality rules are:</p><ul><li>the two operands must have the same element type as the result</li><li>the two operands and the result must have the same rank and trailing
dimension sizes, viz. given two k-D operands
v1 : &lt;s_1 x s_2 x .. x s_k x type> and
v2 : &lt;t_1 x t_2 x .. x t_k x type>
we have s_i = t_i for all 1 &lt; i &lt;= k</li><li>the mask length equals the leading dimension size of the result</li><li>numbering the input vector indices left to right across the operands, all
mask values must be within range, viz. given two k-D operands v1 and v2
above, all mask values are in the range [0,s_1+t_1)</li></ul><p>Examples:</p><pre><code>%0 = vector.shuffle %a, %b[0, 3]
           : vector&lt;2xf32&gt;, vector&lt;2xf32&gt;       ; yields vector&lt;2xf32&gt;
%1 = vector.shuffle %c, %b[0, 1, 2]
           : vector&lt;2x16xf32&gt;, vector&lt;1x16xf32&gt; ; yields vector&lt;3x16xf32&gt;
%2 = vector.shuffle %a, %b[3, 2, 1, 0]
           : vector&lt;2xf32&gt;, vector&lt;2xf32&gt;       ; yields vector&lt;4xf32&gt;

</code></pre><h4 id=operands-18>Operands:</h4><ol><li><code>v1</code>: vector of any type values</li><li><code>v2</code>: vector of any type values</li></ol><h4 id=attributes-18>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>mask</code></td><td align=center><code>ArrayAttr</code></td><td>64-bit integer array attribute attribute</td></tr></tbody></table><h4 id=results-18>Results:</h4><ol><li><code>vector</code>: vector of any type values</li></ol><h3 id=vectorstrided_slice-vectorstridedsliceop>vector.strided_slice (vector::StridedSliceOp)</h3><p>strided_slice operation</p><h4 id=description-19>Description:</h4><p>Takes an n-D vector, k-D <code>offsets</code> integer array attribute, a k-sized
<code>sizes</code> integer array attribute, a k-sized <code>strides</code> integer array
attribute and extracts the n-D subvector at the proper offset.</p><p>At the moment strides must contain only 1s.
// TODO(ntv) support non-1 strides.</p><p>Returns an n-D vector where the first k-D dimensions match the <code>sizes</code>
attribute. The returned subvector contains the elements starting at offset
<code>offsets</code> and ending at <code>offsets + sizes</code>.</p><p>Examples:</p><pre><code>  %1 = vector.strided_slice %0
      {offsets = [0, 2], sizes = [2, 4], strides = [1, 1]}:
    vector&lt;4x8x16xf32&gt; to vector&lt;2x4x16xf32&gt;
</code></pre><p>// TODO(ntv) Evolve to a range form syntax similar to:
%1 = vector.strided_slice %0[0:2:1][2:4:1]
vector&lt;4x8x16xf32> to vector&lt;2x4x16xf32></p><h4 id=operands-19>Operands:</h4><ol><li><code>vector</code>: vector of any type values</li></ol><h4 id=attributes-19>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>offsets</code></td><td align=center><code>ArrayAttr</code></td><td>64-bit integer array attribute attribute</td></tr><tr><td align=center><code>sizes</code></td><td align=center><code>ArrayAttr</code></td><td>64-bit integer array attribute attribute</td></tr><tr><td align=center><code>strides</code></td><td align=center><code>ArrayAttr</code></td><td>64-bit integer array attribute attribute</td></tr></tbody></table><h4 id=results-19>Results:</h4><ol><li>«unnamed»: vector of any type values</li></ol><h3 id=vectortransfer_read-vectortransferreadop>vector.transfer_read (vector::TransferReadOp)</h3><p>Reads a supervector from memory into an SSA vector value.</p><h4 id=description-20>Description:</h4><p>The <code>vector.transfer_read</code> op performs a blocking read from a slice within
a
<a href=/docs/LangRef/#memref-type>MemRef</a>
supplied as its first operand
into a
<a href=/docs/LangRef/#vector-type>vector</a>
of the same base elemental type.</p><p>A memref operand with vector element type, must have its vector element
type match a suffix (shape and element type) of the vector (e.g.
memref&lt;3x2x6x4x3xf32>, vector&lt;1x1x4x3xf32>).</p><p>The slice is further defined by a full-rank index within the MemRef,
supplied as the operands <code>2 .. 1 + rank(memref)</code>. The permutation_map
<a href=/docs/LangRef/#attributes>attribute</a>
is an
<a href=/docs/Dialects/Affine/#affine-maps>affine-map</a>
which specifies the transposition on the
slice to match the vector shape. The size of the slice is specified by the
size of the vector, given as the return type. An <code>ssa-value</code> of the same
elemental type as the MemRef is provided as the last operand to specify
padding in the case of out-of-bounds accesses. This operation is called
&lsquo;read&rsquo; by opposition to &lsquo;load&rsquo; because the super-vector granularity is
generally not representable with a single hardware register.
A <code>vector.transfer_read</code> is thus a mid-level
abstraction that supports super-vectorization with non-effecting padding for
full-tile-only code.</p><p>More precisely, let&rsquo;s dive deeper into the permutation_map for the following
MLIR:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>vector</span><span class=p>.</span>transfer_read <span class=nv>%A</span><span class=p>[</span><span class=nv>%expr1</span><span class=p>,</span> <span class=nv>%expr2</span><span class=p>,</span> <span class=nv>%expr3</span><span class=p>,</span> <span class=nv>%expr4</span><span class=p>]</span>
  <span class=p>{</span> permutation_map <span class=p>:</span> <span class=p>(</span>d0<span class=p>,</span>d1<span class=p>,</span>d2<span class=p>,</span>d3<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d2<span class=p>,</span><span class=m>0</span><span class=p>,</span>d0<span class=p>)</span> <span class=p>}</span> <span class=p>:</span>
  <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x?x?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x4x5x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><p>This operation always reads a slice starting at <code>%A[%expr1, %expr2, %expr3, %expr4]</code>. The size of the slice is 3 along d2 and 5 along d0, so the slice
is: <code>%A[%expr1 : %expr1 + 5, %expr2, %expr3:%expr3 + 3, %expr4]</code></p><p>That slice needs to be read into a <code>vector&lt;3x4x5xf32></code>. Since the
permutation map is not full rank, there must be a broadcast along vector
dimension <code>1</code>.</p><p>A notional lowering of vector.transfer_read could generate code resembling:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// %expr1, %expr2, %expr3, %expr4 defined before this point
</span><span class=c></span><span class=nv>%tmp</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x4x5x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=nv>%view_in_tmp</span> <span class=p>=</span> <span class=s>&#34;element_type_cast&#34;</span><span class=p>(</span><span class=nv>%tmp</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1x</span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x4x5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>&gt;</span>
for <span class=nv>%i</span> <span class=p>=</span> <span class=m>0</span> to <span class=m>3</span> <span class=p>{</span>
  affine<span class=p>.</span>for <span class=nv>%j</span> <span class=p>=</span> <span class=m>0</span> to <span class=m>4</span> <span class=p>{</span>
    affine<span class=p>.</span>for <span class=nv>%k</span> <span class=p>=</span> <span class=m>0</span> to <span class=m>5</span> <span class=p>{</span>
      <span class=nv>%a</span> <span class=p>=</span> load <span class=nv>%A</span><span class=p>[</span><span class=nv>%expr1</span> <span class=err>+</span> <span class=nv>%k</span><span class=p>,</span> <span class=nv>%expr2</span><span class=p>,</span> <span class=nv>%expr3</span> <span class=err>+</span> <span class=nv>%i</span><span class=p>,</span> <span class=nv>%expr4</span><span class=p>]</span> <span class=p>:</span>
        <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
      store <span class=nv>%tmp</span><span class=p>[</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>,</span> <span class=nv>%k</span><span class=p>]</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x4x5x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=p>}</span><span class=p>}</span><span class=p>}</span>
<span class=nv>%c0</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>index</span>
<span class=nv>%vec</span> <span class=p>=</span> load <span class=nv>%view_in_tmp</span><span class=p>[</span><span class=nv>%c0</span><span class=p>]</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x4x5x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><p>On a GPU one could then map <code>i</code>, <code>j</code>, <code>k</code> to blocks and threads. Notice that
the temporary storage footprint is <code>3 * 5</code> values but <code>3 * 4 * 5</code> values are
actually transferred between <code>%A</code> and <code>%tmp</code>.</p><p>Alternatively, if a notional vector broadcast operation were available, the
lowered code would resemble:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// %expr1, %expr2, %expr3, %expr4 defined before this point
</span><span class=c></span><span class=nv>%tmp</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x4x5x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=nv>%view_in_tmp</span> <span class=p>=</span> <span class=s>&#34;element_type_cast&#34;</span><span class=p>(</span><span class=nv>%tmp</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1x</span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x4x5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>&gt;</span>
for <span class=nv>%i</span> <span class=p>=</span> <span class=m>0</span> to <span class=m>3</span> <span class=p>{</span>
  affine<span class=p>.</span>for <span class=nv>%k</span> <span class=p>=</span> <span class=m>0</span> to <span class=m>5</span> <span class=p>{</span>
    <span class=nv>%a</span> <span class=p>=</span> load <span class=nv>%A</span><span class=p>[</span><span class=nv>%expr1</span> <span class=err>+</span> <span class=nv>%k</span><span class=p>,</span> <span class=nv>%expr2</span><span class=p>,</span> <span class=nv>%expr3</span> <span class=err>+</span> <span class=nv>%i</span><span class=p>,</span> <span class=nv>%expr4</span><span class=p>]</span> <span class=p>:</span>
      <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
    store <span class=nv>%tmp</span><span class=p>[</span><span class=nv>%i</span><span class=p>,</span> <span class=m>0</span><span class=p>,</span> <span class=nv>%k</span><span class=p>]</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x4x5x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=p>}</span><span class=p>}</span>
<span class=nv>%c0</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>index</span>
<span class=nv>%tmpvec</span> <span class=p>=</span> load <span class=nv>%view_in_tmp</span><span class=p>[</span><span class=nv>%c0</span><span class=p>]</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x4x5x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=nv>%vec</span> <span class=p>=</span> broadcast <span class=nv>%tmpvec</span><span class=p>,</span> <span class=m>1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x4x5x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><p>where <code>broadcast</code> broadcasts from element 0 to all others along the
specified dimension. This time, the temporary storage footprint is <code>3 * 5</code>
values which is the same amount of data as the <code>3 * 5</code> values transferred.
An additional <code>1</code> broadcast is required. On a GPU this broadcast could be
implemented using a warp-shuffle if loop <code>j</code> were mapped to <code>threadIdx.x</code>.</p><p>Syntax</p><pre><code>operation ::= ssa-id `=` `vector.transfer_read` ssa-use-list
  `{` attribute-entry `} :` memref-type `,` vector-type
</code></pre><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Read the slice `%A[%i0, %i1:%i1+256, %i2:%i2+32]` into vector&lt;32x256xf32&gt;
</span><span class=c></span><span class=c>// and pad with %f0 to handle the boundary case:
</span><span class=c></span><span class=nv>%f0</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>0.0</span>f <span class=p>:</span> <span class=k>f32</span>
for <span class=nv>%i0</span> <span class=p>=</span> <span class=m>0</span> to <span class=nv>%0</span> <span class=p>{</span>
  affine<span class=p>.</span>for <span class=nv>%i1</span> <span class=p>=</span> <span class=m>0</span> to <span class=nv>%1</span> step <span class=m>256</span> <span class=p>{</span>
    affine<span class=p>.</span>for <span class=nv>%i2</span> <span class=p>=</span> <span class=m>0</span> to <span class=nv>%2</span> step <span class=m>32</span> <span class=p>{</span>
      <span class=nv>%v</span> <span class=p>=</span> <span class=kt>vector</span><span class=p>.</span>transfer_read <span class=nv>%A</span><span class=p>[</span><span class=nv>%i0</span><span class=p>,</span> <span class=nv>%i1</span><span class=p>,</span> <span class=nv>%i2</span><span class=p>]</span><span class=p>,</span> <span class=p>(</span><span class=nv>%f0</span><span class=p>)</span>
           <span class=p>{</span>permutation_map<span class=p>:</span> <span class=p>(</span>d0<span class=p>,</span> d1<span class=p>,</span> d2<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d2<span class=p>,</span> d1<span class=p>)</span><span class=p>}</span> <span class=p>:</span>
           <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>32x256x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=p>}</span><span class=p>}</span><span class=p>}</span>

<span class=c>// Read the slice `%A[%i0, %i1]` (i.e. the element `%A[%i0, %i1]`) into
</span><span class=c></span><span class=c>// vector&lt;128xf32&gt;. The underlying implementation will require a 1-D vector
</span><span class=c></span><span class=c>// broadcast:
</span><span class=c></span>for <span class=nv>%i0</span> <span class=p>=</span> <span class=m>0</span> to <span class=nv>%0</span> <span class=p>{</span>
  affine<span class=p>.</span>for <span class=nv>%i1</span> <span class=p>=</span> <span class=m>0</span> to <span class=nv>%1</span> <span class=p>{</span>
    <span class=nv>%3</span> <span class=p>=</span> <span class=kt>vector</span><span class=p>.</span>transfer_read <span class=nv>%A</span><span class=p>[</span><span class=nv>%i0</span><span class=p>,</span> <span class=nv>%i1</span><span class=p>]</span>
         <span class=p>{</span>permutation_map<span class=p>:</span> <span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=m>0</span><span class=p>)</span><span class=p>}</span> <span class=p>:</span>
         <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>128x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=p>}</span>
<span class=p>}</span>

<span class=c>// Read from a memref with vector element type.
</span><span class=c></span><span class=nv>%4</span> <span class=p>=</span> <span class=kt>vector</span><span class=p>.</span>transfer_read <span class=nv>%arg1</span><span class=p>[</span><span class=nv>%c3</span><span class=p>,</span> <span class=nv>%c3</span><span class=p>]</span><span class=p>,</span> <span class=nv>%vf0</span>
  <span class=p>{</span><span class=nl>permutation_map =</span> <span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span><span class=p>-&gt;</span><span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span><span class=p>}</span>
    <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x3x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>1x1x4x3x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-20>Operands:</h4><ol><li><code>memref</code>: memref of any type values</li><li><code>indices</code>: index</li><li><code>padding</code>: any type</li></ol><h4 id=attributes-20>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>permutation_map</code></td><td align=center><code>AffineMapAttr</code></td><td>AffineMap attribute attribute</td></tr></tbody></table><h4 id=results-20>Results:</h4><ol><li><code>vector</code>: vector of any type values</li></ol><h3 id=vectortransfer_write-vectortransferwriteop>vector.transfer_write (vector::TransferWriteOp)</h3><p>The vector.transfer_write op writes a supervector to memory.</p><h4 id=description-21>Description:</h4><p>The <code>vector.transfer_write</code> performs a blocking write from a
<a href=/docs/LangRef/#vector-type>vector</a>
, supplied as its first operand, into a
slice within a
<a href=/docs/LangRef/#memref-type>MemRef</a>
of the same base
elemental type, supplied as its second operand.</p><p>A vector memref operand must have its vector element type match a suffix
(shape and element type) of the vector (e.g. memref&lt;3x2x6x4x3xf32>,
vector&lt;1x1x4x3xf32>).</p><p>The slice is further defined by a full-rank index within the MemRef,
supplied as the operands <code>3 .. 2 + rank(memref)</code>.
The permutation_map
<a href=/docs/LangRef/#attributes>attribute</a>
is an
<a href=/docs/Dialects/Affine/#affine-maps>affine-map</a>
which specifies the transposition on the
slice to match the vector shape. The size of the slice is specified by the
size of the vector. This operation is called &lsquo;write&rsquo; by opposition to
&lsquo;store&rsquo; because the super-vector granularity is generally not representable
with a single hardware register. A <code>vector.transfer_write</code> is thus a
mid-level abstraction that supports super-vectorization with non-effecting
padding for full-tile-only code. It is the responsibility of
<code>vector.transfer_write</code>'s implementation to ensure the memory writes are
valid. Different lowerings may be pertinent depending on the hardware
support.</p><p>Syntax:</p><pre><code>operation ::= `vector.transfer_write` ssa-use-list `{` attribute-entry `} :
  ` vector-type ', ' memref-type '
</code></pre><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// write vector&lt;16x32x64xf32&gt; into the slice
</span><span class=c></span><span class=c>//   `%A[%i0, %i1:%i1+32, %i2:%i2+64, %i3:%i3+16]`:
</span><span class=c></span>for <span class=nv>%i0</span> <span class=p>=</span> <span class=m>0</span> to <span class=nv>%0</span> <span class=p>{</span>
  affine<span class=p>.</span>for <span class=nv>%i1</span> <span class=p>=</span> <span class=m>0</span> to <span class=nv>%1</span> step <span class=m>32</span> <span class=p>{</span>
    affine<span class=p>.</span>for <span class=nv>%i2</span> <span class=p>=</span> <span class=m>0</span> to <span class=nv>%2</span> step <span class=m>64</span> <span class=p>{</span>
      affine<span class=p>.</span>for <span class=nv>%i3</span> <span class=p>=</span> <span class=m>0</span> to <span class=nv>%3</span> step <span class=m>16</span> <span class=p>{</span>
        <span class=nv>%val</span> <span class=p>=</span> <span class=err>`</span>ssa<span class=err>-</span>value<span class=err>`</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>16x32x64x</span><span class=k>f32</span><span class=p>&gt;</span>
        <span class=kt>vector</span><span class=p>.</span>transfer_write <span class=nv>%val</span><span class=p>,</span> <span class=nv>%A</span><span class=p>[</span><span class=nv>%i0</span><span class=p>,</span> <span class=nv>%i1</span><span class=p>,</span> <span class=nv>%i2</span><span class=p>,</span> <span class=nv>%i3</span><span class=p>]</span>
          <span class=p>{</span>permutation_map<span class=p>:</span> <span class=p>(</span>d0<span class=p>,</span> d1<span class=p>,</span> d2<span class=p>,</span> d3<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d3<span class=p>,</span> d1<span class=p>,</span> d2<span class=p>)</span><span class=p>}</span> <span class=p>:</span>
          <span class=kt>vector</span><span class=p>&lt;</span><span class=m>16x32x64x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=p>}</span><span class=p>}</span><span class=p>}</span><span class=p>}</span>

<span class=c>// write to a memref with vector element type.
</span><span class=c></span><span class=kt>vector</span><span class=p>.</span>transfer_write <span class=nv>%4</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>[</span><span class=nv>%c3</span><span class=p>,</span> <span class=nv>%c3</span><span class=p>]</span>
  <span class=p>{</span><span class=nl>permutation_map =</span> <span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span><span class=p>-&gt;</span><span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span><span class=p>}</span>
    <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>1x1x4x3x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x3x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-21>Operands:</h4><ol><li><code>vector</code>: vector of any type values</li><li><code>memref</code>: memref of any type values</li><li><code>indices</code>: index</li></ol><h4 id=attributes-21>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>permutation_map</code></td><td align=center><code>AffineMapAttr</code></td><td>AffineMap attribute attribute</td></tr></tbody></table><h4 id=results-21>Results:</h4><h3 id=vectortuple_get-vectortuplegetop>vector.tuple_get (vector::TupleGetOp)</h3><p>vector tuple get operation</p><h4 id=description-22>Description:</h4><p>Returns the tuple element of &lsquo;vectors&rsquo; at &lsquo;index&rsquo;.</p><p>Note that this operation is used during the vector op unrolling
transformation and should be removed before lowering to lower-level
dialects.</p><p>Examples:</p><pre><code>  %4 = vector.tuple %0, %1, %2, %3
    : vector&lt;2x2xf32&gt;, vector&lt;2x1xf32&gt;, vector&lt;2x2xf32&gt;, vector&lt;2x1xf32&gt;&gt;

  %5 = vector.tuple_get %4, 1
    : tuple&lt;vector&lt;2x2xf32&gt;, vector&lt;2x1xf32&gt;,
            vector&lt;2x2xf32&gt;, vector&lt;2x1xf32&gt;&gt;
</code></pre><h4 id=operands-22>Operands:</h4><ol><li><code>vectors</code>: tuple with any combination of vector of any type values values</li></ol><h4 id=attributes-22>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>index</code></td><td align=center><code>IntegerAttr</code></td><td>arbitrary integer attribute attribute</td></tr></tbody></table><h4 id=results-22>Results:</h4><ol><li>«unnamed»: vector of any type values</li></ol><h3 id=vectortuple-vectortupleop>vector.tuple (vector::TupleOp)</h3><p>make tuple of vectors operation</p><h4 id=description-23>Description:</h4><p>Returns a tuple of its operands &lsquo;vectors&rsquo;.</p><p>Note that this operation is used during the vector op unrolling
transformation and should be removed before lowering to lower-level
dialects.</p><p>Examples:</p><pre><code>  %0 = vector.transfer_read ... : vector&lt;2x2xf32&gt;
  %1 = vector.transfer_read ... : vector&lt;2x1xf32&gt;
  %2 = vector.transfer_read ... : vector&lt;2x2xf32&gt;
  %3 = vector.transfer_read ... : vector&lt;2x1xf32&gt;

  %4 = vector.tuple %0, %1, %2, %3
    : vector&lt;2x2xf32&gt;, vector&lt;2x1xf32&gt;, vector&lt;2x2xf32&gt;, vector&lt;2x1xf32&gt;

</code></pre><h4 id=operands-23>Operands:</h4><ol><li><code>vectors</code>: vector of any type values</li></ol><h4 id=attributes-23>Attributes:</h4><h4 id=results-23>Results:</h4><ol><li>«unnamed»: tuple with any combination of vector of any type values values</li></ol><h3 id=vectortype_cast-vectortypecastop>vector.type_cast (vector::TypeCastOp)</h3><p>type_cast op converts a scalar memref to a vector memref</p><h4 id=description-24>Description:</h4><p>Performs a conversion from a memref with scalar element to a memref with a
<em>single</em> vector element, copying the shape of the memref to the vector. This
is the minimal viable operation that is required to makeke
super-vectorization operational. It can be seen as a special case of the
<code>view</code> operation but scoped in the super-vectorization context.</p><p>Syntax:</p><pre><code>operation ::= `vector.type_cast` ssa-use : memref-type to memref-type
</code></pre><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%A</span>  <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x4x3x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=nv>%VA</span> <span class=p>=</span> <span class=kt>vector</span><span class=p>.</span>type_cast <span class=nv>%A</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x4x3x</span><span class=k>f32</span><span class=p>&gt;</span> to <span class=kt>memref</span><span class=p>&lt;</span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>5x4x3x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-24>Operands:</h4><ol><li><code>memref</code>: statically shaped memref of any type values</li></ol><h4 id=attributes-24>Attributes:</h4><h4 id=results-24>Results:</h4><ol><li>«unnamed»: memref of any type values</li></ol><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Dialects/SPIRVOps/ title="Dialect 'spv' definition"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Dialect 'spv' definition</a>
<a class="nav nav-next" href=/docs/Dialects/GPU/ title="GPU Dialect">Next - GPU Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class="parent has-sub-menu"><a href=/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Affine/>Affine Dialect</a></li><li><a href=/docs/Dialects/AffineOps/>Dialect 'affine' definition</a></li><li><a href=/docs/Dialects/FxpMathOps/>Dialect 'fxpmath' definition</a></li><li><a href=/docs/Dialects/GPUOps/>Dialect 'gpu' definition</a></li><li><a href=/docs/Dialects/LinalgDoc/>Dialect 'linalg' definition</a></li><li><a href=/docs/Dialects/LoopOps/>Dialect 'loop' definition</a></li><li><a href=/docs/Dialects/NVVMOps/>Dialect 'nvvm' definition</a></li><li><a href=/docs/Dialects/OpenMPOps/>Dialect 'omp' definition</a></li><li><a href=/docs/Dialects/QuantOps/>Dialect 'quant' definition</a></li><li><a href=/docs/Dialects/ROCDLOps/>Dialect 'rocdl' definition</a></li><li><a href=/docs/Dialects/SPIRVOps/>Dialect 'spv' definition</a></li><li class=active><a href=/docs/Dialects/VectorOps/>Dialect 'vector' definition</a></li><li><a href=/docs/Dialects/GPU/>GPU Dialect</a></li><li><a href=/docs/Dialects/Linalg/>Linalg Dialect</a></li><li><a href=/docs/Dialects/LLVM/>LLVM IR Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=/docs/Dialects/Standard/>Standard Dialect</a></li><li><a href=/docs/Dialects/Vector/>Vector Dialect</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Tutorial Introduction</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/EDSC/>Background: declarative builders API</a></li><li><a href=/docs/ConversionToLLVMDialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li><a href=/docs/Diagnostics/>Introduction and Usage Guide to MLIR's Diagnostics Infrastructure</a></li><li><a href=/docs/Interfaces/>Introduction to MLIR Interfaces</a></li><li><a href=/docs/Traits/>Introduction to MLIR Operation Traits</a></li><li><a href=/docs/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/GenericDAGRewriter/>MLIR Generic DAG Rewriter Infrastructure</a></li><li><a href=/docs/Passes/>MLIR Passes</a></li><li><a href=/docs/Quantization/>MLIR Quantization</a></li><li><a href=/docs/Rationale/>MLIR Rationale</a></li><li><a href=/docs/LangRef/>MLIR Specification</a></li><li><a href=/docs/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization in MLIR</a></li><li><a href=/docs/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li><a href=/docs/DefiningAttributesAndTypes/>Quickstart tutorial to defining custom dialect attributes and types</a></li><li><a href=/docs/ShapeInference/>Shape inference</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/OpDefinitions/>Table-driven Operation Definition Specification (ODS)</a></li><li><a href=/docs/UsageOfConst/>Usage of 'Const' in MLIR, for core IR types</a></li><li><a href=/docs/WritingAPass/>Writing a Pass</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>