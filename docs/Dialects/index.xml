<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dialects on MLIR</title><link>https://mlir.llvm.org/docs/Dialects/</link><description>Recent content in Dialects on MLIR</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 29 Nov 2019 15:26:15 +0000</lastBuildDate><atom:link href="https://mlir.llvm.org/docs/Dialects/index.xml" rel="self" type="application/rss+xml"/><item><title>Affine Dialect</title><link>https://mlir.llvm.org/docs/Dialects/Affine/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/Affine/</guid><description>This dialect provides a powerful abstraction for affine operations and analyses.
Polyhedral Structures Dimensions and Symbols Restrictions on Dimensions and Symbols Affine Expressions Affine Maps Semi-affine maps Integer Sets Operations Polyhedral Structures MLIR uses techniques from polyhedral compilation to make dependence analysis and loop transformations efficient and reliable. This section introduces some of the core concepts that are used throughout the document.</description></item><item><title>Dialect 'affine' definition</title><link>https://mlir.llvm.org/docs/Dialects/AffineOps/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/AffineOps/</guid><description>Operation definition affine.apply (AffineApplyOp) affine.for (AffineForOp) affine.if (AffineIfOp) affine.max (AffineMaxOp) affine.min (AffineMinOp) affine.parallel (AffineParallelOp) affine.prefetch (AffinePrefetchOp) affine.terminator (AffineTerminatorOp) Operation definition affine.apply (AffineApplyOp) affine apply operation
Description: The affine.apply operation applies an affine mapping to a list of SSA values, yielding a single SSA value. The number of dimension and symbol arguments to affine.apply must be equal to the respective number of dimensional and symbolic inputs to the affine mapping; the affine mapping has to be one-dimensional, and so the affine.</description></item><item><title>Dialect 'fxpmath' definition</title><link>https://mlir.llvm.org/docs/Dialects/FxpMathOps/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/FxpMathOps/</guid><description>Operation definition fxpmath.clampis (fxpmath::ClampISOp) fxpmath.convertis (fxpmath::ConvertISOp) fxpmath.convertistof (fxpmath::ConvertISToFOp) fxpmath.real_add_ew (fxpmath::RealAddEwOp) fxpmath.compare (fxpmath::RealCompareZeroEwOp) fxpmath.real_div_ew (fxpmath::RealDivEwOp) fxpmath.real_matmul_bias (fxpmath::RealMatMulBiasOp) fxpmath.real_matmul (fxpmath::RealMatMulOp) fxpmath.real_mul_ew (fxpmath::RealMulEwOp) fxpmath.real_sub_ew (fxpmath::RealSubEwOp) fxpmath.real_unary_ew (fxpmath::RealUnaryEwOp) fxpmath.rounding_divide_by_potis (fxpmath::RoundingDivideByPotISOp) fxpmath.vs_saturating_rounding_doubling_high_mulis (fxpmath::VecScalarSaturatingRoundingDoublingHighMulISOp) Operation definition fxpmath.clampis (fxpmath::ClampISOp) Clamps a signed-integer like argument to a min/max range.
Description: Element-wise equivalent to: r = std::min(clamp_max, std::max(e, clamp_min))
Operands: operand: signless-integer-like Attributes: Attribute MLIR Type Description clamp_min IntegerAttr arbitrary integer attribute attribute clamp_max IntegerAttr arbitrary integer attribute attribute Results: «unnamed»: signless-integer-like fxpmath.</description></item><item><title>Dialect 'gpu' definition</title><link>https://mlir.llvm.org/docs/Dialects/GPUOps/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/GPUOps/</guid><description>Operation definition gpu.all_reduce (gpu::AllReduceOp) gpu.barrier (gpu::BarrierOp) gpu.block_dim (gpu::BlockDimOp) gpu.block_id (gpu::BlockIdOp) gpu.func (gpu::GPUFuncOp) gpu.module (gpu::GPUModuleOp) gpu.grid_dim (gpu::GridDimOp) gpu.launch_func (gpu::LaunchFuncOp) gpu.launch (gpu::LaunchOp) gpu.module_end (gpu::ModuleEndOp) gpu.return (gpu::ReturnOp) gpu.shuffle (gpu::ShuffleOp) gpu.terminator (gpu::TerminatorOp) gpu.thread_id (gpu::ThreadIdOp) gpu.yield (gpu::YieldOp) Operation definition gpu.all_reduce (gpu::AllReduceOp) Reduce values among workgroup.
Description: The &amp;ldquo;all_reduce&amp;rdquo; op reduces the value of every work item across a local workgroup. The result is equal for all work items of a workgroup.</description></item><item><title>Dialect 'linalg' definition</title><link>https://mlir.llvm.org/docs/Dialects/LinalgDoc/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/LinalgDoc/</guid><description>The linalg dialect groups together a set of types, operations and transformations that are useful to implement a structured abstraction on buffers and tensors. These abstractions are useful for transformations and can lower to scalar load/store and other operations or to more general library calls.
Additional Linalg Dialect Documentation and a Rationale Document are are also available and should be read first before going in the details of the op semantics.</description></item><item><title>Dialect 'loop' definition</title><link>https://mlir.llvm.org/docs/Dialects/LoopOps/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/LoopOps/</guid><description>Operation definition loop.for (ForOp) loop.if (IfOp) loop.parallel (ParallelOp) loop.reduce (ReduceOp) loop.reduce.return (ReduceReturnOp) loop.yield (YieldOp) Operation definition loop.for (ForOp) for operation
Description: The &amp;ldquo;loop.for&amp;rdquo; operation represents a loop taking 3 SSA value as operands that represent the lower bound, upper bound and step respectively. The operation defines an SSA value for its induction variable. It has one region capturing the loop body. The induction variable is represented as an argument of this region.</description></item><item><title>Dialect 'nvvm' definition</title><link>https://mlir.llvm.org/docs/Dialects/NVVMOps/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/NVVMOps/</guid><description>Operation definition nvvm.barrier0 (NVVM::Barrier0Op) nvvm.read.ptx.sreg.ntid.x (NVVM::BlockDimXOp) nvvm.read.ptx.sreg.ntid.y (NVVM::BlockDimYOp) nvvm.read.ptx.sreg.ntid.z (NVVM::BlockDimZOp) nvvm.read.ptx.sreg.ctaid.x (NVVM::BlockIdXOp) nvvm.read.ptx.sreg.ctaid.y (NVVM::BlockIdYOp) nvvm.read.ptx.sreg.ctaid.z (NVVM::BlockIdZOp) nvvm.read.ptx.sreg.nctaid.x (NVVM::GridDimXOp) nvvm.read.ptx.sreg.nctaid.y (NVVM::GridDimYOp) nvvm.read.ptx.sreg.nctaid.z (NVVM::GridDimZOp) nvvm.read.ptx.sreg.laneid (NVVM::LaneIdOp) nvvm.mma.sync (NVVM::MmaOp) nvvm.shfl.sync.bfly (NVVM::ShflBflyOp) nvvm.read.ptx.sreg.tid.x (NVVM::ThreadIdXOp) nvvm.read.ptx.sreg.tid.y (NVVM::ThreadIdYOp) nvvm.read.ptx.sreg.tid.z (NVVM::ThreadIdZOp) nvvm.vote.ballot.sync (NVVM::VoteBallotOp) nvvm.read.ptx.sreg.warpsize (NVVM::WarpSizeOp) Operation definition nvvm.barrier0 (NVVM::Barrier0Op) Description: Operands: Attributes: Results: nvvm.read.ptx.sreg.ntid.x (NVVM::BlockDimXOp) Description: Operands: Attributes: Results: res: LLVM dialect type nvvm.read.ptx.sreg.ntid.y (NVVM::BlockDimYOp) Description: Operands: Attributes: Results: res: LLVM dialect type nvvm.</description></item><item><title>Dialect 'omp' definition</title><link>https://mlir.llvm.org/docs/Dialects/OpenMPOps/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/OpenMPOps/</guid><description> Operation definition omp.barrier (omp::BarrierOp) Operation definition omp.barrier (omp::BarrierOp) barrier construct
Description: The barrier construct specifies an explicit barrier at the point at which the construct appears.
Operands: Attributes: Results:</description></item><item><title>Dialect 'quant' definition</title><link>https://mlir.llvm.org/docs/Dialects/QuantOps/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/QuantOps/</guid><description>Type definition UniformQuantizedType Operation definition quant.const_fake_quant (quant::ConstFakeQuant) quant.const_fake_quant_per_axis (quant::ConstFakeQuantPerAxis) quant.coupled_ref (quant::CoupledRefOp) quant.dcast (quant::DequantizeCastOp) quant.qcast (quant::QuantizeCastOp) quant.region (quant::QuantizeRegionOp) quant.return (quant::ReturnOp) quant.stats (quant::StatisticsOp) Type definition UniformQuantizedType Operation definition quant.const_fake_quant (quant::ConstFakeQuant) Simulates the effect of uniform quantization with const range.
Description: Given a const min, max, num_bits and narrow_range attribute, applies the same uniform quantization simulation as is done by the TensorFlow fake_quant_with_min_max_args op. See the fakeQuantAttrsToType() utility method and the quant-convert-simulated-quantization pass for futher details.</description></item><item><title>Dialect 'rocdl' definition</title><link>https://mlir.llvm.org/docs/Dialects/ROCDLOps/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/ROCDLOps/</guid><description>Operation definition rocdl.workgroup.dim.x (ROCDL::BlockDimXOp) rocdl.workgroup.dim.y (ROCDL::BlockDimYOp) rocdl.workgroup.dim.z (ROCDL::BlockDimZOp) rocdl.workgroup.id.x (ROCDL::BlockIdXOp) rocdl.workgroup.id.y (ROCDL::BlockIdYOp) rocdl.workgroup.id.z (ROCDL::BlockIdZOp) rocdl.grid.dim.x (ROCDL::GridDimXOp) rocdl.grid.dim.y (ROCDL::GridDimYOp) rocdl.grid.dim.z (ROCDL::GridDimZOp) rocdl.workitem.id.x (ROCDL::ThreadIdXOp) rocdl.workitem.id.y (ROCDL::ThreadIdYOp) rocdl.workitem.id.z (ROCDL::ThreadIdZOp) Operation definition rocdl.workgroup.dim.x (ROCDL::BlockDimXOp) Description: Operands: Attributes: Results: res: LLVM dialect type rocdl.workgroup.dim.y (ROCDL::BlockDimYOp) Description: Operands: Attributes: Results: res: LLVM dialect type rocdl.workgroup.dim.z (ROCDL::BlockDimZOp) Description: Operands: Attributes: Results: res: LLVM dialect type rocdl.</description></item><item><title>Dialect 'shape' definition</title><link>https://mlir.llvm.org/docs/Dialects/ShapeOps/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/ShapeOps/</guid><description>Types and operations for shape dialect
This dialect contains operations for shape inference.
Note: Unless explicitly stated, all functions that return a shape and take shapes as input, return the invalid shape if one of its operands is an invalid shape. This avoids flagging multiple errors for one verification failure. The dialect itself does not specify how errors should be combined (there are multiple different options, from always chosing first operand, concatting etc.</description></item><item><title>Dialect 'spv' definition</title><link>https://mlir.llvm.org/docs/Dialects/SPIRVOps/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/SPIRVOps/</guid><description>The SPIR-V dialect in MLIR.
SPIR-V is a binary intermediate language for representing graphical-shader stages and compute kernels for multiple Khronos APIs, including OpenCL, OpenGL, and Vulkan. See https://www.khronos.org/registry/spir-v for more details regarding SPIR-V itself.
The SPIR-V dialect aims to be a proper compiler intermediate representation to facilitate transformations. Ops in this dialect stay at the same semantic level as the SPIR-V specification and try to have one-to-one mapping to the corresponding SPIR-V instructions; but they may deviate representationally to utilize MLIR mechanisms if it results in better representation and thus benefits transformations.</description></item><item><title>Dialect 'vector' definition</title><link>https://mlir.llvm.org/docs/Dialects/VectorOps/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/VectorOps/</guid><description>Operation definition vector.broadcast (vector::BroadcastOp) vector.constant_mask (vector::ConstantMaskOp) vector.contract (vector::ContractionOp) vector.create_mask (vector::CreateMaskOp) vector.extractelement (vector::ExtractElementOp) vector.extract (vector::ExtractOp) vector.extract_slices (vector::ExtractSlicesOp) vector.fma (vector::FMAOp) vector.insertelement (vector::InsertElementOp) vector.insert (vector::InsertOp) vector.insert_slices (vector::InsertSlicesOp) vector.insert_strided_slice (vector::InsertStridedSliceOp) vector.matrix_multiply (vector::MatmulOp) vector.outerproduct (vector::OuterProductOp) vector.print (vector::PrintOp) vector.reduction (vector::ReductionOp) vector.reshape (vector::ReshapeOp) vector.shape_cast (vector::ShapeCastOp) vector.shuffle (vector::ShuffleOp) vector.strided_slice (vector::StridedSliceOp) vector.transfer_read (vector::TransferReadOp) vector.transfer_write (vector::TransferWriteOp) vector.tuple_get (vector::TupleGetOp) vector.tuple (vector::TupleOp) vector.type_cast (vector::TypeCastOp) Operation definition vector.broadcast (vector::BroadcastOp) broadcast operation
Description: Broadcasts the scalar or k-D vector value in the source operand to a n-D result vector such that the broadcast makes sense, i.</description></item><item><title>GPU Dialect</title><link>https://mlir.llvm.org/docs/Dialects/GPU/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/GPU/</guid><description>Note: this dialect is more likely to change than others in the near future; use with caution.
This dialect provides middle-level abstractions for launching GPU kernels following a programming model similar to that of CUDA or OpenCL. It provides abstractions for kernel invocations (and may eventually provide those for device management) that are not present at the lower level (e.g., as LLVM IR intrinsics for GPUs). Its goal is to abstract away device- and driver-specific manipulations to launch a GPU kernel and provide a simple path towards GPU execution from MLIR.</description></item><item><title>Linalg Dialect</title><link>https://mlir.llvm.org/docs/Dialects/Linalg/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/Linalg/</guid><description>Rationale Set of Key Transformations High-Level Description of Linalg Ops Payload-Carrying Ops Data Representation: Views Metadata Ops Named Payload-Carrying Ops Open Issues and Design Alternatives Rationale Linalg is designed to solve the High-level Hierarchical Optimization (HHO box) in MLIR and to interoperate nicely within a Mixture Of Expert Compilers environment (i.e. the CGSel box).
The Rationale Document goes into significantly more design and architectural decision details.</description></item><item><title>LLVM IR Dialect</title><link>https://mlir.llvm.org/docs/Dialects/LLVM/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/LLVM/</guid><description>This dialect wraps the LLVM IR types and instructions into MLIR types and operations. It provides several additional operations that are necessary to cover for the differences in the IR structure (e.g., MLIR does not have phi operations and LLVM IR does not have a constant operation).
In this document, we use &amp;ldquo;LLVM IR&amp;rdquo; to designate the intermediate representation of LLVM and &amp;ldquo;LLVM IR dialect&amp;rdquo; to refer to the MLIR dialect reflecting LLVM instructions and types.</description></item><item><title>SPIR-V Dialect</title><link>https://mlir.llvm.org/docs/Dialects/SPIR-V/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/SPIR-V/</guid><description>This document describes the design of the SPIR-V dialect in MLIR. It lists various design choices we made for modeling different SPIR-V mechanisms, and their rationale.
This document also explains in a high-level manner how different components are organized and implemented in the code and gives steps to follow for extending them.
This document assumes familiarity with SPIR-V. SPIR-V is the Khronos Group’s binary intermediate language for representing graphics shaders and compute kernels.</description></item><item><title>Standard Dialect</title><link>https://mlir.llvm.org/docs/Dialects/Standard/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/Standard/</guid><description>This dialect provides documentation for operations within the Standard dialect.
Note: This dialect is a collection of operations for several different concepts, and should be split into multiple more-focused dialects accordingly.
Terminator operations &amp;lsquo;br&amp;rsquo; terminator operation &amp;lsquo;cond_br&amp;rsquo; terminator operation &amp;lsquo;return&amp;rsquo; terminator operation Core Operations &amp;lsquo;call&amp;rsquo; operation &amp;lsquo;call_indirect&amp;rsquo; operation &amp;lsquo;dim&amp;rsquo; operation Memory Operations &amp;lsquo;alloc&amp;rsquo; operation &amp;lsquo;alloc_static&amp;rsquo; operation &amp;lsquo;dealloc&amp;rsquo; operation &amp;lsquo;dma_start&amp;rsquo; operation &amp;lsquo;dma_wait&amp;rsquo; operation &amp;lsquo;extract_element&amp;rsquo; operation &amp;lsquo;load&amp;rsquo; operation &amp;lsquo;splat&amp;rsquo; operation &amp;lsquo;store&amp;rsquo; operation &amp;lsquo;tensor_load&amp;rsquo; operation &amp;lsquo;tensor_store&amp;rsquo; operation Unary Operations &amp;lsquo;absf&amp;rsquo; operation &amp;lsquo;ceilf&amp;rsquo; operation &amp;lsquo;cos&amp;rsquo; operation &amp;lsquo;exp&amp;rsquo; operation &amp;lsquo;negf&amp;rsquo; operation &amp;lsquo;sqrt&amp;rsquo; operation &amp;lsquo;tanh&amp;rsquo; operation Arithmetic Operations &amp;lsquo;addi&amp;rsquo; operation &amp;lsquo;addf&amp;rsquo; operation &amp;lsquo;and&amp;rsquo; operation &amp;lsquo;cmpi&amp;rsquo; operation &amp;lsquo;constant&amp;rsquo; operation &amp;lsquo;copysign&amp;rsquo; operation &amp;lsquo;divis&amp;rsquo; operation &amp;lsquo;diviu&amp;rsquo; operation &amp;lsquo;memref_cast&amp;rsquo; operation &amp;lsquo;mulf&amp;rsquo; operation &amp;lsquo;or&amp;rsquo; operation &amp;lsquo;remis&amp;rsquo; operation &amp;lsquo;remiu&amp;rsquo; operation &amp;lsquo;select&amp;rsquo; operation &amp;lsquo;tensor_cast&amp;rsquo; operation &amp;lsquo;xor&amp;rsquo; operation TODO: shape, which returns a 1D tensor, and can take an unknown rank tensor as input.</description></item><item><title>Vector Dialect</title><link>https://mlir.llvm.org/docs/Dialects/Vector/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/Vector/</guid><description>MLIR supports multi-dimensional vector types and custom operations on those types. A generic, retargetable, higher-order vector type (n-D with n &amp;gt; 1) is a structured type, that carries semantic information useful for transformations. This document discusses retargetable abstractions that exist in MLIR today and operate on ssa-values of type vector along with pattern rewrites and lowerings that enable targeting specific instructions on concrete targets. These abstractions serve to separate concerns between operations on memref (a.</description></item></channel></rss>