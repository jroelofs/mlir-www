<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Standard Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.64.1"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/Standard/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/master/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/master/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li></ul></nav></div><div class=content-container><main><h1>Standard Dialect</h1><p>This dialect provides documentation for operations within the Standard dialect.</p><p>Note: This dialect is a collection of operations for several different concepts,
and should be split into multiple more-focused dialects accordingly.</p><p><nav id=TableOfContents><ul><li><a href=#terminator-operations>Terminator operations</a><ul><li><a href=#br-terminator-operation>&lsquo;br&rsquo; terminator operation</a></li><li><a href=#cond_br-terminator-operation>&lsquo;cond_br&rsquo; terminator operation</a></li><li><a href=#return-terminator-operation>&lsquo;return&rsquo; terminator operation</a></li></ul></li><li><a href=#core-operations>Core Operations</a><ul><li><a href=#call-operation>&lsquo;call&rsquo; operation</a></li><li><a href=#call_indirect-operation>&lsquo;call_indirect&rsquo; operation</a></li><li><a href=#dim-operation>&lsquo;dim&rsquo; operation</a></li></ul></li><li><a href=#memory-operations>Memory Operations</a><ul><li><a href=#alloc-operation>&lsquo;alloc&rsquo; operation</a></li><li><a href=#alloc_static-operation>&lsquo;alloc_static&rsquo; operation</a></li><li><a href=#dealloc-operation>&lsquo;dealloc&rsquo; operation</a></li><li><a href=#dma_start-operation>&lsquo;dma_start&rsquo; operation</a></li><li><a href=#dma_wait-operation>&lsquo;dma_wait&rsquo; operation</a></li><li><a href=#extract_element-operation>&lsquo;extract_element&rsquo; operation</a></li><li><a href=#load-operation>&lsquo;load&rsquo; operation</a></li><li><a href=#splat-operation>&lsquo;splat&rsquo; operation</a></li><li><a href=#store-operation>&lsquo;store&rsquo; operation</a></li><li><a href=#tensor_load-operation>&lsquo;tensor_load&rsquo; operation</a></li><li><a href=#tensor_store-operation>&lsquo;tensor_store&rsquo; operation</a></li></ul></li><li><a href=#unary-operations>Unary Operations</a><ul><li><a href=#absf-operation>&lsquo;absf&rsquo; operation</a></li><li><a href=#ceilf-operation>&lsquo;ceilf&rsquo; operation</a></li><li><a href=#cos-operation>&lsquo;cos&rsquo; operation</a></li><li><a href=#exp-operation>&lsquo;exp&rsquo; operation</a></li><li><a href=#negf-operation>&lsquo;negf&rsquo; operation</a></li><li><a href=#sqrt-operation>&lsquo;sqrt&rsquo; operation</a></li><li><a href=#tanh-operation>&lsquo;tanh&rsquo; operation</a></li></ul></li><li><a href=#arithmetic-operations>Arithmetic Operations</a><ul><li><a href=#addi-operation>&lsquo;addi&rsquo; operation</a></li><li><a href=#addf-operation>&lsquo;addf&rsquo; operation</a></li><li><a href=#and-operation>&lsquo;and&rsquo; operation</a></li><li><a href=#cmpi-operation>&lsquo;cmpi&rsquo; operation</a></li><li><a href=#constant-operation>&lsquo;constant&rsquo; operation</a></li><li><a href=#copysign-operation>&lsquo;copysign&rsquo; operation</a></li><li><a href=#divis-operation>&lsquo;divis&rsquo; operation</a></li><li><a href=#diviu-operation>&lsquo;diviu&rsquo; operation</a></li><li><a href=#memref_cast-operation>&lsquo;memref_cast&rsquo; operation</a></li><li><a href=#mulf-operation>&lsquo;mulf&rsquo; operation</a></li><li><a href=#or-operation>&lsquo;or&rsquo; operation</a></li><li><a href=#remis-operation>&lsquo;remis&rsquo; operation</a></li><li><a href=#remiu-operation>&lsquo;remiu&rsquo; operation</a></li><li><a href=#select-operation>&lsquo;select&rsquo; operation</a></li><li><a href=#tensor_cast-operation>&lsquo;tensor_cast&rsquo; operation</a></li><li><a href=#xor-operation>&lsquo;xor&rsquo; operation</a></li></ul></li></ul></nav><p>TODO: shape, which returns a 1D tensor, and can take an unknown rank tensor as
input.</p><p>TODO: rank, which returns an index.</p><h2 id=terminator-operations>Terminator operations</h2><p>Terminator operations are required at the end of each block. They may contain a
list of successors, i.e. other blocks to which the control flow will proceed.</p><h3 id=br-terminator-operation>&lsquo;br&rsquo; terminator operation</h3><p>Syntax:</p><pre><code>operation ::= `br` successor
successor ::= bb-id branch-use-list?
branch-use-list ::= `(` ssa-use-list `:` type-list-no-parens `)`
</code></pre><p>The <code>br</code> terminator operation represents an unconditional jump to a target
block. The count and types of operands to the branch must align with the
arguments in the target block.</p><p>The MLIR branch operation is not allowed to target the entry block for a region.</p><h3 id=cond_br-terminator-operation>&lsquo;cond_br&rsquo; terminator operation</h3><p>Syntax:</p><pre><code>operation ::= `cond_br` ssa-use `,` successor `,` successor
</code></pre><p>The <code>cond_br</code> terminator operation represents a conditional branch on a boolean
(1-bit integer) value. If the bit is set, then the first destination is jumped
to; if it is false, the second destination is chosen. The count and types of
operands must align with the arguments in the corresponding target blocks.</p><p>The MLIR conditional branch operation is not allowed to target the entry block
for a region. The two destinations of the conditional branch operation are
allowed to be the same.</p><p>The following example illustrates a function with a conditional branch operation
that targets the same block:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@select</span><span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i1</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span> <span class=p>{</span>
<span class=nl>^bb0</span><span class=p>(</span><span class=nv>%a</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nv>%b</span> <span class=p>:</span><span class=k>i32</span><span class=p>,</span> <span class=nv>%flag</span> <span class=p>:</span> <span class=k>i1</span><span class=p>)</span> <span class=p>:</span>
    <span class=c>// Both targets are the same, operands differ
</span><span class=c></span>    cond_br <span class=nv>%flag</span><span class=p>,</span> <span class=nl>^bb1</span><span class=p>(</span><span class=nv>%a</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span><span class=p>,</span> <span class=nl>^bb1</span><span class=p>(</span><span class=nv>%b</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span>

<span class=nl>^bb1</span><span class=p>(</span><span class=nv>%x</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>:</span>
    <span class=kt>return</span> <span class=nv>%x</span> <span class=p>:</span> <span class=k>i32</span>
<span class=p>}</span>
</code></pre></div><h3 id=return-terminator-operation>&lsquo;return&rsquo; terminator operation</h3><p>Syntax:</p><pre><code>operation ::= `return` (ssa-use-list `:` type-list-no-parens)?
</code></pre><p>The <code>return</code> terminator operation represents the completion of a function, and
produces the result values. The count and types of the operands must match the
result types of the enclosing function. It is legal for multiple blocks in a
single function to return.</p><h2 id=core-operations>Core Operations</h2><h3 id=call-operation>&lsquo;call&rsquo; operation</h3><p>Syntax:</p><pre><code>operation ::=
    (ssa-id `=`)? `call` symbol-ref-id `(` ssa-use-list? `)` `:` function-type
</code></pre><p>The <code>call</code> operation represents a direct call to a function. The operands and
result types of the call must match the specified function type. The callee is
encoded as a function attribute named &ldquo;callee&rdquo;.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Calling the function my_add.
</span><span class=c></span><span class=nv>%31</span> <span class=p>=</span> call <span class=nf>@my_add</span><span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>16x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>16x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>16x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><h3 id=call_indirect-operation>&lsquo;call_indirect&rsquo; operation</h3><p>Syntax:</p><pre><code>operation ::= `call_indirect` ssa-use `(` ssa-use-list? `)` `:` function-type
</code></pre><p>The <code>call_indirect</code> operation represents an indirect call to a value of function
type. Functions are first class types in MLIR, and may be passed as arguments
and merged together with block arguments. The operands and result types of the
call must match the specified function type.</p><p>Function values can be created with the
<a href=#constant-operation><code>constant</code> operation</a>
.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%31</span> <span class=p>=</span> call_indirect <span class=nv>%15</span><span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>)</span>
        <span class=p>:</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>16x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>16x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>16x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><h3 id=dim-operation>&lsquo;dim&rsquo; operation</h3><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `dim` ssa-id `,` integer-literal `:` type
</code></pre><p>The <code>dim</code> operation takes a memref or tensor operand and a dimension index, and
returns an
<a href=/docs/LangRef/#index-type><code>index</code></a>
that is the size of that
dimension.</p><p>The <code>dim</code> operation is represented with a single integer attribute named
<code>index</code>, and the type specifies the type of the memref or tensor operand.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Always returns 4, can be constant folded:
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> dim <span class=nv>%A</span><span class=p>,</span> <span class=m>0</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4 x</span> <span class=m>? x</span> <span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Returns the dynamic dimension of %A.
</span><span class=c></span><span class=nv>%y</span> <span class=p>=</span> dim <span class=nv>%A</span><span class=p>,</span> <span class=m>1</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4 x</span> <span class=m>? x</span> <span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Equivalent generic form:
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> <span class=s>&#34;std.dim&#34;</span><span class=p>(</span><span class=nv>%A</span><span class=p>)</span> <span class=p>{</span><span class=nl>index =</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i64</span><span class=p>}</span> <span class=p>:</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4 x</span> <span class=m>? x</span> <span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>index</span>
<span class=nv>%y</span> <span class=p>=</span> <span class=s>&#34;std.dim&#34;</span><span class=p>(</span><span class=nv>%A</span><span class=p>)</span> <span class=p>{</span><span class=nl>index =</span> <span class=m>1</span> <span class=p>:</span> <span class=k>i64</span><span class=p>}</span> <span class=p>:</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4 x</span> <span class=m>? x</span> <span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>index</span>
</code></pre></div><h2 id=memory-operations>Memory Operations</h2><h3 id=alloc-operation>&lsquo;alloc&rsquo; operation</h3><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `alloc` dim-and-symbol-use-list `:` memref-type
</code></pre><p>Allocates a new memref of specified type. Values required for dynamic dimension
sizes are passed as arguments in parentheses (in the same order in which they
appear in the shape signature of the memref) while the symbols required by the
layout map are passed in the square brackets in lexicographical order. If no
layout maps are specified in the memref, then an identity mapping is used.</p><p>The buffer referenced by a memref type is created by the <code>alloc</code> operation, and
destroyed by the <code>dealloc</code> operation.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Allocating memref for a fully static shape.
</span><span class=c></span><span class=nv>%A</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1024x64x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#layout_map0</span><span class=p>,</span> memspace0<span class=p>&gt;</span>

<span class=c>// %M, %N, %x, %y are SSA values of integer type.  M and N are bound to the
</span><span class=c></span><span class=c>// two unknown dimensions of the type and x/y are bound to symbols in
</span><span class=c></span><span class=c>// #layout_map1.
</span><span class=c></span><span class=nv>%B</span> <span class=p>=</span> alloc<span class=p>(</span><span class=nv>%M</span><span class=p>,</span> <span class=nv>%N</span><span class=p>)</span><span class=p>[</span><span class=nv>%x</span><span class=p>,</span> <span class=nv>%y</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#layout_map1</span><span class=p>,</span> memspace1<span class=p>&gt;</span>
</code></pre></div><h3 id=alloc_static-operation>&lsquo;alloc_static&rsquo; operation</h3><p>Syntax:</p><pre><code>operation ::=
    ssa-id `=` `alloc_static` `(` integer-literal `)` :  memref-type
</code></pre><p>Allocates a new memref of specified type with a fixed base pointer location in
memory. &lsquo;alloc_static&rsquo; does not support types that have dynamic shapes or that
require dynamic symbols in their layout function (use the
<a href=#alloc-operation><code>alloc</code> operation</a>
in those cases).</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%A</span> <span class=p>=</span> alloc_static<span class=p>(</span><span class=m>0x1232a00</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1024 x</span> <span class=m>64 x</span> <span class=k>f32</span><span class=p>,</span> <span class=nv>#layout_map0</span><span class=p>,</span> memspace0<span class=p>&gt;</span>
</code></pre></div><p>The <code>alloc_static</code> operation is used to represent code after buffer allocation
has been performed.</p><h3 id=dealloc-operation>&lsquo;dealloc&rsquo; operation</h3><p>Syntax:</p><pre><code>operation ::= `dealloc` ssa-use `:` memref-type
</code></pre><p>Delineates the end of the lifetime of the memory corresponding to a memref
allocation. It is paired with an
<a href=#alloc-operation><code>alloc</code></a>
or
<a href=#alloc-static-operation><code>alloc_static</code></a>
operation.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>dealloc <span class=nv>%A</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>128 x</span> <span class=k>f32</span><span class=p>,</span> <span class=nv>#layout</span><span class=p>,</span> memspace0<span class=p>&gt;</span>
</code></pre></div><h3 id=dma_start-operation>&lsquo;dma_start&rsquo; operation</h3><p>Syntax:</p><pre><code>operation ::= `dma_start` ssa-use`[`ssa-use-list`]` `,`
               ssa-use`[`ssa-use-list`]` `,` ssa-use `,`
               ssa-use`[`ssa-use-list`]` (`,` ssa-use `,` ssa-use)?
              `:` memref-type `,` memref-type `,` memref-type
</code></pre><p>Starts a non-blocking DMA operation that transfers data from a source memref to
a destination memref. The operands include the source and destination memref&rsquo;s
each followed by its indices, size of the data transfer in terms of the number
of elements (of the elemental type of the memref), a tag memref with its
indices, and optionally two additional arguments corresponding to the stride (in
terms of number of elements) and the number of elements to transfer per stride.
The tag location is used by a dma_wait operation to check for completion. The
indices of the source memref, destination memref, and the tag memref have the
same restrictions as any load/store operation in a affine context (whenever DMA
operations appear in an affine context). See
<a href=/docs/Dialects/Affine/#restrictions-on-dimensions-and-symbols>restrictions on dimensions and symbols</a>
in affine contexts. This allows powerful static analysis and transformations in
the presence of such DMAs including rescheduling, pipelining / overlap with
computation, and checking for matching start/end operations. The source and
destination memref need not be of the same dimensionality, but need to have the
same elemental type.</p><p>For example, a <code>dma_start</code> operation that transfers 32 vector elements from a
memref <code>%src</code> at location <code>[%i, %j]</code> to memref <code>%dst</code> at <code>[%k, %l]</code> would be
specified as shown below.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%size</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>32</span> <span class=p>:</span> <span class=k>index</span>
<span class=nv>%tag</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1 x</span> <span class=k>i32</span><span class=p>,</span> affine_map<span class=p>&lt;</span><span class=p>(</span>d0<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>)</span><span class=p>&gt;</span><span class=p>,</span> <span class=m>4</span><span class=p>&gt;</span>
<span class=nv>%idx</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>index</span>
dma_start <span class=nv>%src</span><span class=p>[</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>]</span><span class=p>,</span> <span class=nv>%dst</span><span class=p>[</span><span class=nv>%k</span><span class=p>,</span> <span class=nv>%l</span><span class=p>]</span><span class=p>,</span> <span class=nv>%size</span><span class=p>,</span> <span class=nv>%tag</span><span class=p>[</span><span class=nv>%idx</span><span class=p>]</span> <span class=p>:</span>
     <span class=kt>memref</span><span class=p>&lt;</span><span class=m>40 x</span> <span class=m>8 x</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>16x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> affine_map<span class=p>&lt;</span><span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span><span class=p>&gt;</span><span class=p>,</span> <span class=m>0</span><span class=p>&gt;</span><span class=p>,</span>
     <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2 x</span> <span class=m>4 x</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>16x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> affine_map<span class=p>&lt;</span><span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span><span class=p>&gt;</span><span class=p>,</span> <span class=m>2</span><span class=p>&gt;</span><span class=p>,</span>
     <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1 x</span> <span class=k>i32</span><span class=p>&gt;</span><span class=p>,</span> affine_map<span class=p>&lt;</span><span class=p>(</span>d0<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>)</span><span class=p>&gt;</span><span class=p>,</span> <span class=m>4</span><span class=p>&gt;</span>
</code></pre></div><h3 id=dma_wait-operation>&lsquo;dma_wait&rsquo; operation</h3><p>Syntax:</p><pre><code>operation ::= `dma_wait` ssa-use`[`ssa-use-list`]` `,` ssa-use `:` memref-type
</code></pre><p>Blocks until the completion of a DMA operation associated with the tag element
specified with a tag memref and its indices. The operands include the tag memref
followed by its indices and the number of elements associated with the DMA being
waited on. The indices of the tag memref have the same restrictions as
load/store indices.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>dma_wait <span class=nv>%tag</span><span class=p>[</span><span class=nv>%idx</span><span class=p>]</span><span class=p>,</span> <span class=nv>%size</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1 x</span> <span class=k>i32</span><span class=p>,</span> affine_map<span class=p>&lt;</span><span class=p>(</span>d0<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>)</span><span class=p>&gt;</span><span class=p>,</span> <span class=m>4</span><span class=p>&gt;</span>
</code></pre></div><h3 id=extract_element-operation>&lsquo;extract_element&rsquo; operation</h3><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `extract_element` ssa-use `[` ssa-use-list `]` `:` type
</code></pre><p>The <code>extract_element</code> op reads a tensor or vector and returns one element from
it specified by an index list. The output of the &lsquo;extract_element&rsquo; is a new
value with the same type as the elements of the tensor or vector. The arity of
indices matches the rank of the accessed value (i.e., if a tensor is of rank 3,
then 3 indices are required for the extract. The indices should all be of
<code>index</code> type.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%3</span> <span class=p>=</span> extract_element <span class=nv>%v</span><span class=p>[</span><span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span><span class=p>]</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x4x</span><span class=k>i32</span><span class=p>&gt;</span>
<span class=nv>%4</span> <span class=p>=</span> extract_element <span class=nv>%t</span><span class=p>[</span><span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span><span class=p>]</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x4x</span><span class=k>i32</span><span class=p>&gt;</span>
<span class=nv>%5</span> <span class=p>=</span> extract_element <span class=nv>%ut</span><span class=p>[</span><span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span><span class=p>]</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=p>*</span>xi32<span class=p>&gt;</span>
</code></pre></div><h3 id=load-operation>&lsquo;load&rsquo; operation</h3><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `load` ssa-use `[` ssa-use-list `]` `:` memref-type
</code></pre><p>The <code>load</code> op reads an element from a memref specified by an index list. The
output of load is a new value with the same type as the elements of the memref.
The arity of indices is the rank of the memref (i.e., if the memref loaded from
is of rank 3, then 3 indices are required for the load following the memref
identifier).</p><p>In an <code>affine.if</code> or <code>affine.for</code> body, the indices of a load are restricted to
SSA values bound to surrounding loop induction variables,
<a href=/docs/LangRef/#dimensions-and-symbols>symbols</a>
, results of a
<a href=#constant-operation><code>constant</code> operation</a>
, or the result of an <code>affine.apply</code>
operation that can in turn take as arguments all of the aforementioned SSA
values or the recursively result of such an <code>affine.apply</code> operation.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%1</span> <span class=p>=</span> affine<span class=p>.</span>apply affine_map<span class=p>&lt;</span><span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=m>3</span><span class=p>*</span>d0<span class=p>)</span><span class=p>&gt;</span> <span class=p>(</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>)</span>
<span class=nv>%2</span> <span class=p>=</span> affine<span class=p>.</span>apply affine_map<span class=p>&lt;</span><span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d1<span class=err>+</span><span class=m>1</span><span class=p>)</span><span class=p>&gt;</span> <span class=p>(</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>)</span>
<span class=nv>%12</span> <span class=p>=</span> load <span class=nv>%A</span><span class=p>[</span><span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x?x</span><span class=k>i32</span><span class=p>,</span> <span class=nv>#layout</span><span class=p>,</span> memspace0<span class=p>&gt;</span>

<span class=c>// Example of an indirect load (treated as non-affine)
</span><span class=c></span><span class=nv>%3</span> <span class=p>=</span> affine<span class=p>.</span>apply affine_map<span class=p>&lt;</span><span class=p>(</span>d0<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=m>2</span><span class=p>*</span>d0 <span class=err>+</span> <span class=m>1</span><span class=p>)</span><span class=p>&gt;</span><span class=p>(</span><span class=nv>%12</span><span class=p>)</span>
<span class=nv>%13</span> <span class=p>=</span> load <span class=nv>%A</span><span class=p>[</span><span class=nv>%3</span><span class=p>,</span> <span class=nv>%2</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i32</span><span class=p>,</span> <span class=nv>#layout</span><span class=p>,</span> memspace0<span class=p>&gt;</span>
</code></pre></div><p><strong>Context:</strong> The <code>load</code> and <code>store</code> operations are specifically crafted to fully
resolve a reference to an element of a memref, and (in affine <code>affine.if</code> and
<code>affine.for</code> operations) the compiler can follow use-def chains (e.g. through
<a href=/docs/Dialects/Affine/#affineapply-operation><code>affine.apply</code></a>
operations) to precisely
analyze references at compile-time using polyhedral techniques. This is possible
because of the
<a href=/docs/Dialects/Affine/#restrictions-on-dimensions-and-symbols>restrictions on dimensions and symbols</a>
in these contexts.</p><h3 id=splat-operation>&lsquo;splat&rsquo; operation</h3><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `splat` ssa-use `:` ( vector-type | tensor-type )
</code></pre><p>Broadcast the operand to all elements of the result vector or tensor. The
operand has to be of either integer or float type. When the result is a tensor,
it has to be statically shaped.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>  <span class=nv>%s</span> <span class=p>=</span> load <span class=nv>%A</span><span class=p>[</span><span class=nv>%i</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>128x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=nv>%v</span> <span class=p>=</span> splat <span class=nv>%s</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=nv>%t</span> <span class=p>=</span> splat <span class=nv>%s</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>8x16x</span><span class=k>i32</span><span class=p>&gt;</span>
</code></pre></div><p>TODO: This operation is easy to extend to broadcast to dynamically shaped
tensors in the same way dynamically shaped memrefs are handled.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Broadcasts %s to a 2-d dynamically shaped tensor, with %m, %n binding
</span><span class=c></span><span class=c>// to the sizes of the two dynamic dimensions.
</span><span class=c></span><span class=nv>%m</span> <span class=p>=</span> <span class=s>&#34;foo&#34;</span><span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>index</span><span class=p>)</span>
<span class=nv>%n</span> <span class=p>=</span> <span class=s>&#34;bar&#34;</span><span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>index</span><span class=p>)</span>
<span class=nv>%t</span> <span class=p>=</span> splat <span class=nv>%s</span> <span class=p>[</span><span class=nv>%m</span><span class=p>,</span> <span class=nv>%n</span><span class=p>]</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>i32</span><span class=p>&gt;</span>
</code></pre></div><h3 id=store-operation>&lsquo;store&rsquo; operation</h3><p>Syntax:</p><pre><code>operation ::= `store` ssa-use `,` ssa-use `[` ssa-use-list `]` `:` memref-type
</code></pre><p>Store value to memref location given by indices. The value stored should have
the same type as the elemental type of the memref. The number of arguments
provided within brackets need to match the rank of the memref.</p><p>In an affine context, the indices of a store are restricted to SSA values bound
to surrounding loop induction variables,
<a href=/docs/Dialects/Affine/#restrictions-on-dimensions-and-symbols>symbols</a>
, results of a
<a href=#constant-operation><code>constant</code> operation</a>
, or the result of an
<a href=/docs/Dialects/Affine/#affineapply-operation><code>affine.apply</code></a>
operation that can in turn
take as arguments all of the aforementioned SSA values or the recursively result
of such an <code>affine.apply</code> operation.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>store <span class=nv>%100</span><span class=p>,</span> <span class=nv>%A</span><span class=p>[</span><span class=nv>%1</span><span class=p>,</span> <span class=m>1023</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#layout</span><span class=p>,</span> memspace0<span class=p>&gt;</span>
</code></pre></div><p><strong>Context:</strong> The <code>load</code> and <code>store</code> operations are specifically crafted to fully
resolve a reference to an element of a memref, and (in polyhedral <code>affine.if</code>
and <code>affine.for</code> operations) the compiler can follow use-def chains (e.g.
through
<a href=/docs/Dialects/Affine/#affineapply-operation><code>affine.apply</code></a>
operations) to
precisely analyze references at compile-time using polyhedral techniques. This
is possible because of the
<a href=/docs/Dialects/Affine/#restrictions-on-dimensions-and-symbols>restrictions on dimensions and symbols</a>
in these contexts.</p><h3 id=tensor_load-operation>&lsquo;tensor_load&rsquo; operation</h3><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `tensor_load` ssa-use-and-type
</code></pre><p>Create a tensor from a memref, making an independent copy of the element data.
The result value is a tensor whose shape and element type match the memref
operand.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Produces a value of tensor&lt;4x?xf32&gt; type.
</span><span class=c></span><span class=nv>%12</span> <span class=p>=</span> <span class=kt>tensor</span>_load <span class=nv>%10</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#layout</span><span class=p>,</span> memspace0<span class=p>&gt;</span>
</code></pre></div><h3 id=tensor_store-operation>&lsquo;tensor_store&rsquo; operation</h3><p>Syntax:</p><pre><code>operation ::= `tensor_store` ssa-use `,` ssa-use `:` memref-type
</code></pre><p>Stores the contents of a tensor into a memref. The first operand is a value of
tensor type, the second operand is a value of memref type. The shapes and
element types of these must match, and are specified by the memref type.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%9</span> <span class=p>=</span> dim <span class=nv>%8</span><span class=p>,</span> <span class=m>1</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=nv>%10</span> <span class=p>=</span> alloc<span class=p>(</span><span class=nv>%9</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#layout</span><span class=p>,</span> memspace0<span class=p>&gt;</span>
<span class=kt>tensor</span>_store <span class=nv>%8</span><span class=p>,</span> <span class=nv>%10</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#layout</span><span class=p>,</span> memspace0<span class=p>&gt;</span>
</code></pre></div><h2 id=unary-operations>Unary Operations</h2><h3 id=absf-operation>&lsquo;absf&rsquo; operation</h3><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `absf` ssa-use `:` type
</code></pre><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar absolute value.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> absf <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>

<span class=c>// SIMD vector element-wise absolute value.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> absf <span class=nv>%g</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise absolute value.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> absf <span class=nv>%y</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span>f8<span class=p>&gt;</span>
</code></pre></div><p>The <code>absf</code> operation computes the absolute value. It takes one operand and
returns one result of the same type. This type may be a float scalar type, a
vector whose element type is float, or a tensor of floats. It has no standard
attributes.</p><h3 id=ceilf-operation>&lsquo;ceilf&rsquo; operation</h3><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `ceilf` ssa-use `:` type
</code></pre><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar ceiling value.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> ceilf <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>

<span class=c>// SIMD vector element-wise ceiling value.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> ceilf <span class=nv>%g</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise ceiling value.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> ceilf <span class=nv>%y</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span>f8<span class=p>&gt;</span>
</code></pre></div><p>The <code>ceilf</code> operation computes the ceiling of a given value. It takes one
operand and returns one result of the same type. This type may be a float
scalar type, a vector whose element type is float, or a tensor of floats. It
has no standard attributes.</p><h3 id=cos-operation>&lsquo;cos&rsquo; operation</h3><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `cos` ssa-use `:` type
</code></pre><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar cosine value.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> cos <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>

<span class=c>// SIMD vector element-wise cosine value.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> cos <span class=nv>%g</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise cosine value.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> cos <span class=nv>%y</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span>f8<span class=p>&gt;</span>
</code></pre></div><p>The <code>cos</code> operation computes the cosine of a given value. It takes one operand
and returns one result of the same type. This type may be a float scalar type,
a vector whose element type is float, or a tensor of floats. It has no standard
attributes.</p><h3 id=exp-operation>&lsquo;exp&rsquo; operation</h3><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `exp` ssa-use `:` type
</code></pre><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar natural exponential.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> exp <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>

<span class=c>// SIMD vector element-wise natural exponential.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> exp <span class=nv>%g</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise natural exponential.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> exp <span class=nv>%y</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span>f8<span class=p>&gt;</span>
</code></pre></div><p>The <code>exp</code> operation takes one operand and returns one result of the same type.
This type may be a float scalar type, a vector whose element type is float, or a
tensor of floats. It has no standard attributes.</p><h3 id=negf-operation>&lsquo;negf&rsquo; operation</h3><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `negf` ssa-use `:` type
</code></pre><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar negation value.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> negf <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>

<span class=c>// SIMD vector element-wise negation value.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> negf <span class=nv>%g</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise negation value.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> negf <span class=nv>%y</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span>f8<span class=p>&gt;</span>
</code></pre></div><p>The <code>negf</code> operation computes the negation of a given value. It takes one
operand and returns one result of the same type. This type may be a float
scalar type, a vector whose element type is float, or a tensor of floats. It
has no standard attributes.</p><h3 id=sqrt-operation>&lsquo;sqrt&rsquo; operation</h3><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `sqrt` ssa-use `:` type
</code></pre><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar square root value.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> sqrt <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>
<span class=c>// SIMD vector element-wise square root value.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> sqrt <span class=nv>%g</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=c>// Tensor element-wise square root value.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> sqrt <span class=nv>%y</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><h3 id=tanh-operation>&lsquo;tanh&rsquo; operation</h3><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `tanh` ssa-use `:` type
</code></pre><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar hyperbolic tangent value.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> tanh <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>

<span class=c>// SIMD vector element-wise hyperbolic tangent value.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> tanh <span class=nv>%g</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise hyperbolic tangent value.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> tanh <span class=nv>%y</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span>f8<span class=p>&gt;</span>
</code></pre></div><p>The <code>tanh</code> operation computes the hyperbolic tangent. It takes one operand and
returns one result of the same type. This type may be a float scalar type, a
vector whose element type is float, or a tensor of floats. It has no standard
attributes.</p><h2 id=arithmetic-operations>Arithmetic Operations</h2><p>Basic arithmetic in MLIR is specified by standard operations described in this
section.</p><h3 id=addi-operation>&lsquo;addi&rsquo; operation</h3><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `addi` ssa-use `,` ssa-use `:` type
</code></pre><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar addition.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> addi <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>

<span class=c>// SIMD vector element-wise addition, e.g. for Intel SSE.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> addi <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise addition.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> addi <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</code></pre></div><p>The <code>addi</code> operation takes two operands and returns one result, each of these is
required to be the same type. This type may be an integer scalar type, a vector
whose element type is integer, or a tensor of integers. It has no standard
attributes.</p><h3 id=addf-operation>&lsquo;addf&rsquo; operation</h3><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `addf` ssa-use `,` ssa-use `:` type
</code></pre><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar addition.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> addf <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>f64</span>

<span class=c>// SIMD vector addition, e.g. for Intel SSE.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> addf <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Tensor addition.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> addf <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>bf16</span><span class=p>&gt;</span>
</code></pre></div><p>The <code>addf</code> operation takes two operands and returns one result, each of these is
required to be the same type. This type may be a floating point scalar type, a
vector whose element type is a floating point type, or a floating point tensor.</p><p>It has no standard attributes.</p><p>TODO: In the distant future, this will accept optional attributes for fast math,
contraction, rounding mode, and other controls.</p><h3 id=and-operation>&lsquo;and&rsquo; operation</h3><p>Bitwise integer and.</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `and` ssa-use `,` ssa-use `:` type
</code></pre><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar integer bitwise and.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> and <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>

<span class=c>// SIMD vector element-wise bitwise integer and.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> and <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise bitwise integer and.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> and <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</code></pre></div><p>The <code>and</code> operation takes two operands and returns one result, each of these is
required to be the same type. This type may be an integer scalar type, a vector
whose element type is integer, or a tensor of integers. It has no standard
attributes.</p><h3 id=cmpi-operation>&lsquo;cmpi&rsquo; operation</h3><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `cmpi` string-literal `,` ssa-id `,` ssa-id `:` type
</code></pre><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Custom form of scalar &#34;signed less than&#34; comparison.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> cmpi <span class=s>&#34;slt&#34;</span><span class=p>,</span> <span class=nv>%lhs</span><span class=p>,</span> <span class=nv>%rhs</span> <span class=p>:</span> <span class=k>i32</span>

<span class=c>// Generic form of the same operation.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> <span class=s>&#34;std.cmpi&#34;</span><span class=p>(</span><span class=nv>%lhs</span><span class=p>,</span> <span class=nv>%rhs</span><span class=p>)</span> <span class=p>{</span><span class=nl>predicate =</span> <span class=m>2</span> <span class=p>:</span> <span class=k>i64</span><span class=p>}</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i1</span>

<span class=c>// Custom form of vector equality comparison.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> cmpi <span class=s>&#34;eq&#34;</span><span class=p>,</span> <span class=nv>%lhs</span><span class=p>,</span> <span class=nv>%rhs</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i64</span><span class=p>&gt;</span>

<span class=c>// Generic form of the same operation.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> <span class=s>&#34;std.cmpi&#34;</span><span class=p>(</span><span class=nv>%lhs</span><span class=p>,</span> <span class=nv>%rhs</span><span class=p>)</span> <span class=p>{</span><span class=nl>predicate =</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i64</span><span class=p>}</span>
    <span class=p>:</span> <span class=p>(</span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i64</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i64</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i1</span><span class=p>&gt;</span>
</code></pre></div><p>The <code>cmpi</code> operation is a generic comparison for integer-like types. Its two
arguments can be integers, vectors or tensors thereof as long as their types
match. The operation produces an i1 for the former case, a vector or a tensor of
i1 with the same shape as inputs in the other cases.</p><p>Its first argument is an attribute that defines which type of comparison is
performed. The following comparisons are supported:</p><ul><li>equal (mnemonic: <code>"eq"</code>; integer value: <code>0</code>)</li><li>not equal (mnemonic: <code>"ne"</code>; integer value: <code>1</code>)</li><li>signed less than (mnemonic: <code>"slt"</code>; integer value: <code>2</code>)</li><li>signed less than or equal (mnemonic: <code>"sle"</code>; integer value: <code>3</code>)</li><li>signed greater than (mnemonic: <code>"sgt"</code>; integer value: <code>4</code>)</li><li>signed greater than or equal (mnemonic: <code>"sge"</code>; integer value: <code>5</code>)</li><li>unsigned less than (mnemonic: <code>"ult"</code>; integer value: <code>6</code>)</li><li>unsigned less than or equal (mnemonic: <code>"ule"</code>; integer value: <code>7</code>)</li><li>unsigned greater than (mnemonic: <code>"ugt"</code>; integer value: <code>8</code>)</li><li>unsigned greater than or equal (mnemonic: <code>"uge"</code>; integer value: <code>9</code>)</li></ul><p>The result is <code>1</code> if the comparison is true and <code>0</code> otherwise. For vector or
tensor operands, the comparison is performed elementwise and the element of the
result indicates whether the comparison is true for the operand elements with
the same indices as those of the result.</p><p>Note: while the custom assembly form uses strings, the actual underlying
attribute has integer type (or rather enum class in C++ code) as seen from the
generic assembly form. String literals are used to improve readability of the IR
by humans.</p><p>This operation only applies to integer-like operands, but not floats. The main
reason being that comparison operations have diverging sets of attributes:
integers require sign specification while floats require various floating
point-related particularities, e.g., <code>-ffast-math</code> behavior, IEEE754 compliance,
etc
(
<a href=/docs/Rationale/#splitting-floating-point-vs-integer-operations>rationale</a>
).
The type of comparison is specified as attribute to avoid introducing ten
similar operations, taking into account that they are often implemented using
the same operation downstream
(
<a href=/docs/Rationale/#specifying-comparison-kind-as-attribute>rationale</a>
). The
separation between signed and unsigned order comparisons is necessary because of
integers being signless. The comparison operation must know how to interpret
values with the foremost bit being set: negatives in two&rsquo;s complement or large
positives
(
<a href=/docs/Rationale/#specifying-sign-in-integer-comparison-operations>rationale</a>
).</p><h3 id=constant-operation>&lsquo;constant&rsquo; operation</h3><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `constant` attribute-value `:` type
</code></pre><p>The <code>constant</code> operation produces an SSA value equal to some constant specified
by an attribute. This is the way that MLIR uses to form simple integer and
floating point constants, as well as more exotic things like references to
functions and (TODO!) tensor/vector constants.</p><p>The <code>constant</code> operation is represented with a single attribute named &ldquo;value&rdquo;.
The type specifies the result type of the operation.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Integer constant
</span><span class=c></span><span class=nv>%1</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>42</span> <span class=p>:</span> <span class=k>i32</span>

<span class=c>// Reference to function @myfn.
</span><span class=c></span><span class=nv>%3</span> <span class=p>=</span> <span class=kt>constant</span> <span class=nf>@myfn</span> <span class=p>:</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>16x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>16x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Equivalent generic forms
</span><span class=c></span><span class=nv>%1</span> <span class=p>=</span> <span class=s>&#34;std.constant&#34;</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span><span class=nl>value =</span> <span class=m>42</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}</span> <span class=p>:</span> <span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span>
<span class=nv>%3</span> <span class=p>=</span> <span class=s>&#34;std.constant&#34;</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span><span class=nl>value =</span> <span class=nf>@myfn</span><span class=p>}</span>
   <span class=p>:</span> <span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>16x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>16x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span>

</code></pre></div><p>MLIR does not allow direct references to functions in SSA operands because the
compiler is multithreaded, and disallowing SSA values to directly reference a
function simplifies this
(
<a href=/docs/Rationale/#multithreading-the-compiler>rationale</a>
).</p><h3 id=copysign-operation>&lsquo;copysign&rsquo; operation</h3><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `copysign` ssa-use `:` type
</code></pre><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar copysign value.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> copysign <span class=nv>%b</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>f64</span>

<span class=c>// SIMD vector element-wise copysign value.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> copysign <span class=nv>%g</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise copysign value.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> copysign <span class=nv>%y</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span>f8<span class=p>&gt;</span>
</code></pre></div><p>The <code>copysign</code> returns a value with the magnitude of the first operand and the
sign of the second operand. It takes two operands and returns one result of the
same type. This type may be a float scalar type, a vector whose element type is
float, or a tensor of floats. It has no standard attributes.</p><h3 id=divis-operation>&lsquo;divis&rsquo; operation</h3><p>Signed integer division. Rounds towards zero. Treats the leading bit as sign,
i.e. <code>6 / -2 = -3</code>.</p><p>Note: the semantics of division by zero or signed division overflow (minimum
value divided by -1) is TBD; do NOT assume any specific behavior.</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `divis` ssa-use `,` ssa-use `:` type
</code></pre><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar signed integer division.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> divis <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>

<span class=c>// SIMD vector element-wise division.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> divis <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise integer division.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> divis <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</code></pre></div><p>The <code>divis</code> operation takes two operands and returns one result, each of these
is required to be the same type. This type may be an integer scalar type, a
vector whose element type is integer, or a tensor of integers. It has no
standard attributes.</p><h3 id=diviu-operation>&lsquo;diviu&rsquo; operation</h3><p>Unsigned integer division. Rounds towards zero. Treats the leading bit as the
most significant, i.e. for <code>i16</code> given two&rsquo;s complement representation, <code>6 / -2 = 6 / (2^16 - 2) = 0</code>.</p><p>Note: the semantics of division by zero is TBD; do NOT assume any specific
behavior.</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `diviu` ssa-use `,` ssa-use `:` type
</code></pre><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar unsigned integer division.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> diviu <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>

<span class=c>// SIMD vector element-wise division.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> diviu <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise integer division.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> diviu <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</code></pre></div><p>The <code>diviu</code> operation takes two operands and returns one result, each of these
is required to be the same type. This type may be an integer scalar type, a
vector whose element type is integer, or a tensor of integers. It has no
standard attributes.</p><h3 id=memref_cast-operation>&lsquo;memref_cast&rsquo; operation</h3><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `memref_cast` ssa-use `:` type `to` type
</code></pre><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Discard static dimension information.
</span><span class=c></span><span class=nv>%3</span> <span class=p>=</span> <span class=kt>memref</span>_cast <span class=nv>%2</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>f32</span><span class=p>&gt;</span> to <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Convert to a type with more known dimensions.
</span><span class=c></span><span class=nv>%4</span> <span class=p>=</span> <span class=kt>memref</span>_cast <span class=nv>%3</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span> to <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Convert to a type with unknown rank.
</span><span class=c></span><span class=nv>%5</span> <span class=p>=</span> <span class=kt>memref</span>_cast <span class=nv>%3</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span> to <span class=kt>memref</span><span class=p>&lt;</span><span class=p>*</span>xf32<span class=p>&gt;</span>

<span class=c>// Convert to a type with static rank.
</span><span class=c></span><span class=nv>%6</span> <span class=p>=</span> <span class=kt>memref</span>_cast <span class=nv>%5</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=p>*</span>xf32<span class=p>&gt;</span> to <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><p>Convert a memref from one type to an equivalent type without changing any data
elements. The types are equivalent if 1. they both have the same static rank,
same element type, same mappings, same address space. The operation is invalid
if converting to a mismatching constant dimension, or 2. exactly one of the
operands have an unknown rank, and they both have the same element type and same
address space. The operation is invalid if both operands are of dynamic rank or
if converting to a mismatching static rank.</p><h3 id=mulf-operation>&lsquo;mulf&rsquo; operation</h3><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `mulf` ssa-use `,` ssa-use `:` type
</code></pre><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar multiplication.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> mulf <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>f64</span>

<span class=c>// SIMD pointwise vector multiplication, e.g. for Intel SSE.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> mulf <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Tensor pointwise multiplication.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> mulf <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>bf16</span><span class=p>&gt;</span>
</code></pre></div><p>The <code>mulf</code> operation takes two operands and returns one result, each of these is
required to be the same type. This type may be a floating point scalar type, a
vector whose element type is a floating point type, or a floating point tensor.</p><p>It has no standard attributes.</p><p>TODO: In the distant future, this will accept optional attributes for fast math,
contraction, rounding mode, and other controls.</p><h3 id=or-operation>&lsquo;or&rsquo; operation</h3><p>Bitwise integer or.</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `or` ssa-use `,` ssa-use `:` type
</code></pre><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar integer bitwise or.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> or <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>

<span class=c>// SIMD vector element-wise bitwise integer or.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> or <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise bitwise integer or.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> or <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</code></pre></div><p>The <code>or</code> operation takes two operands and returns one result, each of these is
required to be the same type. This type may be an integer scalar type, a vector
whose element type is integer, or a tensor of integers. It has no standard
attributes.</p><h3 id=remis-operation>&lsquo;remis&rsquo; operation</h3><p>Signed integer division remainder. Treats the leading bit as sign, i.e. <code>6 % -2 = 0</code>.</p><p>Note: the semantics of division by zero is TBD; do NOT assume any specific
behavior.</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `remis` ssa-use `,` ssa-use `:` type
</code></pre><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar signed integer division remainder.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> remis <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>

<span class=c>// SIMD vector element-wise division remainder.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> remis <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise integer division remainder.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> remis <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</code></pre></div><p>The <code>remis</code> operation takes two operands and returns one result, each of these
is required to be the same type. This type may be an integer scalar type, a
vector whose element type is integer, or a tensor of integers. It has no
standard attributes.</p><h3 id=remiu-operation>&lsquo;remiu&rsquo; operation</h3><p>Unsigned integer division remainder. Treats the leading bit as the most
significant, i.e. for <code>i16</code>, <code>6 % -2 = 6 % (2^16 - 2) = 6</code>.</p><p>Note: the semantics of division by zero is TBD; do NOT assume any specific
behavior.</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `remiu` ssa-use `,` ssa-use `:` type
</code></pre><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar unsigned integer division remainder.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> remiu <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>

<span class=c>// SIMD vector element-wise division remainder.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> remiu <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise integer division remainder.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> remiu <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</code></pre></div><p>The <code>remiu</code> operation takes two operands and returns one result, each of these
is required to be the same type. This type may be an integer scalar type, a
vector whose element type is integer, or a tensor of integers. It has no
standard attributes.</p><h3 id=select-operation>&lsquo;select&rsquo; operation</h3><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `select` ssa-use `,` ssa-use `,` ssa-use `:` type
</code></pre><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Custom form of scalar selection.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> select <span class=nv>%cond</span><span class=p>,</span> <span class=nv>%true</span><span class=p>,</span> <span class=nv>%false</span> <span class=p>:</span> <span class=k>i32</span>

<span class=c>// Generic form of the same operation.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> <span class=s>&#34;std.select&#34;</span><span class=p>(</span><span class=nv>%cond</span><span class=p>,</span> <span class=nv>%true</span><span class=p>,</span> <span class=nv>%false</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i1</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span>

<span class=c>// Vector selection is element-wise
</span><span class=c></span><span class=nv>%vx</span> <span class=p>=</span> <span class=s>&#34;std.select&#34;</span><span class=p>(</span><span class=nv>%vcond</span><span class=p>,</span> <span class=nv>%vtrue</span><span class=p>,</span> <span class=nv>%vfalse</span><span class=p>)</span>
    <span class=p>:</span> <span class=p>(</span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>42x</span><span class=k>i1</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>42x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>42x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>42x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><p>The <code>select</code> operation chooses one value based on a binary condition supplied as
its first operand. If the value of the first operand is <code>1</code>, the second operand
is chosen, otherwise the third operand is chosen. The second and the third
operand must have the same type.</p><p>The operation applies to vectors and tensors elementwise given the <em>shape</em> of
all operands is identical. The choice is made for each element individually
based on the value at the same position as the element in the condition operand.</p><p>The <code>select</code> operation combined with
<a href=#cmpi-operation><code>cmpi</code></a>
can be used to
implement <code>min</code> and <code>max</code> with signed or unsigned comparison semantics.</p><h3 id=tensor_cast-operation>&lsquo;tensor_cast&rsquo; operation</h3><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `tensor_cast` ssa-use `:` type `to` type
</code></pre><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Convert from unknown rank to rank 2 with unknown dimension sizes.
</span><span class=c></span><span class=nv>%2</span> <span class=p>=</span> <span class=s>&#34;std.tensor_cast&#34;</span><span class=p>(</span><span class=nv>%1</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=p>*</span>xf32<span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=nv>%2</span> <span class=p>=</span> <span class=kt>tensor</span>_cast <span class=nv>%1</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=p>*</span>xf32<span class=p>&gt;</span> to <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Convert to a type with more known dimensions.
</span><span class=c></span><span class=nv>%3</span> <span class=p>=</span> <span class=s>&#34;std.tensor_cast&#34;</span><span class=p>(</span><span class=nv>%2</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Discard static dimension and rank information.
</span><span class=c></span><span class=nv>%4</span> <span class=p>=</span> <span class=s>&#34;std.tensor_cast&#34;</span><span class=p>(</span><span class=nv>%3</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=nv>%5</span> <span class=p>=</span> <span class=s>&#34;std.tensor_cast&#34;</span><span class=p>(</span><span class=nv>%4</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=p>*</span>xf32<span class=p>&gt;</span>
</code></pre></div><p>Convert a tensor from one type to an equivalent type without changing any data
elements. The source and destination types must both be tensor types with the
same element type. If both are ranked, then the rank should be the same and
static dimensions should match. The operation is invalid if converting to a
mismatching constant dimension.</p><h3 id=xor-operation>&lsquo;xor&rsquo; operation</h3><p>Bitwise integer xor.</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `xor` ssa-use, ssa-use `:` type
</code></pre><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar integer bitwise xor.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> xor <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>

<span class=c>// SIMD vector element-wise bitwise integer xor.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> xor <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise bitwise integer xor.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> xor <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</code></pre></div><p>The <code>xor</code> operation takes two operands and returns one result, each of these is
required to be the same type. This type may be an integer scalar type, a vector
whose element type is integer, or a tensor of integers. It has no standard
attributes.</p><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Dialects/SPIR-V/ title="SPIR-V Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - SPIR-V Dialect</a>
<a class="nav nav-next" href=/docs/Dialects/Vector/ title="Vector Dialect">Next - Vector Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class="parent has-sub-menu"><a href=/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Dialects/AffineDialect/>'affine' Dialect</a></li><li><a href=/docs/Dialects/FxpMathDialect/>'fxpmath' Dialect</a></li><li><a href=/docs/Dialects/GPUDialect/>'gpu' Dialect</a></li><li><a href=/docs/Dialects/LinalgDialect/>'linalg' Dialect</a></li><li><a href=/docs/Dialects/LoopDialect/>'loop' Dialect</a></li><li><a href=/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=/docs/Dialects/SPIRVDialect/>'spv' Dialect</a></li><li><a href=/docs/Dialects/Affine/>Affine Dialect</a></li><li><a href=/docs/Dialects/GPU/>GPU Dialect</a></li><li><a href=/docs/Dialects/Linalg/>Linalg Dialect</a></li><li><a href=/docs/Dialects/LLVM/>LLVM IR Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li class=active><a href=/docs/Dialects/Standard/>Standard Dialect</a></li><li><a href=/docs/Dialects/Vector/>Vector Dialect</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Tutorial Introduction</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/EDSC/>Background: declarative builders API</a></li><li><a href=/docs/ConversionToLLVMDialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li><a href=/docs/Diagnostics/>Introduction and Usage Guide to MLIR's Diagnostics Infrastructure</a></li><li><a href=/docs/Interfaces/>Introduction to MLIR Interfaces</a></li><li><a href=/docs/Traits/>Introduction to MLIR Operation Traits</a></li><li><a href=/docs/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/GenericDAGRewriter/>MLIR Generic DAG Rewriter Infrastructure</a></li><li><a href=/docs/Passes/>MLIR Passes</a></li><li><a href=/docs/Quantization/>MLIR Quantization</a></li><li><a href=/docs/Rationale/>MLIR Rationale</a></li><li><a href=/docs/LangRef/>MLIR Specification</a></li><li><a href=/docs/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization in MLIR</a></li><li><a href=/docs/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li><a href=/docs/DefiningAttributesAndTypes/>Quickstart tutorial to defining custom dialect attributes and types</a></li><li><a href=/docs/ShapeInference/>Shape inference</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/OpDefinitions/>Table-driven Operation Definition Specification (ODS)</a></li><li><a href=/docs/UsageOfConst/>Usage of 'Const' in MLIR, for core IR types</a></li><li><a href=/docs/WritingAPass/>Writing a Pass</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>