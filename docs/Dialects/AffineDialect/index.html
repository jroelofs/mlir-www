<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'affine' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.64.1"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/AffineDialect/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/master/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/master/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li></ul></nav></div><div class=content-container><main><h1>'affine' Dialect</h1><p><nav id=TableOfContents><ul><li><a href=#operation-definition>Operation definition</a><ul><li><a href=#affineapply-affineapplyop>affine.apply (AffineApplyOp)</a></li><li><a href=#affinefor-affineforop>affine.for (AffineForOp)</a></li><li><a href=#affineif-affineifop>affine.if (AffineIfOp)</a></li><li><a href=#affinemax-affinemaxop>affine.max (AffineMaxOp)</a></li><li><a href=#affinemin-affineminop>affine.min (AffineMinOp)</a></li><li><a href=#affineparallel-affineparallelop>affine.parallel (AffineParallelOp)</a></li><li><a href=#affineprefetch-affineprefetchop>affine.prefetch (AffinePrefetchOp)</a></li><li><a href=#affineterminator-affineterminatorop>affine.terminator (AffineTerminatorOp)</a></li></ul></li></ul></nav><h2 id=operation-definition>Operation definition</h2><h3 id=affineapply-affineapplyop><code>affine.apply</code> (AffineApplyOp)</h3><p>affine apply operation</p><p>The affine.apply operation applies an affine mapping to a list of SSA
values, yielding a single SSA value. The number of dimension and symbol
arguments to affine.apply must be equal to the respective number of
dimensional and symbolic inputs to the affine mapping; the affine mapping
has to be one-dimensional, and so the affine.apply operation always returns
one value. The input operands and result must all have ‘index’ type.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>  <span class=nv>#map10</span> <span class=p>=</span> affine_map<span class=p>&lt;</span><span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 floordiv <span class=m>8</span> <span class=err>+</span> d1 floordiv <span class=m>128</span><span class=p>)</span><span class=p>&gt;</span>
  <span class=p>.</span><span class=p>.</span><span class=p>.</span>
  <span class=nv>%1</span> <span class=p>=</span> affine<span class=p>.</span>apply <span class=nv>#map10</span> <span class=p>(</span><span class=nv>%s</span><span class=p>,</span> <span class=nv>%t</span><span class=p>)</span>

  <span class=c>// Inline example.
</span><span class=c></span>  <span class=nv>%2</span> <span class=p>=</span> affine<span class=p>.</span>apply affine_map<span class=p>&lt;</span><span class=p>(</span>i<span class=p>)</span><span class=p>[</span>s0<span class=p>]</span> <span class=p>-&gt;</span> <span class=p>(</span>i<span class=err>+</span>s0<span class=p>)</span><span class=p>&gt;</span> <span class=p>(</span><span class=nv>%42</span><span class=p>)</span><span class=p>[</span><span class=nv>%n</span><span class=p>]</span>
</code></pre></div><h4 id=attributes>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>map</code></td><td align=center>AffineMapAttr</td><td>AffineMap attribute</td></tr></tbody></table><h4 id=operands>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>mapOperands</code></td><td>index</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>index</td></tr></tbody></table><h3 id=affinefor-affineforop><code>affine.for</code> (AffineForOp)</h3><p>for operation</p><p>The &ldquo;affine.for&rdquo; operation represents an affine loop nest, defining an SSA
value for its induction variable. It has one region capturing the loop body.
The induction variable is represented as a argument of this region. This SSA
value always has type index, which is the size of the machine word. The
stride, represented by step, is a positive constant integer which defaults
to &ldquo;1&rdquo; if not present. The lower and upper bounds specify a half-open range:
the range includes the lower bound but does not include the upper bound.</p><p>The body region must contain exactly one block that terminates with
&ldquo;affine.terminator&rdquo;. Calling AffineForOp::build will create such region
and insert the terminator, so will the parsing even in cases if it is absent
from the custom format.</p><p>The lower and upper bounds of a for operation are represented as an
application of an affine mapping to a list of SSA values passed to the map.
The same restrictions hold for these SSA values as for all bindings of SSA
values to dimensions and symbols. The affine mappings for the bounds may
return multiple results, in which case the max/min keywords are required
(for the lower/upper bound respectively), and the bound is the
maximum/minimum of the returned values.</p><p>Example:</p><p>affine.for %i = 1 to 10 {
&mldr;
}</p><h4 id=operands-1>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=affineif-affineifop><code>affine.if</code> (AffineIfOp)</h3><p>if-then-else operation</p><p>The &ldquo;if&rdquo; operation represents an if-then-else construct for conditionally
executing two regions of code. The operands to an if operation are an
IntegerSet condition and a set of symbol/dimension operands to the
condition set. The operation produces no results. For example:</p><p>affine.if #set(%i) {
&mldr;
} else {
&mldr;
}</p><p>The &lsquo;else&rsquo; blocks to the if operation are optional, and may be omitted. For
example:</p><p>affine.if #set(%i) {
&mldr;
}</p><h4 id=operands-2>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=affinemax-affinemaxop><code>affine.max</code> (AffineMaxOp)</h3><p>max operation</p><p>The &ldquo;max&rdquo; operation computes the maximum value result from a multi-result
affine map.</p><p>Example:</p><p>%0 = affine.max (d0) -> (1000, d0 + 512) (%i0) : index</p><h4 id=attributes-1>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>map</code></td><td align=center>AffineMapAttr</td><td>AffineMap attribute</td></tr></tbody></table><h4 id=operands-3>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operands</code></td><td>index</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>index</td></tr></tbody></table><h3 id=affinemin-affineminop><code>affine.min</code> (AffineMinOp)</h3><p>min operation</p><p>The &ldquo;min&rdquo; operation computes the minimum value result from a multi-result
affine map.</p><p>Example:</p><p>%0 = affine.min (d0) -> (1000, d0 + 512) (%i0) : index</p><h4 id=attributes-2>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>map</code></td><td align=center>AffineMapAttr</td><td>AffineMap attribute</td></tr></tbody></table><h4 id=operands-4>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operands</code></td><td>index</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>index</td></tr></tbody></table><h3 id=affineparallel-affineparallelop><code>affine.parallel</code> (AffineParallelOp)</h3><p>multi-index parallel band operation</p><p>The &ldquo;affine.parallel&rdquo; operation represents a hyper-rectangular affine
parallel band, defining multiple SSA values for its induction variables. It
has one region capturing the parallel band body. The induction variables are
represented as arguments of this region. These SSA values always have type
index, which is the size of the machine word. The strides, represented by
steps, are positive constant integers which defaults to &ldquo;1&rdquo; if not present.
The lower and upper bounds specify a half-open range: the range includes the
lower bound but does not include the upper bound. The body region must
contain exactly one block that terminates with &ldquo;affine.terminator&rdquo;.</p><p>The lower and upper bounds of a parallel operation are represented as an
application of an affine mapping to a list of SSA values passed to the map.
The same restrictions hold for these SSA values as for all bindings of SSA
values to dimensions and symbols.</p><p>Note: Calling AffineParallelOp::build will create the required region and
block, and insert the required terminator. Parsing will also create the
required region, block, and terminator, even when they are missing from the
textual representation.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>  affine<span class=p>.</span>parallel <span class=p>(</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>)</span> <span class=p>=</span> <span class=p>(</span><span class=m>0</span><span class=p>,</span> <span class=m>0</span><span class=p>)</span> to <span class=p>(</span><span class=m>10</span><span class=p>,</span> <span class=m>10</span><span class=p>)</span> step <span class=p>(</span><span class=m>1</span><span class=p>,</span> <span class=m>1</span><span class=p>)</span> <span class=p>{</span>
    <span class=p>.</span><span class=p>.</span><span class=p>.</span>
  <span class=p>}</span>
</code></pre></div><h4 id=attributes-3>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lowerBoundsMap</code></td><td align=center>AffineMapAttr</td><td>AffineMap attribute</td></tr><tr><td align=center><code>upperBoundsMap</code></td><td align=center>AffineMapAttr</td><td>AffineMap attribute</td></tr><tr><td align=center><code>steps</code></td><td align=center>ArrayAttr</td><td>64-bit integer array attribute</td></tr></tbody></table><h4 id=operands-5>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>mapOperands</code></td><td>index</td></tr></tbody></table><h3 id=affineprefetch-affineprefetchop><code>affine.prefetch</code> (AffinePrefetchOp)</h3><p>affine prefetch operation</p><p>The &ldquo;affine.prefetch&rdquo; op prefetches data from a memref location described
with an affine subscript similar to affine.load, and has three attributes:
a read/write specifier, a locality hint, and a cache type specifier as shown
below:</p><p>affine.prefetch %0[%i, %j + 5], read, locality&lt;3>, data
: memref&lt;400x400xi32></p><p>The read/write specifier is either &lsquo;read&rsquo; or &lsquo;write&rsquo;, the locality hint
specifier ranges from locality&lt;0> (no locality) to locality&lt;3> (extremely
local keep in cache). The cache type specifier is either &lsquo;data&rsquo; or &lsquo;instr&rsquo;
and specifies whether the prefetch is performed on data cache or on
instruction cache.</p><h4 id=attributes-4>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>isWrite</code></td><td align=center>BoolAttr</td><td>bool attribute</td></tr><tr><td align=center><code>localityHint</code></td><td align=center>IntegerAttr</td><td>32-bit signless integer attribute whose minimum value is 0 whose maximum value is 3</td></tr><tr><td align=center><code>isDataCache</code></td><td align=center>BoolAttr</td><td>bool attribute</td></tr></tbody></table><h4 id=operands-6>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>memref</code></td><td>memref of any type values</td></tr><tr><td align=center><code>indices</code></td><td>index</td></tr></tbody></table><h3 id=affineterminator-affineterminatorop><code>affine.terminator</code> (AffineTerminatorOp)</h3><p>affine terminator operation</p><p>Affine terminator is a special terminator operation for blocks inside affine
loops and branches. It unconditionally transmits the control flow to the
successor of the operation enclosing the region.</p><p>This operation does <em>not</em> have a custom syntax. However, affine control
operations omit the terminator in their custom syntax for brevity.</p><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Dialects/ title=Dialects><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Dialects</a>
<a class="nav nav-next" href=/docs/Dialects/FxpMathDialect/ title="'fxpmath' Dialect">Next - 'fxpmath' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class="parent has-sub-menu"><a href=/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li class=active><a href=/docs/Dialects/AffineDialect/>'affine' Dialect</a></li><li><a href=/docs/Dialects/FxpMathDialect/>'fxpmath' Dialect</a></li><li><a href=/docs/Dialects/GPUDialect/>'gpu' Dialect</a></li><li><a href=/docs/Dialects/LinalgDialect/>'linalg' Dialect</a></li><li><a href=/docs/Dialects/LoopDialect/>'loop' Dialect</a></li><li><a href=/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=/docs/Dialects/SPIRVDialect/>'spv' Dialect</a></li><li><a href=/docs/Dialects/Affine/>Affine Dialect</a></li><li><a href=/docs/Dialects/GPU/>GPU Dialect</a></li><li><a href=/docs/Dialects/Linalg/>Linalg Dialect</a></li><li><a href=/docs/Dialects/LLVM/>LLVM IR Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=/docs/Dialects/Standard/>Standard Dialect</a></li><li><a href=/docs/Dialects/Vector/>Vector Dialect</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Tutorial Introduction</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/EDSC/>Background: declarative builders API</a></li><li><a href=/docs/ConversionToLLVMDialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li><a href=/docs/Diagnostics/>Introduction and Usage Guide to MLIR's Diagnostics Infrastructure</a></li><li><a href=/docs/Interfaces/>Introduction to MLIR Interfaces</a></li><li><a href=/docs/Traits/>Introduction to MLIR Operation Traits</a></li><li><a href=/docs/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/GenericDAGRewriter/>MLIR Generic DAG Rewriter Infrastructure</a></li><li><a href=/docs/Passes/>MLIR Passes</a></li><li><a href=/docs/Quantization/>MLIR Quantization</a></li><li><a href=/docs/Rationale/>MLIR Rationale</a></li><li><a href=/docs/LangRef/>MLIR Specification</a></li><li><a href=/docs/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization in MLIR</a></li><li><a href=/docs/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li><a href=/docs/DefiningAttributesAndTypes/>Quickstart tutorial to defining custom dialect attributes and types</a></li><li><a href=/docs/ShapeInference/>Shape inference</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/OpDefinitions/>Table-driven Operation Definition Specification (ODS)</a></li><li><a href=/docs/UsageOfConst/>Usage of 'Const' in MLIR, for core IR types</a></li><li><a href=/docs/WritingAPass/>Writing a Pass</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>