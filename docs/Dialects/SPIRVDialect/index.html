<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'spv' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.64.1"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/SPIRVDialect/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/master/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/master/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li></ul></nav></div><div class=content-container><main><h1>'spv' Dialect</h1><p>The SPIR-V dialect in MLIR.</p><p>SPIR-V is a binary intermediate language for representing graphical-shader
stages and compute kernels for multiple Khronos APIs, including OpenCL,
OpenGL, and Vulkan.
See <a href=https://www.khronos.org/registry/spir-v>https://www.khronos.org/registry/spir-v</a> for more details regarding
SPIR-V itself.</p><p>The SPIR-V dialect aims to be a proper compiler intermediate representation
to facilitate transformations. Ops in this dialect stay at the same semantic
level as the SPIR-V specification and try to have one-to-one mapping to the
corresponding SPIR-V instructions; but they may deviate representationally
to utilize MLIR mechanisms if it results in better representation and thus
benefits transformations. The dialect also aims to maintain straightforward
serialization into and deserialization from the SPIR-V binary format.
See <a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>https://mlir.llvm.org/docs/Dialects/SPIR-V/</a> for more details regarding
high-level designs and implementation structures of the SPIR-V dialect.</p><p><nav id=TableOfContents><ul><li><a href=#type-definition>Type definition</a><ul><li><a href=#any-spir-v-array-type>any SPIR-V array type</a></li><li><a href=#any-spir-v-pointer-type>any SPIR-V pointer type</a></li><li><a href=#any-spir-v-runtime-array-type>any SPIR-V runtime array type</a></li><li><a href=#any-spir-v-struct-type>any SPIR-V struct type</a></li></ul></li><li><a href=#operation-definition>Operation definition</a><ul><li><a href=#spvaccesschain-spirvaccesschainop>spv.AccessChain (spirv::AccessChainOp)</a></li><li><a href=#custom-assembly-form>Custom assembly form</a></li><li><a href=#spv_address_of-spirvaddressofop>spv._address_of (spirv::AddressOfOp)</a></li><li><a href=#custom-assembly-form-1>Custom assembly form</a></li><li><a href=#spvatomicand-spirvatomicandop>spv.AtomicAnd (spirv::AtomicAndOp)</a></li><li><a href=#custom-assembly-form-2>Custom assembly form</a></li><li><a href=#spvatomiccompareexchangeweak-spirvatomiccompareexchangeweakop>spv.AtomicCompareExchangeWeak (spirv::AtomicCompareExchangeWeakOp)</a></li><li><a href=#custom-assembly-form-3>Custom assembly form</a></li><li><a href=#spvatomiciadd-spirvatomiciaddop>spv.AtomicIAdd (spirv::AtomicIAddOp)</a></li><li><a href=#custom-assembly-form-4>Custom assembly form</a></li><li><a href=#spvatomicidecrement-spirvatomicidecrementop>spv.AtomicIDecrement (spirv::AtomicIDecrementOp)</a></li><li><a href=#custom-assembly-form-5>Custom assembly form</a></li><li><a href=#spvatomiciincrement-spirvatomiciincrementop>spv.AtomicIIncrement (spirv::AtomicIIncrementOp)</a></li><li><a href=#custom-assembly-form-6>Custom assembly form</a></li><li><a href=#spvatomicisub-spirvatomicisubop>spv.AtomicISub (spirv::AtomicISubOp)</a></li><li><a href=#custom-assembly-form-7>Custom assembly form</a></li><li><a href=#spvatomicor-spirvatomicorop>spv.AtomicOr (spirv::AtomicOrOp)</a></li><li><a href=#custom-assembly-form-8>Custom assembly form</a></li><li><a href=#spvatomicsmax-spirvatomicsmaxop>spv.AtomicSMax (spirv::AtomicSMaxOp)</a></li><li><a href=#custom-assembly-form-9>Custom assembly form</a></li><li><a href=#spvatomicsmin-spirvatomicsminop>spv.AtomicSMin (spirv::AtomicSMinOp)</a></li><li><a href=#custom-assembly-form-10>Custom assembly form</a></li><li><a href=#spvatomicumax-spirvatomicumaxop>spv.AtomicUMax (spirv::AtomicUMaxOp)</a></li><li><a href=#custom-assembly-form-11>Custom assembly form</a></li><li><a href=#spvatomicumin-spirvatomicuminop>spv.AtomicUMin (spirv::AtomicUMinOp)</a></li><li><a href=#custom-assembly-form-12>Custom assembly form</a></li><li><a href=#spvatomicxor-spirvatomicxorop>spv.AtomicXor (spirv::AtomicXorOp)</a></li><li><a href=#custom-assembly-form-13>Custom assembly form</a></li><li><a href=#spvbitcount-spirvbitcountop>spv.BitCount (spirv::BitCountOp)</a></li><li><a href=#custom-assembly-form-14>Custom assembly form</a></li><li><a href=#spvbitfieldinsert-spirvbitfieldinsertop>spv.BitFieldInsert (spirv::BitFieldInsertOp)</a></li><li><a href=#custom-assembly-form-15>Custom assembly form</a></li><li><a href=#spvbitfieldsextract-spirvbitfieldsextractop>spv.BitFieldSExtract (spirv::BitFieldSExtractOp)</a></li><li><a href=#custom-assembly-form-16>Custom assembly form</a></li><li><a href=#spvbitfielduextract-spirvbitfielduextractop>spv.BitFieldUExtract (spirv::BitFieldUExtractOp)</a></li><li><a href=#custom-assembly-form-17>Custom assembly form</a></li><li><a href=#spvbitreverse-spirvbitreverseop>spv.BitReverse (spirv::BitReverseOp)</a></li><li><a href=#custom-assembly-form-18>Custom assembly form</a></li><li><a href=#spvbitcast-spirvbitcastop>spv.Bitcast (spirv::BitcastOp)</a></li><li><a href=#custom-assembly-form-19>Custom assembly form</a></li><li><a href=#spvbitwiseand-spirvbitwiseandop>spv.BitwiseAnd (spirv::BitwiseAndOp)</a></li><li><a href=#custom-assembly-form-20>Custom assembly form</a></li><li><a href=#spvbitwiseor-spirvbitwiseorop>spv.BitwiseOr (spirv::BitwiseOrOp)</a></li><li><a href=#custom-assembly-form-21>Custom assembly form</a></li><li><a href=#spvbitwisexor-spirvbitwisexorop>spv.BitwiseXor (spirv::BitwiseXorOp)</a></li><li><a href=#custom-assembly-form-22>Custom assembly form</a></li><li><a href=#spvbranchconditional-spirvbranchconditionalop>spv.BranchConditional (spirv::BranchConditionalOp)</a></li><li><a href=#custom-assembly-form-23>Custom assembly form</a></li><li><a href=#spvbranch-spirvbranchop>spv.Branch (spirv::BranchOp)</a></li><li><a href=#custom-assembly-form-24>Custom assembly form</a></li><li><a href=#spvcompositeconstruct-spirvcompositeconstructop>spv.CompositeConstruct (spirv::CompositeConstructOp)</a></li><li><a href=#custom-assembly-form-25>Custom assembly form</a></li><li><a href=#spvcompositeextract-spirvcompositeextractop>spv.CompositeExtract (spirv::CompositeExtractOp)</a></li><li><a href=#custom-assembly-form-26>Custom assembly form</a></li><li><a href=#spvcompositeinsert-spirvcompositeinsertop>spv.CompositeInsert (spirv::CompositeInsertOp)</a></li><li><a href=#custom-assembly-form-27>Custom assembly form</a></li><li><a href=#spvconstant-spirvconstantop>spv.constant (spirv::ConstantOp)</a></li><li><a href=#custom-assembly-form-28>Custom assembly form</a></li><li><a href=#spvcontrolbarrier-spirvcontrolbarrierop>spv.ControlBarrier (spirv::ControlBarrierOp)</a></li><li><a href=#custom-assembly-form-29>Custom assembly form</a></li><li><a href=#spvconvertftos-spirvconvertftosop>spv.ConvertFToS (spirv::ConvertFToSOp)</a></li><li><a href=#custom-assembly-form-30>Custom assembly form</a></li><li><a href=#spvconvertftou-spirvconvertftouop>spv.ConvertFToU (spirv::ConvertFToUOp)</a></li><li><a href=#custom-assembly-form-31>Custom assembly form</a></li><li><a href=#spvconvertstof-spirvconvertstofop>spv.ConvertSToF (spirv::ConvertSToFOp)</a></li><li><a href=#custom-assembly-form-32>Custom assembly form</a></li><li><a href=#spvconvertutof-spirvconvertutofop>spv.ConvertUToF (spirv::ConvertUToFOp)</a></li><li><a href=#custom-assembly-form-33>Custom assembly form</a></li><li><a href=#spventrypoint-spirventrypointop>spv.EntryPoint (spirv::EntryPointOp)</a></li><li><a href=#custom-assembly-form-34>Custom assembly form</a></li><li><a href=#spvexecutionmode-spirvexecutionmodeop>spv.ExecutionMode (spirv::ExecutionModeOp)</a></li><li><a href=#custom-assembly-form-35>Custom assembly form</a></li><li><a href=#spvfadd-spirvfaddop>spv.FAdd (spirv::FAddOp)</a></li><li><a href=#custom-assembly-form-36>Custom assembly form</a></li><li><a href=#spvfconvert-spirvfconvertop>spv.FConvert (spirv::FConvertOp)</a></li><li><a href=#custom-assembly-form-37>Custom assembly form</a></li><li><a href=#spvfdiv-spirvfdivop>spv.FDiv (spirv::FDivOp)</a></li><li><a href=#custom-assembly-form-38>Custom assembly form</a></li><li><a href=#spvfmod-spirvfmodop>spv.FMod (spirv::FModOp)</a></li><li><a href=#custom-assembly-form-39>Custom assembly form</a></li><li><a href=#spvfmul-spirvfmulop>spv.FMul (spirv::FMulOp)</a></li><li><a href=#custom-assembly-form-40>Custom assembly form</a></li><li><a href=#spvfnegate-spirvfnegateop>spv.FNegate (spirv::FNegateOp)</a></li><li><a href=#custom-assembly-form-41>Custom assembly form</a></li><li><a href=#spvfordequal-spirvfordequalop>spv.FOrdEqual (spirv::FOrdEqualOp)</a></li><li><a href=#custom-assembly-form-42>Custom assembly form</a></li><li><a href=#spvfordgreaterthanequal-spirvfordgreaterthanequalop>spv.FOrdGreaterThanEqual (spirv::FOrdGreaterThanEqualOp)</a></li><li><a href=#custom-assembly-form-43>Custom assembly form</a></li><li><a href=#spvfordgreaterthan-spirvfordgreaterthanop>spv.FOrdGreaterThan (spirv::FOrdGreaterThanOp)</a></li><li><a href=#custom-assembly-form-44>Custom assembly form</a></li><li><a href=#spvfordlessthanequal-spirvfordlessthanequalop>spv.FOrdLessThanEqual (spirv::FOrdLessThanEqualOp)</a></li><li><a href=#custom-assembly-form-45>Custom assembly form</a></li><li><a href=#spvfordlessthan-spirvfordlessthanop>spv.FOrdLessThan (spirv::FOrdLessThanOp)</a></li><li><a href=#custom-assembly-form-46>Custom assembly form</a></li><li><a href=#spvfordnotequal-spirvfordnotequalop>spv.FOrdNotEqual (spirv::FOrdNotEqualOp)</a></li><li><a href=#custom-assembly-form-47>Custom assembly form</a></li><li><a href=#spvfrem-spirvfremop>spv.FRem (spirv::FRemOp)</a></li><li><a href=#custom-assembly-form-48>Custom assembly form</a></li><li><a href=#spvfsub-spirvfsubop>spv.FSub (spirv::FSubOp)</a></li><li><a href=#custom-assembly-form-49>Custom assembly form</a></li><li><a href=#spvfunordequal-spirvfunordequalop>spv.FUnordEqual (spirv::FUnordEqualOp)</a></li><li><a href=#custom-assembly-form-50>Custom assembly form</a></li><li><a href=#spvfunordgreaterthanequal-spirvfunordgreaterthanequalop>spv.FUnordGreaterThanEqual (spirv::FUnordGreaterThanEqualOp)</a></li><li><a href=#custom-assembly-form-51>Custom assembly form</a></li><li><a href=#spvfunordgreaterthan-spirvfunordgreaterthanop>spv.FUnordGreaterThan (spirv::FUnordGreaterThanOp)</a></li><li><a href=#custom-assembly-form-52>Custom assembly form</a></li><li><a href=#spvfunordlessthanequal-spirvfunordlessthanequalop>spv.FUnordLessThanEqual (spirv::FUnordLessThanEqualOp)</a></li><li><a href=#custom-assembly-form-53>Custom assembly form</a></li><li><a href=#spvfunordlessthan-spirvfunordlessthanop>spv.FUnordLessThan (spirv::FUnordLessThanOp)</a></li><li><a href=#custom-assembly-form-54>Custom assembly form</a></li><li><a href=#spvfunordnotequal-spirvfunordnotequalop>spv.FUnordNotEqual (spirv::FUnordNotEqualOp)</a></li><li><a href=#custom-assembly-form-55>Custom assembly form</a></li><li><a href=#spvfunc-spirvfuncop>spv.func (spirv::FuncOp)</a></li><li><a href=#custom-assembly-form-56>Custom assembly form</a></li><li><a href=#spvfunctioncall-spirvfunctioncallop>spv.FunctionCall (spirv::FunctionCallOp)</a></li><li><a href=#custom-assembly-form-57>Custom assembly form</a></li><li><a href=#spvglslceil-spirvglslceilop>spv.GLSL.Ceil (spirv::GLSLCeilOp)</a></li><li><a href=#custom-assembly-format>Custom assembly format</a></li><li><a href=#spvglslcos-spirvglslcosop>spv.GLSL.Cos (spirv::GLSLCosOp)</a></li><li><a href=#custom-assembly-format-1>Custom assembly format</a></li><li><a href=#spvglslexp-spirvglslexpop>spv.GLSL.Exp (spirv::GLSLExpOp)</a></li><li><a href=#custom-assembly-format-2>Custom assembly format</a></li><li><a href=#spvglslfabs-spirvglslfabsop>spv.GLSL.FAbs (spirv::GLSLFAbsOp)</a></li><li><a href=#custom-assembly-format-3>Custom assembly format</a></li><li><a href=#spvglslfmax-spirvglslfmaxop>spv.GLSL.FMax (spirv::GLSLFMaxOp)</a></li><li><a href=#custom-assembly-format-4>Custom assembly format</a></li><li><a href=#spvglslfmin-spirvglslfminop>spv.GLSL.FMin (spirv::GLSLFMinOp)</a></li><li><a href=#custom-assembly-format-5>Custom assembly format</a></li><li><a href=#spvglslfsign-spirvglslfsignop>spv.GLSL.FSign (spirv::GLSLFSignOp)</a></li><li><a href=#custom-assembly-format-6>Custom assembly format</a></li><li><a href=#spvglslfloor-spirvglslfloorop>spv.GLSL.Floor (spirv::GLSLFloorOp)</a></li><li><a href=#custom-assembly-format-7>Custom assembly format</a></li><li><a href=#spvglslinversesqrt-spirvglslinversesqrtop>spv.GLSL.InverseSqrt (spirv::GLSLInverseSqrtOp)</a></li><li><a href=#custom-assembly-format-8>Custom assembly format</a></li><li><a href=#spvglsllog-spirvglsllogop>spv.GLSL.Log (spirv::GLSLLogOp)</a></li><li><a href=#custom-assembly-format-9>Custom assembly format</a></li><li><a href=#spvglslsabs-spirvglslsabsop>spv.GLSL.SAbs (spirv::GLSLSAbsOp)</a></li><li><a href=#custom-assembly-format-10>Custom assembly format</a></li><li><a href=#spvglslsmax-spirvglslsmaxop>spv.GLSL.SMax (spirv::GLSLSMaxOp)</a></li><li><a href=#custom-assembly-format-11>Custom assembly format</a></li><li><a href=#spvglslsmin-spirvglslsminop>spv.GLSL.SMin (spirv::GLSLSMinOp)</a></li><li><a href=#custom-assembly-format-12>Custom assembly format</a></li><li><a href=#spvglslssign-spirvglslssignop>spv.GLSL.SSign (spirv::GLSLSSignOp)</a></li><li><a href=#custom-assembly-format-13>Custom assembly format</a></li><li><a href=#spvglslsin-spirvglslsinop>spv.GLSL.Sin (spirv::GLSLSinOp)</a></li><li><a href=#custom-assembly-format-14>Custom assembly format</a></li><li><a href=#spvglslsqrt-spirvglslsqrtop>spv.GLSL.Sqrt (spirv::GLSLSqrtOp)</a></li><li><a href=#custom-assembly-format-15>Custom assembly format</a></li><li><a href=#spvglsltanh-spirvglsltanhop>spv.GLSL.Tanh (spirv::GLSLTanhOp)</a></li><li><a href=#custom-assembly-format-16>Custom assembly format</a></li><li><a href=#spvglobalvariable-spirvglobalvariableop>spv.globalVariable (spirv::GlobalVariableOp)</a></li><li><a href=#custom-assembly-form-58>Custom assembly form</a></li><li><a href=#spvgroupnonuniformballot-spirvgroupnonuniformballotop>spv.GroupNonUniformBallot (spirv::GroupNonUniformBallotOp)</a></li><li><a href=#custom-assembly-form-59>Custom assembly form</a></li><li><a href=#spvgroupnonuniformelect-spirvgroupnonuniformelectop>spv.GroupNonUniformElect (spirv::GroupNonUniformElectOp)</a></li><li><a href=#custom-assembly-form-60>Custom assembly form</a></li><li><a href=#spvgroupnonuniformfadd-spirvgroupnonuniformfaddop>spv.GroupNonUniformFAdd (spirv::GroupNonUniformFAddOp)</a></li><li><a href=#custom-assembly-form-61>Custom assembly form</a></li><li><a href=#spvgroupnonuniformfmax-spirvgroupnonuniformfmaxop>spv.GroupNonUniformFMax (spirv::GroupNonUniformFMaxOp)</a></li><li><a href=#custom-assembly-form-62>Custom assembly form</a></li><li><a href=#spvgroupnonuniformfmin-spirvgroupnonuniformfminop>spv.GroupNonUniformFMin (spirv::GroupNonUniformFMinOp)</a></li><li><a href=#custom-assembly-form-63>Custom assembly form</a></li><li><a href=#spvgroupnonuniformfmul-spirvgroupnonuniformfmulop>spv.GroupNonUniformFMul (spirv::GroupNonUniformFMulOp)</a></li><li><a href=#custom-assembly-form-64>Custom assembly form</a></li><li><a href=#spvgroupnonuniformiadd-spirvgroupnonuniformiaddop>spv.GroupNonUniformIAdd (spirv::GroupNonUniformIAddOp)</a></li><li><a href=#custom-assembly-form-65>Custom assembly form</a></li><li><a href=#spvgroupnonuniformimul-spirvgroupnonuniformimulop>spv.GroupNonUniformIMul (spirv::GroupNonUniformIMulOp)</a></li><li><a href=#custom-assembly-form-66>Custom assembly form</a></li><li><a href=#spvgroupnonuniformsmax-spirvgroupnonuniformsmaxop>spv.GroupNonUniformSMax (spirv::GroupNonUniformSMaxOp)</a></li><li><a href=#custom-assembly-form-67>Custom assembly form</a></li><li><a href=#spvgroupnonuniformsmin-spirvgroupnonuniformsminop>spv.GroupNonUniformSMin (spirv::GroupNonUniformSMinOp)</a></li><li><a href=#custom-assembly-form-68>Custom assembly form</a></li><li><a href=#spvgroupnonuniformumax-spirvgroupnonuniformumaxop>spv.GroupNonUniformUMax (spirv::GroupNonUniformUMaxOp)</a></li><li><a href=#custom-assembly-form-69>Custom assembly form</a></li><li><a href=#spvgroupnonuniformumin-spirvgroupnonuniformuminop>spv.GroupNonUniformUMin (spirv::GroupNonUniformUMinOp)</a></li><li><a href=#custom-assembly-form-70>Custom assembly form</a></li><li><a href=#spviadd-spirviaddop>spv.IAdd (spirv::IAddOp)</a></li><li><a href=#custom-assembly-form-71>Custom assembly form</a></li><li><a href=#spviequal-spirviequalop>spv.IEqual (spirv::IEqualOp)</a></li><li><a href=#custom-assembly-form-72>Custom assembly form</a></li><li><a href=#spvimul-spirvimulop>spv.IMul (spirv::IMulOp)</a></li><li><a href=#custom-assembly-form-73>Custom assembly form</a></li><li><a href=#spvinotequal-spirvinotequalop>spv.INotEqual (spirv::INotEqualOp)</a></li><li><a href=#custom-assembly-form-74>Custom assembly form</a></li><li><a href=#spvisub-spirvisubop>spv.ISub (spirv::ISubOp)</a></li><li><a href=#custom-assembly-form-75>Custom assembly form</a></li><li><a href=#spvload-spirvloadop>spv.Load (spirv::LoadOp)</a></li><li><a href=#custom-assembly-form-76>Custom assembly form</a></li><li><a href=#spvlogicaland-spirvlogicalandop>spv.LogicalAnd (spirv::LogicalAndOp)</a></li><li><a href=#custom-assembly-form-77>Custom assembly form</a></li><li><a href=#spvlogicalequal-spirvlogicalequalop>spv.LogicalEqual (spirv::LogicalEqualOp)</a></li><li><a href=#custom-assembly-form-78>Custom assembly form</a></li><li><a href=#spvlogicalnotequal-spirvlogicalnotequalop>spv.LogicalNotEqual (spirv::LogicalNotEqualOp)</a></li><li><a href=#custom-assembly-form-79>Custom assembly form</a></li><li><a href=#spvlogicalnot-spirvlogicalnotop>spv.LogicalNot (spirv::LogicalNotOp)</a></li><li><a href=#custom-assembly-form-80>Custom assembly form</a></li><li><a href=#spvlogicalor-spirvlogicalorop>spv.LogicalOr (spirv::LogicalOrOp)</a></li><li><a href=#custom-assembly-form-81>Custom assembly form</a></li><li><a href=#spvloop-spirvloopop>spv.loop (spirv::LoopOp)</a></li><li><a href=#spvmemorybarrier-spirvmemorybarrierop>spv.MemoryBarrier (spirv::MemoryBarrierOp)</a></li><li><a href=#custom-assembly-form-82>Custom assembly form</a></li><li><a href=#spv_merge-spirvmergeop>spv._merge (spirv::MergeOp)</a></li><li><a href=#spv_module_end-spirvmoduleendop>spv._module_end (spirv::ModuleEndOp)</a></li><li><a href=#spvmodule-spirvmoduleop>spv.module (spirv::ModuleOp)</a></li><li><a href=#custom-assembly-form-83>Custom assembly form</a></li><li><a href=#spvnot-spirvnotop>spv.Not (spirv::NotOp)</a></li><li><a href=#custom-assembly-form-84>Custom assembly form</a></li><li><a href=#spv_reference_of-spirvreferenceofop>spv._reference_of (spirv::ReferenceOfOp)</a></li><li><a href=#custom-assembly-form-85>Custom assembly form</a></li><li><a href=#spvreturn-spirvreturnop>spv.Return (spirv::ReturnOp)</a></li><li><a href=#custom-assembly-form-86>Custom assembly form</a></li><li><a href=#spvreturnvalue-spirvreturnvalueop>spv.ReturnValue (spirv::ReturnValueOp)</a></li><li><a href=#custom-assembly-form-87>Custom assembly form</a></li><li><a href=#spvsconvert-spirvsconvertop>spv.SConvert (spirv::SConvertOp)</a></li><li><a href=#custom-assembly-form-88>Custom assembly form</a></li><li><a href=#spvsdiv-spirvsdivop>spv.SDiv (spirv::SDivOp)</a></li><li><a href=#custom-assembly-form-89>Custom assembly form</a></li><li><a href=#spvsgreaterthanequal-spirvsgreaterthanequalop>spv.SGreaterThanEqual (spirv::SGreaterThanEqualOp)</a></li><li><a href=#custom-assembly-form-90>Custom assembly form</a></li><li><a href=#spvsgreaterthan-spirvsgreaterthanop>spv.SGreaterThan (spirv::SGreaterThanOp)</a></li><li><a href=#custom-assembly-form-91>Custom assembly form</a></li><li><a href=#spvslessthanequal-spirvslessthanequalop>spv.SLessThanEqual (spirv::SLessThanEqualOp)</a></li><li><a href=#custom-assembly-form-92>Custom assembly form</a></li><li><a href=#spvslessthan-spirvslessthanop>spv.SLessThan (spirv::SLessThanOp)</a></li><li><a href=#custom-assembly-form-93>Custom assembly form</a></li><li><a href=#spvsmod-spirvsmodop>spv.SMod (spirv::SModOp)</a></li><li><a href=#custom-assembly-form-94>Custom assembly form</a></li><li><a href=#spvsrem-spirvsremop>spv.SRem (spirv::SRemOp)</a></li><li><a href=#custom-assembly-form-95>Custom assembly form</a></li><li><a href=#spvselect-spirvselectop>spv.Select (spirv::SelectOp)</a></li><li><a href=#custom-assembly-form-96>Custom assembly form</a></li><li><a href=#spvselection-spirvselectionop>spv.selection (spirv::SelectionOp)</a></li><li><a href=#spvshiftleftlogical-spirvshiftleftlogicalop>spv.ShiftLeftLogical (spirv::ShiftLeftLogicalOp)</a></li><li><a href=#custom-assembly-form-97>Custom assembly form</a></li><li><a href=#spvshiftrightarithmetic-spirvshiftrightarithmeticop>spv.ShiftRightArithmetic (spirv::ShiftRightArithmeticOp)</a></li><li><a href=#custom-assembly-form-98>Custom assembly form</a></li><li><a href=#spvshiftrightlogical-spirvshiftrightlogicalop>spv.ShiftRightLogical (spirv::ShiftRightLogicalOp)</a></li><li><a href=#custom-assembly-form-99>Custom assembly form</a></li><li><a href=#spvspecconstant-spirvspecconstantop>spv.specConstant (spirv::SpecConstantOp)</a></li><li><a href=#custom-assembly-form-100>Custom assembly form</a></li><li><a href=#spvstore-spirvstoreop>spv.Store (spirv::StoreOp)</a></li><li><a href=#custom-assembly-form-101>Custom assembly form</a></li></ul></li></ul></nav><h2 id=type-definition>Type definition</h2><h3 id=any-spir-v-array-type>any SPIR-V array type</h3><h3 id=any-spir-v-pointer-type>any SPIR-V pointer type</h3><h3 id=any-spir-v-runtime-array-type>any SPIR-V runtime array type</h3><h3 id=any-spir-v-struct-type>any SPIR-V struct type</h3><h2 id=operation-definition>Operation definition</h2><h3 id=spvaccesschain-spirvaccesschainop><code>spv.AccessChain</code> (spirv::AccessChainOp)</h3><pre><code>Create a pointer into a composite object that can be used with OpLoad
and OpStore.
</code></pre><p>Result Type must be an OpTypePointer. Its Type operand must be the type
reached by walking the Base’s type hierarchy down to the last provided
index in Indexes, and its Storage Class operand must be the same as the
Storage Class of Base.</p><p>Base must be a pointer, pointing to the base of a composite object.</p><p>Indexes walk the type hierarchy to the desired depth, potentially down
to scalar granularity. The first index in Indexes will select the top-
level member/element/component/element of the base composite. All
composite constituents use zero-based numbering, as described by their
OpType… instruction. The second index will apply similarly to that
result, and so on. Once any non-composite type is reached, there must be
no remaining (unused) indexes.</p><p>Each index in Indexes</p><ul><li><p>must be a scalar integer type,</p></li><li><p>is treated as a signed count, and</p></li><li><p>must be an OpConstant when indexing into a structure.</p></li></ul><h3 id=custom-assembly-form>Custom assembly form</h3><pre><code>access-chain-op ::= ssa-id `=` `spv.AccessChain` ssa-use
                    `[` ssa-use (',' ssa-use)* `]`
                    `:` pointer-type
</code></pre><p>For example:</p><pre><code>%0 = &quot;spv.constant&quot;() { value = 1: i32} : () -&gt; i32
%1 = spv.Variable : !spv.ptr&lt;!spv.struct&lt;f32, !spv.array&lt;4xf32&gt;&gt;, Function&gt;
%2 = spv.AccessChain %1[%0] : !spv.ptr&lt;!spv.struct&lt;f32, !spv.array&lt;4xf32&gt;&gt;, Function&gt;
%3 = spv.Load &quot;Function&quot; %2 [&quot;Volatile&quot;] : !spv.array&lt;4xf32&gt;
</code></pre><h4 id=operands>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>base_ptr</code></td><td>any SPIR-V pointer type</td></tr><tr><td align=center><code>indices</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>component_ptr</code></td><td>any SPIR-V pointer type</td></tr></tbody></table><h3 id=spv_address_of-spirvaddressofop><code>spv._address_of</code> (spirv::AddressOfOp)</h3><p>Get the address of a global variable.</p><p>Syntax:</p><pre><code>operation ::= `spv._address_of` $variable attr-dict `:` type($pointer)
</code></pre><p>Variables in module scope are defined using symbol names. This op generates
an SSA value that can be used to refer to the symbol within function scope
for use in ops that expect an SSA value. This operation has no corresponding
SPIR-V instruction; it&rsquo;s merely used for modelling purpose in the SPIR-V
dialect. Since variables in module scope in SPIR-V dialect are of pointer
type, this op returns a pointer type as well, and the type is the same as
the variable referenced.</p><h3 id=custom-assembly-form-1>Custom assembly form</h3><pre><code>spv-address-of-op ::= ssa-id `=` `spv._address_of` symbol-ref-id
                                 `:` spirv-pointer-type
</code></pre><p>For example:</p><pre><code>%0 = spv._address_of @global_var : !spv.ptr&lt;f32, Input&gt;
</code></pre><h4 id=attributes>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>variable</code></td><td align=center>FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr></tbody></table><h3 id=spvatomicand-spirvatomicandop><code>spv.AtomicAnd</code> (spirv::AtomicAndOp)</h3><pre><code>Perform the following steps atomically with respect to any other atomic
accesses within Scope to the same location:
</code></pre><ol><li><p>load through Pointer to get an Original Value,</p></li><li><p>get a New Value by the bitwise AND of Original Value and Value, and</p></li><li><p>store the New Value back through Pointer.</p></li></ol><p>The instruction’s result is the Original Value.</p><p>Result Type must be an integer type scalar.</p><p>The type of Value must be the same as Result Type. The type of the
value pointed to by Pointer must be the same as Result Type.</p><p>Memory must be a valid memory Scope.</p><h3 id=custom-assembly-form-2>Custom assembly form</h3><pre><code>scope ::= `&quot;CrossDevice&quot;` | `&quot;Device&quot;` | `&quot;Workgroup&quot;` | ...

memory-semantics ::= `&quot;None&quot;` | `&quot;Acquire&quot;` | &quot;Release&quot;` | ...

atomic-and-op ::=
    `spv.AtomicAnd` scope memory-semantics
                    ssa-use `,` ssa-use `:` spv-pointer-type
</code></pre><p>For example:</p><pre><code>%0 = spv.AtomicAnd &quot;Device&quot; &quot;None&quot; %pointer, %value :
                   !spv.ptr&lt;i32, StorageBuffer&gt;
</code></pre><h4 id=attributes-1>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>memory_scope</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V Scope</td></tr><tr><td align=center><code>semantics</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V MemorySemantics</td></tr></tbody></table><h4 id=operands-1>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr><tr><td align=center><code>value</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h3 id=spvatomiccompareexchangeweak-spirvatomiccompareexchangeweakop><code>spv.AtomicCompareExchangeWeak</code> (spirv::AtomicCompareExchangeWeakOp)</h3><p>Deprecated (use OpAtomicCompareExchange).</p><p>Has the same semantics as OpAtomicCompareExchange.</p><p>Memory must be a valid memory Scope.</p><h3 id=custom-assembly-form-3>Custom assembly form</h3><pre><code>atomic-compare-exchange-weak-op ::=
    `spv.AtomicCompareExchangeWeak` scope memory-semantics memory-semantics
                                    ssa-use `,` ssa-use `,` ssa-use
                                    `:` spv-pointer-type
</code></pre><p>For example:</p><pre><code>%0 = spv.AtomicCompareExchangeWeak &quot;Workgroup&quot; &quot;Acquire&quot; &quot;None&quot;
                                   %pointer, %value, %comparator
                                   : !spv.ptr&lt;i32, WorkGroup&gt;
</code></pre><h4 id=attributes-2>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>memory_scope</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V Scope</td></tr><tr><td align=center><code>equal_semantics</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V MemorySemantics</td></tr><tr><td align=center><code>unequal_semantics</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V MemorySemantics</td></tr></tbody></table><h4 id=operands-2>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr><tr><td align=center><code>value</code></td><td>8/16/32/64-bit integer</td></tr><tr><td align=center><code>comparator</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h3 id=spvatomiciadd-spirvatomiciaddop><code>spv.AtomicIAdd</code> (spirv::AtomicIAddOp)</h3><pre><code>Perform the following steps atomically with respect to any other atomic
accesses within Scope to the same location:
</code></pre><ol><li><p>load through Pointer to get an Original Value,</p></li><li><p>get a New Value by integer addition of Original Value and Value, and</p></li><li><p>store the New Value back through Pointer.</p></li></ol><p>The instruction’s result is the Original Value.</p><p>Result Type must be an integer type scalar.</p><p>The type of Value must be the same as Result Type. The type of the
value pointed to by Pointer must be the same as Result Type.</p><p>Memory must be a valid memory Scope.</p><h3 id=custom-assembly-form-4>Custom assembly form</h3><pre><code>atomic-iadd-op ::=
    `spv.AtomicIAdd` scope memory-semantics
                     ssa-use `,` ssa-use `:` spv-pointer-type
</code></pre><p>For example:</p><pre><code>%0 = spv.AtomicIAdd &quot;Device&quot; &quot;None&quot; %pointer, %value :
                    !spv.ptr&lt;i32, StorageBuffer&gt;
</code></pre><h4 id=attributes-3>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>memory_scope</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V Scope</td></tr><tr><td align=center><code>semantics</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V MemorySemantics</td></tr></tbody></table><h4 id=operands-3>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr><tr><td align=center><code>value</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h3 id=spvatomicidecrement-spirvatomicidecrementop><code>spv.AtomicIDecrement</code> (spirv::AtomicIDecrementOp)</h3><pre><code>Perform the following steps atomically with respect to any other atomic
accesses within Scope to the same location:
</code></pre><ol><li><p>load through Pointer to get an Original Value,</p></li><li><p>get a New Value through integer subtraction of 1 from Original Value,
and</p></li><li><p>store the New Value back through Pointer.</p></li></ol><p>The instruction’s result is the Original Value.</p><p>Result Type must be an integer type scalar. The type of the value
pointed to by Pointer must be the same as Result Type.</p><p>Memory must be a valid memory Scope.</p><h3 id=custom-assembly-form-5>Custom assembly form</h3><pre><code>atomic-idecrement-op ::=
    `spv.AtomicIDecrement` scope memory-semantics ssa-use
                           `:` spv-pointer-type
</code></pre><p>For example:</p><pre><code>%0 = spv.AtomicIDecrement &quot;Device&quot; &quot;None&quot; %pointer :
                          !spv.ptr&lt;i32, StorageBuffer&gt;
</code></pre><h4 id=attributes-4>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>memory_scope</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V Scope</td></tr><tr><td align=center><code>semantics</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V MemorySemantics</td></tr></tbody></table><h4 id=operands-4>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h3 id=spvatomiciincrement-spirvatomiciincrementop><code>spv.AtomicIIncrement</code> (spirv::AtomicIIncrementOp)</h3><pre><code>Perform the following steps atomically with respect to any other atomic
accesses within Scope to the same location:
</code></pre><ol><li><p>load through Pointer to get an Original Value,</p></li><li><p>get a New Value through integer addition of 1 to Original Value, and</p></li><li><p>store the New Value back through Pointer.</p></li></ol><p>The instruction’s result is the Original Value.</p><p>Result Type must be an integer type scalar. The type of the value
pointed to by Pointer must be the same as Result Type.</p><p>Memory must be a valid memory Scope.</p><h3 id=custom-assembly-form-6>Custom assembly form</h3><pre><code>atomic-iincrement-op ::=
    `spv.AtomicIIncrement` scope memory-semantics ssa-use
                           `:` spv-pointer-type
</code></pre><p>For example:</p><pre><code>%0 = spv.AtomicIncrement &quot;Device&quot; &quot;None&quot; %pointer :
                         !spv.ptr&lt;i32, StorageBuffer&gt;
</code></pre><h4 id=attributes-5>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>memory_scope</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V Scope</td></tr><tr><td align=center><code>semantics</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V MemorySemantics</td></tr></tbody></table><h4 id=operands-5>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h3 id=spvatomicisub-spirvatomicisubop><code>spv.AtomicISub</code> (spirv::AtomicISubOp)</h3><pre><code>Perform the following steps atomically with respect to any other atomic
accesses within Scope to the same location:
</code></pre><ol><li><p>load through Pointer to get an Original Value,</p></li><li><p>get a New Value by integer subtraction of Value from Original Value,
and</p></li><li><p>store the New Value back through Pointer.</p></li></ol><p>The instruction’s result is the Original Value.</p><p>Result Type must be an integer type scalar.</p><p>The type of Value must be the same as Result Type. The type of the
value pointed to by Pointer must be the same as Result Type.</p><p>Memory must be a valid memory Scope.</p><h3 id=custom-assembly-form-7>Custom assembly form</h3><pre><code>atomic-isub-op ::=
    `spv.AtomicISub` scope memory-semantics
                     ssa-use `,` ssa-use `:` spv-pointer-type
</code></pre><p>For example:</p><pre><code>%0 = spv.AtomicISub &quot;Device&quot; &quot;None&quot; %pointer, %value :
                    !spv.ptr&lt;i32, StorageBuffer&gt;
</code></pre><h4 id=attributes-6>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>memory_scope</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V Scope</td></tr><tr><td align=center><code>semantics</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V MemorySemantics</td></tr></tbody></table><h4 id=operands-6>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr><tr><td align=center><code>value</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h3 id=spvatomicor-spirvatomicorop><code>spv.AtomicOr</code> (spirv::AtomicOrOp)</h3><pre><code>Perform the following steps atomically with respect to any other atomic
accesses within Scope to the same location:
</code></pre><ol><li><p>load through Pointer to get an Original Value,</p></li><li><p>get a New Value by the bitwise OR of Original Value and Value, and</p></li><li><p>store the New Value back through Pointer.</p></li></ol><p>The instruction’s result is the Original Value.</p><p>Result Type must be an integer type scalar.</p><p>The type of Value must be the same as Result Type. The type of the
value pointed to by Pointer must be the same as Result Type.</p><p>Memory must be a valid memory Scope.</p><h3 id=custom-assembly-form-8>Custom assembly form</h3><pre><code>atomic-or-op ::=
    `spv.AtomicOr` scope memory-semantics
                   ssa-use `,` ssa-use `:` spv-pointer-type
</code></pre><p>For example:</p><pre><code>%0 = spv.AtomicOr &quot;Device&quot; &quot;None&quot; %pointer, %value :
                  !spv.ptr&lt;i32, StorageBuffer&gt;
</code></pre><h4 id=attributes-7>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>memory_scope</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V Scope</td></tr><tr><td align=center><code>semantics</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V MemorySemantics</td></tr></tbody></table><h4 id=operands-7>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr><tr><td align=center><code>value</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-8>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h3 id=spvatomicsmax-spirvatomicsmaxop><code>spv.AtomicSMax</code> (spirv::AtomicSMaxOp)</h3><pre><code>Perform the following steps atomically with respect to any other atomic
accesses within Scope to the same location:
</code></pre><ol><li><p>load through Pointer to get an Original Value,</p></li><li><p>get a New Value by finding the largest signed integer of Original
Value and Value, and</p></li><li><p>store the New Value back through Pointer.</p></li></ol><p>The instruction’s result is the Original Value.</p><p>Result Type must be an integer type scalar.</p><p>The type of Value must be the same as Result Type. The type of the
value pointed to by Pointer must be the same as Result Type.</p><p>Memory must be a valid memory Scope.</p><h3 id=custom-assembly-form-9>Custom assembly form</h3><pre><code>atomic-smax-op ::=
    `spv.AtomicSMax` scope memory-semantics
                     ssa-use `,` ssa-use `:` spv-pointer-type
</code></pre><p>For example:</p><pre><code>%0 = spv.AtomicSMax &quot;Device&quot; &quot;None&quot; %pointer, %value :
                    !spv.ptr&lt;i32, StorageBuffer&gt;
</code></pre><h4 id=attributes-8>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>memory_scope</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V Scope</td></tr><tr><td align=center><code>semantics</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V MemorySemantics</td></tr></tbody></table><h4 id=operands-8>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr><tr><td align=center><code>value</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-9>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h3 id=spvatomicsmin-spirvatomicsminop><code>spv.AtomicSMin</code> (spirv::AtomicSMinOp)</h3><pre><code>Perform the following steps atomically with respect to any other atomic
accesses within Scope to the same location:
</code></pre><ol><li><p>load through Pointer to get an Original Value,</p></li><li><p>get a New Value by finding the smallest signed integer of Original
Value and Value, and</p></li><li><p>store the New Value back through Pointer.</p></li></ol><p>The instruction’s result is the Original Value.</p><p>Result Type must be an integer type scalar.</p><p>The type of Value must be the same as Result Type. The type of the
value pointed to by Pointer must be the same as Result Type.</p><p>Memory must be a valid memory Scope.</p><h3 id=custom-assembly-form-10>Custom assembly form</h3><pre><code>atomic-smin-op ::=
    `spv.AtomicSMin` scope memory-semantics
                     ssa-use `,` ssa-use `:` spv-pointer-type
</code></pre><p>For example:</p><pre><code>%0 = spv.AtomicSMin &quot;Device&quot; &quot;None&quot; %pointer, %value :
                    !spv.ptr&lt;i32, StorageBuffer&gt;
</code></pre><h4 id=attributes-9>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>memory_scope</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V Scope</td></tr><tr><td align=center><code>semantics</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V MemorySemantics</td></tr></tbody></table><h4 id=operands-9>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr><tr><td align=center><code>value</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-10>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h3 id=spvatomicumax-spirvatomicumaxop><code>spv.AtomicUMax</code> (spirv::AtomicUMaxOp)</h3><pre><code>Perform the following steps atomically with respect to any other atomic
accesses within Scope to the same location:
</code></pre><ol><li><p>load through Pointer to get an Original Value,</p></li><li><p>get a New Value by finding the largest unsigned integer of Original
Value and Value, and</p></li><li><p>store the New Value back through Pointer.</p></li></ol><p>The instruction’s result is the Original Value.</p><p>Result Type must be an integer type scalar.</p><p>The type of Value must be the same as Result Type. The type of the
value pointed to by Pointer must be the same as Result Type.</p><p>Memory must be a valid memory Scope.</p><h3 id=custom-assembly-form-11>Custom assembly form</h3><pre><code>atomic-umax-op ::=
    `spv.AtomicUMax` scope memory-semantics
                     ssa-use `,` ssa-use `:` spv-pointer-type
</code></pre><p>For example:</p><pre><code>%0 = spv.AtomicUMax &quot;Device&quot; &quot;None&quot; %pointer, %value :
                    !spv.ptr&lt;i32, StorageBuffer&gt;
</code></pre><h4 id=attributes-10>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>memory_scope</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V Scope</td></tr><tr><td align=center><code>semantics</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V MemorySemantics</td></tr></tbody></table><h4 id=operands-10>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr><tr><td align=center><code>value</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-11>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h3 id=spvatomicumin-spirvatomicuminop><code>spv.AtomicUMin</code> (spirv::AtomicUMinOp)</h3><pre><code>Perform the following steps atomically with respect to any other atomic
accesses within Scope to the same location:
</code></pre><ol><li><p>load through Pointer to get an Original Value,</p></li><li><p>get a New Value by finding the smallest unsigned integer of Original
Value and Value, and</p></li><li><p>store the New Value back through Pointer.</p></li></ol><p>The instruction’s result is the Original Value.</p><p>Result Type must be an integer type scalar.</p><p>The type of Value must be the same as Result Type. The type of the
value pointed to by Pointer must be the same as Result Type.</p><p>Memory must be a valid memory Scope.</p><h3 id=custom-assembly-form-12>Custom assembly form</h3><pre><code>atomic-umin-op ::=
    `spv.AtomicUMin` scope memory-semantics
                     ssa-use `,` ssa-use `:` spv-pointer-type
</code></pre><p>For example:</p><pre><code>%0 = spv.AtomicUMin &quot;Device&quot; &quot;None&quot; %pointer, %value :
                    !spv.ptr&lt;i32, StorageBuffer&gt;
</code></pre><h4 id=attributes-11>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>memory_scope</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V Scope</td></tr><tr><td align=center><code>semantics</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V MemorySemantics</td></tr></tbody></table><h4 id=operands-11>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr><tr><td align=center><code>value</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-12>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h3 id=spvatomicxor-spirvatomicxorop><code>spv.AtomicXor</code> (spirv::AtomicXorOp)</h3><pre><code>Perform the following steps atomically with respect to any other atomic
accesses within Scope to the same location:
</code></pre><ol><li><p>load through Pointer to get an Original Value,</p></li><li><p>get a New Value by the bitwise exclusive OR of Original Value and
Value, and</p></li><li><p>store the New Value back through Pointer.</p></li></ol><p>The instruction’s result is the Original Value.</p><p>Result Type must be an integer type scalar.</p><p>The type of Value must be the same as Result Type. The type of the
value pointed to by Pointer must be the same as Result Type.</p><p>Memory must be a valid memory Scope.</p><h3 id=custom-assembly-form-13>Custom assembly form</h3><pre><code>atomic-xor-op ::=
    `spv.AtomicXor` scope memory-semantics
                    ssa-use `,` ssa-use `:` spv-pointer-type
</code></pre><p>For example:</p><pre><code>%0 = spv.AtomicXor &quot;Device&quot; &quot;None&quot; %pointer, %value :
                   !spv.ptr&lt;i32, StorageBuffer&gt;
</code></pre><h4 id=attributes-12>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>memory_scope</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V Scope</td></tr><tr><td align=center><code>semantics</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V MemorySemantics</td></tr></tbody></table><h4 id=operands-12>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr><tr><td align=center><code>value</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-13>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h3 id=spvbitcount-spirvbitcountop><code>spv.BitCount</code> (spirv::BitCountOp)</h3><p>Count the number of set bits in an object.</p><p>Results are computed per component.</p><p>Result Type must be a scalar or vector of integer type. The components
must be wide enough to hold the unsigned Width of Base as an unsigned
value. That is, no sign bit is needed or counted when checking for a
wide enough result width.</p><p>Base must be a scalar or vector of integer type. It must have the same
number of components as Result Type.</p><p>The result is the unsigned value that is the number of bits in Base that
are 1.</p><h3 id=custom-assembly-form-14>Custom assembly form</h3><pre><code>integer-scalar-vector-type ::= integer-type |
                              `vector&lt;` integer-literal `x` integer-type `&gt;`
bitcount-op ::= ssa-id `=` `spv.BitCount` ssa-use
                           `:` integer-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%2 = spv.BitCount %0: i32
%3 = spv.BitCount %1: vector&lt;4xi32&gt;
</code></pre><h4 id=operands-13>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h4 id=results-14>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h3 id=spvbitfieldinsert-spirvbitfieldinsertop><code>spv.BitFieldInsert</code> (spirv::BitFieldInsertOp)</h3><pre><code>Make a copy of an object, with a modified bit field that comes from
another object.
</code></pre><p>Syntax:</p><pre><code>operation ::= `spv.BitFieldInsert` operands attr-dict `:` type($base) `,` type($offset) `,` type($count)
</code></pre><p>Results are computed per component.</p><p>Result Type must be a scalar or vector of integer type.</p><p>The type of Base and Insert must be the same as Result Type.</p><p>Any result bits numbered outside [Offset, Offset + Count - 1]
(inclusive) will come from the corresponding bits in Base.</p><p>Any result bits numbered in [Offset, Offset + Count - 1] come, in
order, from the bits numbered [0, Count - 1] of Insert.</p><p>Count must be an integer type scalar. Count is the number of bits taken
from Insert. It will be consumed as an unsigned value. Count can be 0,
in which case the result will be Base.</p><p>Offset must be an integer type scalar. Offset is the lowest-order bit
of the bit field. It will be consumed as an unsigned value.</p><p>The resulting value is undefined if Count or Offset or their sum is
greater than the number of bits in the result.</p><h3 id=custom-assembly-form-15>Custom assembly form</h3><pre><code>integer-scalar-vector-type ::= integer-type |
                              `vector&lt;` integer-literal `x` integer-type `&gt;`
bitfield-insert-op ::= ssa-id `=` `spv.BitFieldInsert` ssa-use `,` ssa-use
                                  `,` ssa-use `,` ssa-use
                                  `:` integer-scalar-vector-type
                                  `,` integer-type `,` integer-type
</code></pre><p>For example:</p><pre><code>%0 = spv.BitFieldInsert %base, %insert, %offset, %count : vector&lt;3xi32&gt;, i8, i8
</code></pre><h4 id=operands-14>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>base</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr><tr><td align=center><code>insert</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr><tr><td align=center><code>offset</code></td><td>8/16/32/64-bit integer</td></tr><tr><td align=center><code>count</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-15>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h3 id=spvbitfieldsextract-spirvbitfieldsextractop><code>spv.BitFieldSExtract</code> (spirv::BitFieldSExtractOp)</h3><p>Extract a bit field from an object, with sign extension.</p><p>Syntax:</p><pre><code>operation ::= `spv.BitFieldSExtract` operands attr-dict `:` type($base) `,` type($offset) `,` type($count)
</code></pre><p>Results are computed per component.</p><p>Result Type must be a scalar or vector of integer type.</p><p>The type of Base must be the same as Result Type.</p><p>If Count is greater than 0: The bits of Base numbered in [Offset, Offset</p><ul><li>Count - 1] (inclusive) become the bits numbered [0, Count - 1] of the
result. The remaining bits of the result will all be the same as bit
Offset + Count - 1 of Base.</li></ul><p>Count must be an integer type scalar. Count is the number of bits
extracted from Base. It will be consumed as an unsigned value. Count can
be 0, in which case the result will be 0.</p><p>Offset must be an integer type scalar. Offset is the lowest-order bit
of the bit field to extract from Base. It will be consumed as an
unsigned value.</p><p>The resulting value is undefined if Count or Offset or their sum is
greater than the number of bits in the result.</p><h3 id=custom-assembly-form-16>Custom assembly form</h3><pre><code>integer-scalar-vector-type ::= integer-type |
                              `vector&lt;` integer-literal `x` integer-type `&gt;`
bitfield-extract-s-op ::= ssa-id `=` `spv.BitFieldSExtract` ssa-use
                                     `,` ssa-use `,` ssa-use
                                     `:` integer-scalar-vector-type
                                     `,` integer-type `,` integer-type
</code></pre><p>For example:</p><pre><code>%0 = spv.BitFieldSExtract %base, %offset, %count : vector&lt;3xi32&gt;, i8, i8
</code></pre><h4 id=operands-15>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>base</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr><tr><td align=center><code>offset</code></td><td>8/16/32/64-bit integer</td></tr><tr><td align=center><code>count</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-16>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h3 id=spvbitfielduextract-spirvbitfielduextractop><code>spv.BitFieldUExtract</code> (spirv::BitFieldUExtractOp)</h3><p>Extract a bit field from an object, without sign extension.</p><p>Syntax:</p><pre><code>operation ::= `spv.BitFieldUExtract` operands attr-dict `:` type($base) `,` type($offset) `,` type($count)
</code></pre><p>The semantics are the same as with OpBitFieldSExtract with the exception
that there is no sign extension. The remaining bits of the result will
all be 0.</p><h3 id=custom-assembly-form-17>Custom assembly form</h3><pre><code>integer-scalar-vector-type ::= integer-type |
                              `vector&lt;` integer-literal `x` integer-type `&gt;`
bitfield-extract-u-op ::= ssa-id `=` `spv.BitFieldUExtract` ssa-use
                                     `,` ssa-use `,` ssa-use
                                     `:` integer-scalar-vector-type
                                     `,` integer-type `,` integer-type
</code></pre><p>For example:</p><pre><code>%0 = spv.BitFieldUExtract %base, %offset, %count : vector&lt;3xi32&gt;, i8, i8
</code></pre><h4 id=operands-16>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>base</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr><tr><td align=center><code>offset</code></td><td>8/16/32/64-bit integer</td></tr><tr><td align=center><code>count</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-17>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h3 id=spvbitreverse-spirvbitreverseop><code>spv.BitReverse</code> (spirv::BitReverseOp)</h3><p>Reverse the bits in an object.</p><p>Results are computed per component.</p><p>Result Type must be a scalar or vector of integer type.</p><p>The type of Base must be the same as Result Type.</p><p>The bit-number n of the result will be taken from bit-number Width - 1 -
n of Base, where Width is the OpTypeInt operand of the Result Type.</p><h3 id=custom-assembly-form-18>Custom assembly form</h3><pre><code>integer-scalar-vector-type ::= integer-type |
                               `vector&lt;` integer-literal `x` integer-type `&gt;`
bitreverse-op ::= ssa-id `=` `spv.BitReverse` ssa-use
                             `:` integer-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%2 = spv.BitReverse %0 : i32
%3 = spv.BitReverse %1 : vector&lt;4xi32&gt;
</code></pre><h4 id=operands-17>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h4 id=results-18>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h3 id=spvbitcast-spirvbitcastop><code>spv.Bitcast</code> (spirv::BitcastOp)</h3><p>Bit pattern-preserving type conversion.</p><p>Result Type must be an OpTypePointer, or a scalar or vector of
numerical-type.</p><p>Operand must have a type of OpTypePointer, or a scalar or vector of
numerical-type. It must be a different type than Result Type.</p><p>If either Result Type or Operand is a pointer, the other must be a
pointer (diverges from the SPIR-V spec).</p><p>If Result Type has a different number of components than Operand, the
total number of bits in Result Type must equal the total number of bits
in Operand. Let L be the type, either Result Type or Operand’s type,
that has the larger number of components. Let S be the other type, with
the smaller number of components. The number of components in L must be
an integer multiple of the number of components in S. The first
component (that is, the only or lowest-numbered component) of S maps to
the first components of L, and so on, up to the last component of S
mapping to the last components of L. Within this mapping, any single
component of S (mapping to multiple components of L) maps its lower-
ordered bits to the lower-numbered components of L.</p><h3 id=custom-assembly-form-19>Custom assembly form</h3><pre><code>bitcast-op ::= ssa-id `=` `spv.Bitcast` ssa-use
               `:` operand-type `to` result-type
</code></pre><p>For example:</p><pre><code>%1 = spv.Bitcast %0 : f32 to i32
%1 = spv.Bitcast %0 : vector&lt;2xf32&gt; to i64
%1 = spv.Bitcast %0 : !spv.ptr&lt;f32, Function&gt; to !spv.ptr&lt;i32, Function&gt;
</code></pre><h4 id=operands-18>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>8/16/32/64-bit integer or 16/32/64-bit float or bool or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float values of length 2/3/4 or any SPIR-V pointer type</td></tr></tbody></table><h4 id=results-19>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer or 16/32/64-bit float or bool or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float values of length 2/3/4 or any SPIR-V pointer type</td></tr></tbody></table><h3 id=spvbitwiseand-spirvbitwiseandop><code>spv.BitwiseAnd</code> (spirv::BitwiseAndOp)</h3><pre><code>Result is 1 if both Operand 1 and Operand 2 are 1. Result is 0 if either
Operand 1 or Operand 2 are 0.
</code></pre><p>Results are computed per component, and within each component, per bit.</p><p>Result Type must be a scalar or vector of integer type. The type of
Operand 1 and Operand 2 must be a scalar or vector of integer type.
They must have the same number of components as Result Type. They must
have the same component width as Result Type.</p><h3 id=custom-assembly-form-20>Custom assembly form</h3><pre><code>integer-scalar-vector-type ::= integer-type |
                              `vector&lt;` integer-literal `x` integer-type `&gt;`
bitwise-and-op ::= ssa-id `=` `spv.BitwiseAnd` ssa-use, ssa-use
                              `:` integer-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%2 = spv.BitwiseAnd %0, %1 : i32
%2 = spv.BitwiseAnd %0, %1 : vector&lt;4xi32&gt;
</code></pre><h4 id=operands-19>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h4 id=results-20>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h3 id=spvbitwiseor-spirvbitwiseorop><code>spv.BitwiseOr</code> (spirv::BitwiseOrOp)</h3><pre><code>Result is 1 if either Operand 1 or Operand 2 is 1. Result is 0 if both
Operand 1 and Operand 2 are 0.
</code></pre><p>Results are computed per component, and within each component, per bit.</p><p>Result Type must be a scalar or vector of integer type. The type of
Operand 1 and Operand 2 must be a scalar or vector of integer type.
They must have the same number of components as Result Type. They must
have the same component width as Result Type.</p><h3 id=custom-assembly-form-21>Custom assembly form</h3><pre><code>integer-scalar-vector-type ::= integer-type |
                              `vector&lt;` integer-literal `x` integer-type `&gt;`
bitwise-or-op ::= ssa-id `=` `spv.BitwiseOr` ssa-use, ssa-use
                              `:` integer-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%2 = spv.BitwiseOr %0, %1 : i32
%2 = spv.BitwiseOr %0, %1 : vector&lt;4xi32&gt;
</code></pre><h4 id=operands-20>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h4 id=results-21>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h3 id=spvbitwisexor-spirvbitwisexorop><code>spv.BitwiseXor</code> (spirv::BitwiseXorOp)</h3><pre><code>Result is 1 if exactly one of Operand 1 or Operand 2 is 1. Result is 0
if Operand 1 and Operand 2 have the same value.
</code></pre><p>Results are computed per component, and within each component, per bit.</p><p>Result Type must be a scalar or vector of integer type. The type of
Operand 1 and Operand 2 must be a scalar or vector of integer type.
They must have the same number of components as Result Type. They must
have the same component width as Result Type.</p><h3 id=custom-assembly-form-22>Custom assembly form</h3><pre><code>integer-scalar-vector-type ::= integer-type |
                              `vector&lt;` integer-literal `x` integer-type `&gt;`
bitwise-xor-op ::= ssa-id `=` `spv.BitwiseXor` ssa-use, ssa-use
                              `:` integer-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%2 = spv.BitwiseXor %0, %1 : i32
%2 = spv.BitwiseXor %0, %1 : vector&lt;4xi32&gt;
</code></pre><h4 id=operands-21>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h4 id=results-22>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h3 id=spvbranchconditional-spirvbranchconditionalop><code>spv.BranchConditional</code> (spirv::BranchConditionalOp)</h3><pre><code>If Condition is true, branch to true block, otherwise branch to false
block.
</code></pre><p>Condition must be a Boolean type scalar.</p><p>Branch weights are unsigned 32-bit integer literals. There must be
either no Branch Weights or exactly two branch weights. If present, the
first is the weight for branching to True Label, and the second is the
weight for branching to False Label. The implied probability that a
branch is taken is its weight divided by the sum of the two Branch
weights. At least one weight must be non-zero. A weight of zero does not
imply a branch is dead or permit its removal; branch weights are only
hints. The two weights must not overflow a 32-bit unsigned integer when
added together.</p><p>This instruction must be the last instruction in a block.</p><h3 id=custom-assembly-form-23>Custom assembly form</h3><pre><code>branch-conditional-op ::= `spv.BranchConditional` ssa-use
                          (`[` integer-literal, integer-literal `]`)?
                          `,` successor `,` successor
successor ::= bb-id branch-use-list?
branch-use-list ::= `(` ssa-use-list `:` type-list-no-parens `)`
</code></pre><p>For example:</p><pre><code>spv.BranchConditional %condition, ^true_branch, ^false_branch
spv.BranchConditional %condition, ^true_branch(%0: i32), ^false_branch(%1: i32)
</code></pre><h4 id=attributes-13>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>branch_weights</code></td><td align=center>ArrayAttr</td><td>32-bit integer array attribute</td></tr></tbody></table><h4 id=operands-22>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>condition</code></td><td>bool</td></tr><tr><td align=center><code>trueTargetOperands</code></td><td>void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float values of length 2/3/4 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type</td></tr><tr><td align=center><code>falseTargetOperands</code></td><td>void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float values of length 2/3/4 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type</td></tr></tbody></table><h4 id=successors>Successors:</h4><table><thead><tr><th align=center>Successor</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>trueTarget</code></td><td>any successor</td></tr><tr><td align=center><code>falseTarget</code></td><td>any successor</td></tr></tbody></table><h3 id=spvbranch-spirvbranchop><code>spv.Branch</code> (spirv::BranchOp)</h3><p>Unconditional branch to target block.</p><p>Syntax:</p><pre><code>operation ::= `spv.Branch` $target (`(` $targetOperands^ `:` type($targetOperands) `)`)? attr-dict
</code></pre><p>This instruction must be the last instruction in a block.</p><h3 id=custom-assembly-form-24>Custom assembly form</h3><pre><code>branch-op ::= `spv.Branch` successor
successor ::= bb-id branch-use-list?
branch-use-list ::= `(` ssa-use-list `:` type-list-no-parens `)`
</code></pre><p>For example:</p><pre><code>spv.Branch ^target
spv.Branch ^target(%0, %1: i32, f32)
</code></pre><h4 id=operands-23>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>targetOperands</code></td><td>void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float values of length 2/3/4 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type</td></tr></tbody></table><h4 id=successors-1>Successors:</h4><table><thead><tr><th align=center>Successor</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>target</code></td><td>any successor</td></tr></tbody></table><h3 id=spvcompositeconstruct-spirvcompositeconstructop><code>spv.CompositeConstruct</code> (spirv::CompositeConstructOp)</h3><pre><code>Construct a new composite object from a set of constituent objects that
will fully form it.
</code></pre><p>Result Type must be a composite type, whose top-level
members/elements/components/columns have the same type as the types of
the operands, with one exception. The exception is that for constructing
a vector, the operands may also be vectors with the same component type
as the Result Type component type. When constructing a vector, the total
number of components in all the operands must equal the number of
components in Result Type.</p><p>Constituents will become members of a structure, or elements of an
array, or components of a vector, or columns of a matrix. There must be
exactly one Constituent for each top-level
member/element/component/column of the result, with one exception. The
exception is that for constructing a vector, a contiguous subset of the
scalars consumed can be represented by a vector operand instead. The
Constituents must appear in the order needed by the definition of the
type of the result. When constructing a vector, there must be at least
two Constituent operands.</p><h3 id=custom-assembly-form-25>Custom assembly form</h3><pre><code>composite-construct-op ::= ssa-id `=` `spv.CompositeConstruct`
                           (ssa-use (`,` ssa-use)* )? `:` composite-type
</code></pre><p>For example:</p><pre><code>%0 = spv.CompositeConstruct %1, %2, %3 : vector&lt;3xf32&gt;
</code></pre><h4 id=operands-24>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>constituents</code></td><td>void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float values of length 2/3/4 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type</td></tr></tbody></table><h4 id=results-23>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float values of length 2/3/4 or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type</td></tr></tbody></table><h3 id=spvcompositeextract-spirvcompositeextractop><code>spv.CompositeExtract</code> (spirv::CompositeExtractOp)</h3><p>Extract a part of a composite object.</p><p>Result Type must be the type of object selected by the last provided
index. The instruction result is the extracted object.</p><p>Composite is the composite to extract from.</p><p>Indexes walk the type hierarchy, potentially down to component
granularity, to select the part to extract. All indexes must be in
bounds. All composite constituents use zero-based numbering, as
described by their OpType… instruction.</p><h3 id=custom-assembly-form-26>Custom assembly form</h3><pre><code>composite-extract-op ::= ssa-id `=` `spv.CompositeExtract` ssa-use
                         `[` integer-literal (',' integer-literal)* `]`
                         `:` composite-type
</code></pre><p>For example:</p><pre><code>%0 = spv.Variable : !spv.ptr&lt;!spv.array&lt;4x!spv.array&lt;4xf32&gt;&gt;, Function&gt;
%1 = spv.Load &quot;Function&quot; %0 [&quot;Volatile&quot;] : !spv.array&lt;4x!spv.array&lt;4xf32&gt;&gt;
%2 = spv.CompositeExtract %1[1 : i32] : !spv.array&lt;4x!spv.array&lt;4xf32&gt;&gt;
</code></pre><h4 id=attributes-14>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>indices</code></td><td align=center>ArrayAttr</td><td>32-bit integer array attribute</td></tr></tbody></table><h4 id=operands-25>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>composite</code></td><td>vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float values of length 2/3/4 or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type</td></tr></tbody></table><h4 id=results-24>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>component</code></td><td>void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float values of length 2/3/4 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type</td></tr></tbody></table><h3 id=spvcompositeinsert-spirvcompositeinsertop><code>spv.CompositeInsert</code> (spirv::CompositeInsertOp)</h3><pre><code>Make a copy of a composite object, while modifying one part of it.
</code></pre><p>Result Type must be the same type as Composite.</p><p>Object is the object to use as the modified part.</p><p>Composite is the composite to copy all but the modified part from.</p><p>Indexes walk the type hierarchy of Composite to the desired depth,
potentially down to component granularity, to select the part to modify.
All indexes must be in bounds. All composite constituents use zero-based
numbering, as described by their OpType… instruction. The type of the
part selected to modify must match the type of Object.</p><h3 id=custom-assembly-form-27>Custom assembly form</h3><pre><code>composite-insert-op ::= ssa-id `=` `spv.CompositeInsert` ssa-use, ssa-use
                        `[` integer-literal (',' integer-literal)* `]`
                        `:` object-type `into` composite-type
</code></pre><p>For example:</p><pre><code>%0 = spv.CompositeInsert %object, %composite[1 : i32] : f32 into !spv.array&lt;4xf32&gt;
</code></pre><h4 id=attributes-15>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>indices</code></td><td align=center>ArrayAttr</td><td>32-bit integer array attribute</td></tr></tbody></table><h4 id=operands-26>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>object</code></td><td>void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float values of length 2/3/4 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type</td></tr><tr><td align=center><code>composite</code></td><td>vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float values of length 2/3/4 or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type</td></tr></tbody></table><h4 id=results-25>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float values of length 2/3/4 or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type</td></tr></tbody></table><h3 id=spvconstant-spirvconstantop><code>spv.constant</code> (spirv::ConstantOp)</h3><p>The op that declares a SPIR-V normal constant</p><p>This op declares a SPIR-V normal constant. SPIR-V has multiple constant
instructions covering different constant types:</p><ul><li><code>OpConstantTrue</code> and <code>OpConstantFalse</code> for boolean constants</li><li><code>OpConstant</code> for scalar constants</li><li><code>OpConstantComposite</code> for composite constants</li><li><code>OpConstantNull</code> for null constants</li><li>&mldr;</li></ul><p>Having such a plethora of constant instructions renders IR transformations
more tedious. Therefore, we use a single <code>spv.constant</code> op to represent
them all. Note that conversion between those SPIR-V constant instructions
and this op is purely mechanical; so it can be scoped to the binary
(de)serialization process.</p><h3 id=custom-assembly-form-28>Custom assembly form</h3><pre><code>spv-constant-op ::= ssa-id `=` `spv.constant` attribute-value
                    (`:` spirv-type)?
</code></pre><p>For example:</p><pre><code>%0 = spv.constant true
%1 = spv.constant dense&lt;[2, 3]&gt; : vector&lt;2xf32&gt;
%2 = spv.constant [dense&lt;3.0&gt; : vector&lt;2xf32&gt;] : !spv.array&lt;1xvector&lt;2xf32&gt;&gt;
</code></pre><p>TODO(antiagainst): support constant structs</p><h4 id=attributes-16>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td align=center>Attribute</td><td>any attribute</td></tr></tbody></table><h4 id=results-26>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>constant</code></td><td>void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float values of length 2/3/4 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type</td></tr></tbody></table><h3 id=spvcontrolbarrier-spirvcontrolbarrierop><code>spv.ControlBarrier</code> (spirv::ControlBarrierOp)</h3><pre><code>Wait for other invocations of this module to reach the current point of
execution.
</code></pre><p>Syntax:</p><pre><code>operation ::= `spv.ControlBarrier` $execution_scope `,` $memory_scope `,` $memory_semantics attr-dict
</code></pre><p>All invocations of this module within Execution scope must reach this
point of execution before any invocation will proceed beyond it.</p><p>When Execution is Workgroup or larger, behavior is undefined if this
instruction is used in control flow that is non-uniform within
Execution. When Execution is Subgroup or Invocation, the behavior of
this instruction in non-uniform control flow is defined by the client
API.</p><p>If Semantics is not None, this instruction also serves as an
OpMemoryBarrier instruction, and must also perform and adhere to the
description and semantics of an OpMemoryBarrier instruction with the
same Memory and Semantics operands. This allows atomically specifying
both a control barrier and a memory barrier (that is, without needing
two instructions). If Semantics is None, Memory is ignored.</p><p>Before version 1.3, it is only valid to use this instruction with
TessellationControl, GLCompute, or Kernel execution models. There is no
such restriction starting with version 1.3.</p><p>When used with the TessellationControl execution model, it also
implicitly synchronizes the Output Storage Class: Writes to Output
variables performed by any invocation executed prior to a
OpControlBarrier will be visible to any other invocation after return
from that OpControlBarrier.</p><h3 id=custom-assembly-form-29>Custom assembly form</h3><pre><code>scope ::= `&quot;CrossDevice&quot;` | `&quot;Device&quot;` | `&quot;Workgroup&quot;` | ...

memory-semantics ::= `&quot;None&quot;` | `&quot;Acquire&quot;` | &quot;Release&quot;` | ...

control-barrier-op ::= `spv.ControlBarrier` scope, scope, memory-semantics
</code></pre><p>For example:</p><pre><code>spv.ControlBarrier &quot;Workgroup&quot;, &quot;Device&quot;, &quot;Acquire|UniformMemory&quot;

</code></pre><h4 id=attributes-17>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>execution_scope</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V Scope</td></tr><tr><td align=center><code>memory_scope</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V Scope</td></tr><tr><td align=center><code>memory_semantics</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V MemorySemantics</td></tr></tbody></table><h3 id=spvconvertftos-spirvconvertftosop><code>spv.ConvertFToS</code> (spirv::ConvertFToSOp)</h3><pre><code>Convert value numerically from floating point to signed integer, with
round toward 0.0.
</code></pre><p>Result Type must be a scalar or vector of integer type.</p><p>Float Value must be a scalar or vector of floating-point type. It must
have the same number of components as Result Type.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-30>Custom assembly form</h3><pre><code>convert-f-to-s-op ::= ssa-id `=` `spv.ConvertFToSOp` ssa-use
                      `:` operand-type `to` result-type
</code></pre><p>For example:</p><pre><code>%1 = spv.ConvertFToS %0 : f32 to i32
%3 = spv.ConvertFToS %2 : vector&lt;3xf32&gt; to vector&lt;3xi32&gt;
</code></pre><h4 id=operands-27>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h4 id=results-27>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h3 id=spvconvertftou-spirvconvertftouop><code>spv.ConvertFToU</code> (spirv::ConvertFToUOp)</h3><pre><code>Convert value numerically from floating point to unsigned integer, with
round toward 0.0.
</code></pre><p>Result Type must be a scalar or vector of integer type, whose Signedness
operand is 0.</p><p>Float Value must be a scalar or vector of floating-point type. It must
have the same number of components as Result Type.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-31>Custom assembly form</h3><pre><code>convert-f-to-u-op ::= ssa-id `=` `spv.ConvertFToUOp` ssa-use
                      `:` operand-type `to` result-type
</code></pre><p>For example:</p><pre><code>%1 = spv.ConvertFToU %0 : f32 to i32
%3 = spv.ConvertFToU %2 : vector&lt;3xf32&gt; to vector&lt;3xi32&gt;
</code></pre><h4 id=operands-28>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h4 id=results-28>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h3 id=spvconvertstof-spirvconvertstofop><code>spv.ConvertSToF</code> (spirv::ConvertSToFOp)</h3><pre><code>Convert value numerically from signed integer to floating point.
</code></pre><p>Result Type must be a scalar or vector of floating-point type.</p><p>Signed Value must be a scalar or vector of integer type. It must have
the same number of components as Result Type.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-32>Custom assembly form</h3><pre><code>convert-s-to-f-op ::= ssa-id `=` `spv.ConvertSToFOp` ssa-use
                      `:` operand-type `to` result-type
</code></pre><p>For example:</p><pre><code>%1 = spv.ConvertSToF %0 : i32 to f32
%3 = spv.ConvertSToF %2 : vector&lt;3xi32&gt; to vector&lt;3xf32&gt;
</code></pre><h4 id=operands-29>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h4 id=results-29>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h3 id=spvconvertutof-spirvconvertutofop><code>spv.ConvertUToF</code> (spirv::ConvertUToFOp)</h3><pre><code>Convert value numerically from unsigned integer to floating point.
</code></pre><p>Result Type must be a scalar or vector of floating-point type.</p><p>Unsigned Value must be a scalar or vector of integer type. It must have
the same number of components as Result Type.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-33>Custom assembly form</h3><pre><code>convert-u-to-f-op ::= ssa-id `=` `spv.ConvertUToFOp` ssa-use
                      `:` operand-type `to` result-type
</code></pre><p>For example:</p><pre><code>%1 = spv.ConvertUToF %0 : i32 to f32
%3 = spv.ConvertUToF %2 : vector&lt;3xi32&gt; to vector&lt;3xf32&gt;
</code></pre><h4 id=operands-30>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h4 id=results-30>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h3 id=spventrypoint-spirventrypointop><code>spv.EntryPoint</code> (spirv::EntryPointOp)</h3><pre><code>Declare an entry point, its execution model, and its interface.
</code></pre><p>Execution Model is the execution model for the entry point and its
static call tree. See Execution Model.</p><p>Entry Point must be the Result <id>of an OpFunction instruction.</p><p>Name is a name string for the entry point. A module cannot have two
OpEntryPoint instructions with the same Execution Model and the same
Name string.</p><p>Interface is a list of symbol references to <code>spv.globalVariable</code>
operations. These declare the set of global variables from a
module that form the interface of this entry point. The set of
Interface symbols must be equal to or a superset of the
<code>spv.globalVariable</code>s referenced by the entry point’s static call
tree, within the interface’s storage classes. Before version 1.4,
the interface’s storage classes are limited to the Input and
Output storage classes. Starting with version 1.4, the interface’s
storage classes are all storage classes used in declaring all
global variables referenced by the entry point’s call tree.</p><h3 id=custom-assembly-form-34>Custom assembly form</h3><pre><code>execution-model ::= &quot;Vertex&quot; | &quot;TesellationControl&quot; |
                    &lt;and other SPIR-V execution models...&gt;

entry-point-op ::= ssa-id `=` `spv.EntryPoint` execution-model
                   symbol-reference (`, ` symbol-reference)*
</code></pre><p>For example:</p><pre><code>spv.EntryPoint &quot;GLCompute&quot; @foo
spv.EntryPoint &quot;Kernel&quot; @foo, @var1, @var2

</code></pre><h4 id=attributes-18>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>execution_model</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V ExecutionModel</td></tr><tr><td align=center><code>fn</code></td><td align=center>FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td align=center><code>interface</code></td><td align=center>ArrayAttr</td><td>symbol ref array attribute</td></tr></tbody></table><h3 id=spvexecutionmode-spirvexecutionmodeop><code>spv.ExecutionMode</code> (spirv::ExecutionModeOp)</h3><p>Declare an execution mode for an entry point.</p><p>Entry Point must be the Entry Point <id>operand of an OpEntryPoint
instruction.</p><p>Mode is the execution mode. See Execution Mode.</p><p>This instruction is only valid when the Mode operand is an execution
mode that takes no Extra Operands, or takes Extra Operands that are not
<id>operands.</p><h3 id=custom-assembly-form-35>Custom assembly form</h3><pre><code>execution-mode ::= &quot;Invocations&quot; | &quot;SpacingEqual&quot; |
                   &lt;and other SPIR-V execution modes...&gt;

execution-mode-op ::= `spv.ExecutionMode ` ssa-use execution-mode
                      (integer-literal (`, ` integer-literal)* )?
</code></pre><p>For example:</p><pre><code>spv.ExecutionMode @foo &quot;ContractionOff&quot;
spv.ExecutionMode @bar &quot;LocalSizeHint&quot;, 3, 4, 5
</code></pre><h4 id=attributes-19>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>fn</code></td><td align=center>FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td align=center><code>execution_mode</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V ExecutionMode</td></tr><tr><td align=center><code>values</code></td><td align=center>ArrayAttr</td><td>32-bit integer array attribute</td></tr></tbody></table><h3 id=spvfadd-spirvfaddop><code>spv.FAdd</code> (spirv::FAddOp)</h3><p>Floating-point addition of Operand 1 and Operand 2.</p><p>Result Type must be a scalar or vector of floating-point type.</p><p>The types of Operand 1 and Operand 2 both must be the same as Result
Type.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-36>Custom assembly form</h3><pre><code>float-scalar-vector-type ::= float-type |
                             `vector&lt;` integer-literal `x` float-type `&gt;`
fadd-op ::= ssa-id `=` `spv.FAdd` ssa-use, ssa-use
                      `:` float-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%4 = spv.FAdd %0, %1 : f32
%5 = spv.FAdd %2, %3 : vector&lt;4xf32&gt;
</code></pre><h4 id=operands-31>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h4 id=results-31>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h3 id=spvfconvert-spirvfconvertop><code>spv.FConvert</code> (spirv::FConvertOp)</h3><pre><code>Convert value numerically from one floating-point width to another
width.
</code></pre><p>Result Type must be a scalar or vector of floating-point type.</p><p>Float Value must be a scalar or vector of floating-point type. It must
have the same number of components as Result Type. The component width
cannot equal the component width in Result Type.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-37>Custom assembly form</h3><pre><code>f-convert-op ::= ssa-id `=` `spv.FConvertOp` ssa-use
                 `:` operand-type `to` result-type
</code></pre><p>For example:</p><pre><code>%1 = spv.FConvertOp %0 : f32 to f64
%3 = spv.FConvertOp %2 : vector&lt;3xf32&gt; to vector&lt;3xf64&gt;
</code></pre><h4 id=operands-32>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h4 id=results-32>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h3 id=spvfdiv-spirvfdivop><code>spv.FDiv</code> (spirv::FDivOp)</h3><p>Floating-point division of Operand 1 divided by Operand 2.</p><p>Result Type must be a scalar or vector of floating-point type.</p><p>The types of Operand 1 and Operand 2 both must be the same as Result
Type.</p><p>Results are computed per component. The resulting value is undefined
if Operand 2 is 0.</p><h3 id=custom-assembly-form-38>Custom assembly form</h3><pre><code>float-scalar-vector-type ::= float-type |
                             `vector&lt;` integer-literal `x` float-type `&gt;`
fdiv-op ::= ssa-id `=` `spv.FDiv` ssa-use, ssa-use
                      `:` float-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%4 = spv.FDiv %0, %1 : f32
%5 = spv.FDiv %2, %3 : vector&lt;4xf32&gt;
</code></pre><h4 id=operands-33>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h4 id=results-33>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h3 id=spvfmod-spirvfmodop><code>spv.FMod</code> (spirv::FModOp)</h3><pre><code>The floating-point remainder whose sign matches the sign of Operand 2.
</code></pre><p>Result Type must be a scalar or vector of floating-point type.</p><p>The types of Operand 1 and Operand 2 both must be the same as Result
Type.</p><p>Results are computed per component. The resulting value is undefined
if Operand 2 is 0. Otherwise, the result is the remainder r of Operand
1 divided by Operand 2 where if r ≠ 0, the sign of r is the same as the
sign of Operand 2.</p><h3 id=custom-assembly-form-39>Custom assembly form</h3><pre><code>float-scalar-vector-type ::= float-type |
                             `vector&lt;` integer-literal `x` float-type `&gt;`
fmod-op ::= ssa-id `=` `spv.FMod` ssa-use, ssa-use
                      `:` float-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%4 = spv.FMod %0, %1 : f32
%5 = spv.FMod %2, %3 : vector&lt;4xf32&gt;
</code></pre><h4 id=operands-34>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h4 id=results-34>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h3 id=spvfmul-spirvfmulop><code>spv.FMul</code> (spirv::FMulOp)</h3><p>Floating-point multiplication of Operand 1 and Operand 2.</p><p>Result Type must be a scalar or vector of floating-point type.</p><p>The types of Operand 1 and Operand 2 both must be the same as Result
Type.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-40>Custom assembly form</h3><pre><code>float-scalar-vector-type ::= float-type |
                             `vector&lt;` integer-literal `x` float-type `&gt;`
fmul-op ::= `spv.FMul` ssa-use, ssa-use
                      `:` float-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%4 = spv.FMul %0, %1 : f32
%5 = spv.FMul %2, %3 : vector&lt;4xf32&gt;
</code></pre><h4 id=operands-35>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h4 id=results-35>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h3 id=spvfnegate-spirvfnegateop><code>spv.FNegate</code> (spirv::FNegateOp)</h3><p>Floating-point subtract of Operand from zero.</p><p>Result Type must be a scalar or vector of floating-point type.</p><p>The type of Operand must be the same as Result Type.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-41>Custom assembly form</h3><pre><code>float-scalar-vector-type ::= float-type |
                             `vector&lt;` integer-literal `x` float-type `&gt;`
fmul-op ::= `spv.FNegate` ssa-use `:` float-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%1 = spv.FNegate %0 : f32
%3 = spv.FNegate %2 : vector&lt;4xf32&gt;
</code></pre><h4 id=operands-36>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h4 id=results-36>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h3 id=spvfordequal-spirvfordequalop><code>spv.FOrdEqual</code> (spirv::FOrdEqualOp)</h3><p>Floating-point comparison for being ordered and equal.</p><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
floating-point type. They must have the same type, and they must have
the same number of components as Result Type.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-42>Custom assembly form</h3><pre><code>float-scalar-vector-type ::= float-type |
                             `vector&lt;` integer-literal `x` float-type `&gt;`
fordequal-op ::= ssa-id `=` `spv.FOrdEqual` ssa-use, ssa-use
</code></pre><p>For example:</p><pre><code>%4 = spv.FOrdEqual %0, %1 : f32
%5 = spv.FOrdEqual %2, %3 : vector&lt;4xf32&gt;
</code></pre><h4 id=operands-37>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h4 id=results-37>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>bool or vector of bool values of length 2/3/4</td></tr></tbody></table><h3 id=spvfordgreaterthanequal-spirvfordgreaterthanequalop><code>spv.FOrdGreaterThanEqual</code> (spirv::FOrdGreaterThanEqualOp)</h3><pre><code>Floating-point comparison if operands are ordered and Operand 1 is
greater than or equal to Operand 2.
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
floating-point type. They must have the same type, and they must have
the same number of components as Result Type.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-43>Custom assembly form</h3><pre><code>float-scalar-vector-type ::= float-type |
                             `vector&lt;` integer-literal `x` float-type `&gt;`
fordgte-op ::= ssa-id `=` `spv.FOrdGreaterThanEqual` ssa-use, ssa-use
</code></pre><p>For example:</p><pre><code>%4 = spv.FOrdGreaterThanEqual %0, %1 : f32
%5 = spv.FOrdGreaterThanEqual %2, %3 : vector&lt;4xf32&gt;
</code></pre><h4 id=operands-38>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h4 id=results-38>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>bool or vector of bool values of length 2/3/4</td></tr></tbody></table><h3 id=spvfordgreaterthan-spirvfordgreaterthanop><code>spv.FOrdGreaterThan</code> (spirv::FOrdGreaterThanOp)</h3><pre><code>Floating-point comparison if operands are ordered and Operand 1 is
greater than  Operand 2.
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
floating-point type. They must have the same type, and they must have
the same number of components as Result Type.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-44>Custom assembly form</h3><pre><code>float-scalar-vector-type ::= float-type |
                             `vector&lt;` integer-literal `x` float-type `&gt;`
fordgt-op ::= ssa-id `=` `spv.FOrdGreaterThan` ssa-use, ssa-use
</code></pre><p>For example:</p><pre><code>%4 = spv.FOrdGreaterThan %0, %1 : f32
%5 = spv.FOrdGreaterThan %2, %3 : vector&lt;4xf32&gt;
</code></pre><h4 id=operands-39>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h4 id=results-39>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>bool or vector of bool values of length 2/3/4</td></tr></tbody></table><h3 id=spvfordlessthanequal-spirvfordlessthanequalop><code>spv.FOrdLessThanEqual</code> (spirv::FOrdLessThanEqualOp)</h3><pre><code>Floating-point comparison if operands are ordered and Operand 1 is less
than or equal to Operand 2.
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
floating-point type. They must have the same type, and they must have
the same number of components as Result Type.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-45>Custom assembly form</h3><pre><code>float-scalar-vector-type ::= float-type |
                             `vector&lt;` integer-literal `x` float-type `&gt;`
fordlte-op ::= ssa-id `=` `spv.FOrdLessThanEqual` ssa-use, ssa-use
</code></pre><p>For example:</p><pre><code>%4 = spv.FOrdLessThanEqual %0, %1 : f32
%5 = spv.FOrdLessThanEqual %2, %3 : vector&lt;4xf32&gt;
</code></pre><h4 id=operands-40>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h4 id=results-40>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>bool or vector of bool values of length 2/3/4</td></tr></tbody></table><h3 id=spvfordlessthan-spirvfordlessthanop><code>spv.FOrdLessThan</code> (spirv::FOrdLessThanOp)</h3><pre><code>Floating-point comparison if operands are ordered and Operand 1 is less
than Operand 2.
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
floating-point type. They must have the same type, and they must have
the same number of components as Result Type.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-46>Custom assembly form</h3><pre><code>float-scalar-vector-type ::= float-type |
                             `vector&lt;` integer-literal `x` float-type `&gt;`
fordlt-op ::= ssa-id `=` `spv.FOrdLessThan` ssa-use, ssa-use
</code></pre><p>For example:</p><pre><code>%4 = spv.FOrdLessThan %0, %1 : f32
%5 = spv.FOrdLessThan %2, %3 : vector&lt;4xf32&gt;
</code></pre><h4 id=operands-41>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h4 id=results-41>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>bool or vector of bool values of length 2/3/4</td></tr></tbody></table><h3 id=spvfordnotequal-spirvfordnotequalop><code>spv.FOrdNotEqual</code> (spirv::FOrdNotEqualOp)</h3><p>Floating-point comparison for being ordered and not equal.</p><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
floating-point type. They must have the same type, and they must have
the same number of components as Result Type.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-47>Custom assembly form</h3><pre><code>float-scalar-vector-type ::= float-type |
                             `vector&lt;` integer-literal `x` float-type `&gt;`
fordneq-op ::= ssa-id `=` `spv.FOrdNotEqual` ssa-use, ssa-use
</code></pre><p>For example:</p><pre><code>%4 = spv.FOrdNotEqual %0, %1 : f32
%5 = spv.FOrdNotEqual %2, %3 : vector&lt;4xf32&gt;
</code></pre><h4 id=operands-42>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h4 id=results-42>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>bool or vector of bool values of length 2/3/4</td></tr></tbody></table><h3 id=spvfrem-spirvfremop><code>spv.FRem</code> (spirv::FRemOp)</h3><pre><code>The floating-point remainder whose sign matches the sign of Operand 1.
</code></pre><p>Result Type must be a scalar or vector of floating-point type.</p><p>The types of Operand 1 and Operand 2 both must be the same as Result
Type.</p><p>Results are computed per component. The resulting value is undefined
if Operand 2 is 0. Otherwise, the result is the remainder r of Operand
1 divided by Operand 2 where if r ≠ 0, the sign of r is the same as the
sign of Operand 1.</p><h3 id=custom-assembly-form-48>Custom assembly form</h3><pre><code>float-scalar-vector-type ::= float-type |
                             `vector&lt;` integer-literal `x` float-type `&gt;`
frem-op ::= ssa-id `=` `spv.FRemOp` ssa-use, ssa-use
                      `:` float-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%4 = spv.FRemOp %0, %1 : f32
%5 = spv.FRemOp %2, %3 : vector&lt;4xf32&gt;
</code></pre><h4 id=operands-43>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h4 id=results-43>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h3 id=spvfsub-spirvfsubop><code>spv.FSub</code> (spirv::FSubOp)</h3><p>Floating-point subtraction of Operand 2 from Operand 1.</p><p>Result Type must be a scalar or vector of floating-point type.</p><p>The types of Operand 1 and Operand 2 both must be the same as Result
Type.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-49>Custom assembly form</h3><pre><code>float-scalar-vector-type ::= float-type |
                             `vector&lt;` integer-literal `x` float-type `&gt;`
fsub-op ::= ssa-id `=` `spv.FRemOp` ssa-use, ssa-use
                      `:` float-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%4 = spv.FRemOp %0, %1 : f32
%5 = spv.FRemOp %2, %3 : vector&lt;4xf32&gt;
</code></pre><h4 id=operands-44>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h4 id=results-44>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h3 id=spvfunordequal-spirvfunordequalop><code>spv.FUnordEqual</code> (spirv::FUnordEqualOp)</h3><p>Floating-point comparison for being unordered or equal.</p><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
floating-point type. They must have the same type, and they must have
the same number of components as Result Type.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-50>Custom assembly form</h3><pre><code>float-scalar-vector-type ::= float-type |
                             `vector&lt;` integer-literal `x` float-type `&gt;`
funordequal-op ::= ssa-id `=` `spv.FUnordEqual` ssa-use, ssa-use
</code></pre><p>For example:</p><pre><code>%4 = spv.FUnordEqual %0, %1 : f32
%5 = spv.FUnordEqual %2, %3 : vector&lt;4xf32&gt;
</code></pre><h4 id=operands-45>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h4 id=results-45>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>bool or vector of bool values of length 2/3/4</td></tr></tbody></table><h3 id=spvfunordgreaterthanequal-spirvfunordgreaterthanequalop><code>spv.FUnordGreaterThanEqual</code> (spirv::FUnordGreaterThanEqualOp)</h3><pre><code>Floating-point comparison if operands are unordered or Operand 1 is
greater than or equal to Operand 2.
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
floating-point type. They must have the same type, and they must have
the same number of components as Result Type.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-51>Custom assembly form</h3><pre><code>float-scalar-vector-type ::= float-type |
                             `vector&lt;` integer-literal `x` float-type `&gt;`
funordgte-op ::= ssa-id `=` `spv.FUnordGreaterThanEqual` ssa-use, ssa-use
</code></pre><p>For example:</p><pre><code>%4 = spv.FUnordGreaterThanEqual %0, %1 : f32
%5 = spv.FUnordGreaterThanEqual %2, %3 : vector&lt;4xf32&gt;
</code></pre><h4 id=operands-46>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h4 id=results-46>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>bool or vector of bool values of length 2/3/4</td></tr></tbody></table><h3 id=spvfunordgreaterthan-spirvfunordgreaterthanop><code>spv.FUnordGreaterThan</code> (spirv::FUnordGreaterThanOp)</h3><pre><code>Floating-point comparison if operands are unordered or Operand 1 is
greater than  Operand 2.
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
floating-point type. They must have the same type, and they must have
the same number of components as Result Type.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-52>Custom assembly form</h3><pre><code>float-scalar-vector-type ::= float-type |
                             `vector&lt;` integer-literal `x` float-type `&gt;`
funordgt-op ::= ssa-id `=` `spv.FUnordGreaterThan` ssa-use, ssa-use
</code></pre><p>For example:</p><pre><code>%4 = spv.FUnordGreaterThan %0, %1 : f32
%5 = spv.FUnordGreaterThan %2, %3 : vector&lt;4xf32&gt;
</code></pre><h4 id=operands-47>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h4 id=results-47>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>bool or vector of bool values of length 2/3/4</td></tr></tbody></table><h3 id=spvfunordlessthanequal-spirvfunordlessthanequalop><code>spv.FUnordLessThanEqual</code> (spirv::FUnordLessThanEqualOp)</h3><pre><code>Floating-point comparison if operands are unordered or Operand 1 is less
than or equal to Operand 2.
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
floating-point type. They must have the same type, and they must have
the same number of components as Result Type.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-53>Custom assembly form</h3><pre><code>float-scalar-vector-type ::= float-type |
                             `vector&lt;` integer-literal `x` float-type `&gt;`
funordlte-op ::= ssa-id `=` `spv.FUnordLessThanEqual` ssa-use, ssa-use
</code></pre><p>For example:</p><pre><code>%4 = spv.FUnordLessThanEqual %0, %1 : f32
%5 = spv.FUnordLessThanEqual %2, %3 : vector&lt;4xf32&gt;
</code></pre><h4 id=operands-48>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h4 id=results-48>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>bool or vector of bool values of length 2/3/4</td></tr></tbody></table><h3 id=spvfunordlessthan-spirvfunordlessthanop><code>spv.FUnordLessThan</code> (spirv::FUnordLessThanOp)</h3><pre><code>Floating-point comparison if operands are unordered or Operand 1 is less
than Operand 2.
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
floating-point type. They must have the same type, and they must have
the same number of components as Result Type.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-54>Custom assembly form</h3><pre><code>float-scalar-vector-type ::= float-type |
                             `vector&lt;` integer-literal `x` float-type `&gt;`
funordlt-op ::= ssa-id `=` `spv.FUnordLessThan` ssa-use, ssa-use
</code></pre><p>For example:</p><pre><code>%4 = spv.FUnordLessThan %0, %1 : f32
%5 = spv.FUnordLessThan %2, %3 : vector&lt;4xf32&gt;
</code></pre><h4 id=operands-49>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h4 id=results-49>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>bool or vector of bool values of length 2/3/4</td></tr></tbody></table><h3 id=spvfunordnotequal-spirvfunordnotequalop><code>spv.FUnordNotEqual</code> (spirv::FUnordNotEqualOp)</h3><p>Floating-point comparison for being unordered or not equal.</p><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
floating-point type. They must have the same type, and they must have
the same number of components as Result Type.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-55>Custom assembly form</h3><pre><code>float-scalar-vector-type ::= float-type |
                             `vector&lt;` integer-literal `x` float-type `&gt;`
funordneq-op ::= ssa-id `=` `spv.FUnordNotEqual` ssa-use, ssa-use
</code></pre><p>For example:</p><pre><code>%4 = spv.FUnordNotEqual %0, %1 : f32
%5 = spv.FUnordNotEqual %2, %3 : vector&lt;4xf32&gt;
</code></pre><h4 id=operands-50>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h4 id=results-50>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>bool or vector of bool values of length 2/3/4</td></tr></tbody></table><h3 id=spvfunc-spirvfuncop><code>spv.func</code> (spirv::FuncOp)</h3><p>Declare or define a function</p><p>This op declares or defines a SPIR-V function using one region, which
contains one or more blocks.</p><p>Different from the SPIR-V binary format, this op is not allowed to
implicitly capture global values, and all external references must use
function arguments or symbol references. This op itself defines a symbol
that is unique in the enclosing module op.</p><p>This op itself takes no operands and generates no results. Its region
can take zero or more arguments and return zero or one values.</p><h3 id=custom-assembly-form-56>Custom assembly form</h3><pre><code>spv-function-control ::= &quot;None&quot; | &quot;Inline&quot; | &quot;DontInline&quot; | ...
spv-function-op ::= `spv.func` function-signature
                     spv-function-control region
</code></pre><p>For example:</p><pre><code>spv.func @foo() -&gt; () &quot;None&quot; { ... }
spv.func @bar() -&gt; () &quot;Inline|Pure&quot; { ... }
</code></pre><h4 id=attributes-20>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>type</code></td><td align=center>TypeAttr</td><td>any type attribute</td></tr><tr><td align=center><code>sym_name</code></td><td align=center>StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>function_control</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V FunctionControl</td></tr></tbody></table><h3 id=spvfunctioncall-spirvfunctioncallop><code>spv.FunctionCall</code> (spirv::FunctionCallOp)</h3><p>Call a function.</p><p>Syntax:</p><pre><code>operation ::= `spv.FunctionCall` $callee `(` $arguments `)` attr-dict `:`
              functional-type($arguments, results)
</code></pre><p>Result Type is the type of the return value of the function. It must be
the same as the Return Type operand of the Function Type operand of the
Function operand.</p><p>Function is an OpFunction instruction. This could be a forward
reference.</p><p>Argument N is the object to copy to parameter N of Function.</p><p>Note: A forward call is possible because there is no missing type
information: Result Type must match the Return Type of the function, and
the calling argument types must match the formal parameter types.</p><h3 id=custom-assembly-form-57>Custom assembly form</h3><pre><code>function-call-op ::= `spv.FunctionCall` function-id `(` ssa-use-list `)`
                 `:` function-type
</code></pre><p>For example:</p><pre><code>spv.FunctionCall @f_void(%arg0) : (i32) -&gt;  ()
%0 = spv.FunctionCall @f_iadd(%arg0, %arg1) : (i32, i32) -&gt; i32
</code></pre><h4 id=attributes-21>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>callee</code></td><td align=center>FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></tbody></table><h4 id=operands-51>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>arguments</code></td><td>void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float values of length 2/3/4 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type</td></tr></tbody></table><h4 id=results-51>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float values of length 2/3/4 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type</td></tr></tbody></table><h3 id=spvglslceil-spirvglslceilop><code>spv.GLSL.Ceil</code> (spirv::GLSLCeilOp)</h3><p>Rounds up to the next whole number</p><p>Result is the value equal to the nearest whole number that is greater than
or equal to x.</p><p>The operand x must be a scalar or vector whose component type is
floating-point.</p><p>Result Type and the type of x must be the same type. Results are computed
per component.</p><h3 id=custom-assembly-format>Custom assembly format</h3><pre><code>float-scalar-vector-type ::= float-type |
                             `vector&lt;` integer-literal `x` float-type `&gt;`
ceil-op ::= ssa-id `=` `spv.GLSL.Ceil` ssa-use `:`
            float-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%2 = spv.GLSL.Ceil %0 : f32
%3 = spv.GLSL.Ceil %1 : vector&lt;3xf16&gt;
</code></pre><h4 id=operands-52>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h4 id=results-52>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h3 id=spvglslcos-spirvglslcosop><code>spv.GLSL.Cos</code> (spirv::GLSLCosOp)</h3><p>Cosine of operand in radians</p><p>The standard trigonometric cosine of x radians.</p><p>The operand x must be a scalar or vector whose component type is 16-bit or
32-bit floating-point.</p><p>Result Type and the type of x must be the same type. Results are computed
per component.</p><h3 id=custom-assembly-format-1>Custom assembly format</h3><pre><code>restricted-float-scalar-type ::=  `f16` | `f32`
restricted-float-scalar-vector-type ::=
  restricted-float-scalar-type |
  `vector&lt;` integer-literal `x` restricted-float-scalar-type `&gt;`
cos-op ::= ssa-id `=` `spv.GLSL.Cos` ssa-use `:`
           restricted-float-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%2 = spv.GLSL.Cos %0 : f32
%3 = spv.GLSL.Cos %1 : vector&lt;3xf16&gt;
</code></pre><h4 id=operands-53>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>16/32-bit float or vector of 16/32-bit float values of length 2/3/4</td></tr></tbody></table><h4 id=results-53>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>16/32-bit float or vector of 16/32-bit float values of length 2/3/4</td></tr></tbody></table><h3 id=spvglslexp-spirvglslexpop><code>spv.GLSL.Exp</code> (spirv::GLSLExpOp)</h3><p>Exponentiation of Operand 1</p><p>Result is the natural exponentiation of x; e^x.</p><p>The operand x must be a scalar or vector whose component type is
16-bit or 32-bit floating-point.</p><p>Result Type and the type of x must be the same type. Results are
computed per component.";</p><h3 id=custom-assembly-format-2>Custom assembly format</h3><pre><code>restricted-float-scalar-type ::=  `f16` | `f32`
restricted-float-scalar-vector-type ::=
  restricted-float-scalar-type |
  `vector&lt;` integer-literal `x` restricted-float-scalar-type `&gt;`
exp-op ::= ssa-id `=` `spv.GLSL.Exp` ssa-use `:`
           restricted-float-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%2 = spv.GLSL.Exp %0 : f32
%3 = spv.GLSL.Exp %1 : vector&lt;3xf16&gt;
</code></pre><h4 id=operands-54>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>16/32-bit float or vector of 16/32-bit float values of length 2/3/4</td></tr></tbody></table><h4 id=results-54>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>16/32-bit float or vector of 16/32-bit float values of length 2/3/4</td></tr></tbody></table><h3 id=spvglslfabs-spirvglslfabsop><code>spv.GLSL.FAbs</code> (spirv::GLSLFAbsOp)</h3><p>Absolute value of operand</p><p>Result is x if x >= 0; otherwise result is -x.</p><p>The operand x must be a scalar or vector whose component type is
floating-point.</p><p>Result Type and the type of x must be the same type. Results are computed
per component.</p><h3 id=custom-assembly-format-3>Custom assembly format</h3><pre><code>float-scalar-vector-type ::= float-type |
                             `vector&lt;` integer-literal `x` float-type `&gt;`
abs-op ::= ssa-id `=` `spv.GLSL.FAbs` ssa-use `:`
           float-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%2 = spv.GLSL.FAbs %0 : f32
%3 = spv.GLSL.FAbs %1 : vector&lt;3xf16&gt;
</code></pre><h4 id=operands-55>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h4 id=results-55>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h3 id=spvglslfmax-spirvglslfmaxop><code>spv.GLSL.FMax</code> (spirv::GLSLFMaxOp)</h3><p>Return maximum of two floating-point operands</p><p>Result is y if x &lt; y; otherwise result is x. Which operand is the
result is undefined if one of the operands is a NaN.</p><p>The operands must all be a scalar or vector whose component type
is floating-point.</p><p>Result Type and the type of all operands must be the same
type. Results are computed per component.</p><h3 id=custom-assembly-format-4>Custom assembly format</h3><pre><code>float-scalar-vector-type ::= float-type |
                             `vector&lt;` integer-literal `x` float-type `&gt;`
fmax-op ::= ssa-id `=` `spv.GLSL.FMax` ssa-use `:`
            float-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%2 = spv.GLSL.FMax %0, %1 : f32
%3 = spv.GLSL.FMax %0, %1 : vector&lt;3xf16&gt;
</code></pre><h4 id=operands-56>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr><tr><td align=center><code>rhs</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h4 id=results-56>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h3 id=spvglslfmin-spirvglslfminop><code>spv.GLSL.FMin</code> (spirv::GLSLFMinOp)</h3><p>Return minimum of two floating-point operands</p><p>Result is y if y &lt; x; otherwise result is x. Which operand is the result is
undefined if one of the operands is a NaN.</p><p>The operands must all be a scalar or vector whose component type is
floating-point.</p><p>Result Type and the type of all operands must be the same type. Results are
computed per component.</p><h3 id=custom-assembly-format-5>Custom assembly format</h3><pre><code>float-scalar-vector-type ::= float-type |
                             `vector&lt;` integer-literal `x` float-type `&gt;`
fmin-op ::= ssa-id `=` `spv.GLSL.FMin` ssa-use `:`
            float-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%2 = spv.GLSL.FMin %0, %1 : f32
%3 = spv.GLSL.FMin %0, %1 : vector&lt;3xf16&gt;
</code></pre><h4 id=operands-57>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr><tr><td align=center><code>rhs</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h4 id=results-57>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h3 id=spvglslfsign-spirvglslfsignop><code>spv.GLSL.FSign</code> (spirv::GLSLFSignOp)</h3><p>Returns the sign of the operand</p><p>Result is 1.0 if x > 0, 0.0 if x = 0, or -1.0 if x &lt; 0.</p><p>The operand x must be a scalar or vector whose component type is
floating-point.</p><p>Result Type and the type of x must be the same type. Results are computed
per component.</p><h3 id=custom-assembly-format-6>Custom assembly format</h3><pre><code>float-scalar-vector-type ::= float-type |
                             `vector&lt;` integer-literal `x` float-type `&gt;`
sign-op ::= ssa-id `=` `spv.GLSL.FSign` ssa-use `:`
            float-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%2 = spv.GLSL.FSign %0 : f32
%3 = spv.GLSL.FSign %1 : vector&lt;3xf16&gt;
</code></pre><h4 id=operands-58>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h4 id=results-58>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h3 id=spvglslfloor-spirvglslfloorop><code>spv.GLSL.Floor</code> (spirv::GLSLFloorOp)</h3><p>Rounds down to the next whole number</p><p>Result is the value equal to the nearest whole number that is less than or
equal to x.</p><p>The operand x must be a scalar or vector whose component type is
floating-point.</p><p>Result Type and the type of x must be the same type. Results are computed
per component.</p><h3 id=custom-assembly-format-7>Custom assembly format</h3><pre><code>float-scalar-vector-type ::= float-type |
                             `vector&lt;` integer-literal `x` float-type `&gt;`
floor-op ::= ssa-id `=` `spv.GLSL.Floor` ssa-use `:`
            float-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%2 = spv.GLSL.Floor %0 : f32
%3 = spv.GLSL.Floor %1 : vector&lt;3xf16&gt;
</code></pre><h4 id=operands-59>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h4 id=results-59>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h3 id=spvglslinversesqrt-spirvglslinversesqrtop><code>spv.GLSL.InverseSqrt</code> (spirv::GLSLInverseSqrtOp)</h3><p>Reciprocal of sqrt(operand)</p><p>Result is the reciprocal of sqrt x. Result is undefined if x &lt;= 0.</p><p>The operand x must be a scalar or vector whose component type is
floating-point.</p><p>Result Type and the type of x must be the same type. Results are computed
per component.</p><h3 id=custom-assembly-format-8>Custom assembly format</h3><pre><code>float-scalar-vector-type ::= float-type |
                             `vector&lt;` integer-literal `x` float-type `&gt;`
rsqrt-op ::= ssa-id `=` `spv.GLSL.InverseSqrt` ssa-use `:`
             float-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%2 = spv.GLSL.InverseSqrt %0 : f32
%3 = spv.GLSL.InverseSqrt %1 : vector&lt;3xf16&gt;
</code></pre><h4 id=operands-60>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h4 id=results-60>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h3 id=spvglsllog-spirvglsllogop><code>spv.GLSL.Log</code> (spirv::GLSLLogOp)</h3><p>Natural logarithm of the operand</p><p>Result is the natural logarithm of x, i.e., the value y which satisfies the
equation x = ey. Result is undefined if x &lt;= 0.</p><p>The operand x must be a scalar or vector whose component type is 16-bit or
32-bit floating-point.</p><p>Result Type and the type of x must be the same type. Results are computed
per component.</p><h3 id=custom-assembly-format-9>Custom assembly format</h3><pre><code>restricted-float-scalar-type ::=  `f16` | `f32`
restricted-float-scalar-vector-type ::=
  restricted-float-scalar-type |
  `vector&lt;` integer-literal `x` restricted-float-scalar-type `&gt;`
log-op ::= ssa-id `=` `spv.GLSL.Log` ssa-use `:`
           restricted-float-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%2 = spv.GLSL.Log %0 : f32
%3 = spv.GLSL.Log %1 : vector&lt;3xf16&gt;
</code></pre><h4 id=operands-61>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>16/32-bit float or vector of 16/32-bit float values of length 2/3/4</td></tr></tbody></table><h4 id=results-61>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>16/32-bit float or vector of 16/32-bit float values of length 2/3/4</td></tr></tbody></table><h3 id=spvglslsabs-spirvglslsabsop><code>spv.GLSL.SAbs</code> (spirv::GLSLSAbsOp)</h3><p>Absolute value of operand</p><p>Result is x if x ≥ 0; otherwise result is -x, where x is interpreted as a
signed integer.</p><p>Result Type and the type of x must both be integer scalar or integer vector
types. Result Type and operand types must have the same number of components
with the same component width. Results are computed per component.</p><h3 id=custom-assembly-format-10>Custom assembly format</h3><pre><code>integer-scalar-vector-type ::= integer-type |
                               `vector&lt;` integer-literal `x` integer-type `&gt;`
abs-op ::= ssa-id `=` `spv.GLSL.SAbs` ssa-use `:`
           integer-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%2 = spv.GLSL.SAbs %0 : i32
%3 = spv.GLSL.SAbs %1 : vector&lt;3xi16&gt;
</code></pre><h4 id=operands-62>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h4 id=results-62>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h3 id=spvglslsmax-spirvglslsmaxop><code>spv.GLSL.SMax</code> (spirv::GLSLSMaxOp)</h3><p>Return maximum of two signed integer operands</p><p>Result is y if x &lt; y; otherwise result is x, where x and y are interpreted
as signed integers.</p><p>Result Type and the type of x and y must both be integer scalar or integer
vector types. Result Type and operand types must have the same number of
components with the same component width. Results are computed per
component.</p><h3 id=custom-assembly-format-11>Custom assembly format</h3><pre><code>integer-scalar-vector-type ::= integer-type |
                               `vector&lt;` integer-literal `x` integer-type `&gt;`
smax-op ::= ssa-id `=` `spv.GLSL.SMax` ssa-use `:`
            integer-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%2 = spv.GLSL.SMax %0, %1 : i32
%3 = spv.GLSL.SMax %0, %1 : vector&lt;3xi16&gt;
</code></pre><h4 id=operands-63>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr><tr><td align=center><code>rhs</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h4 id=results-63>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h3 id=spvglslsmin-spirvglslsminop><code>spv.GLSL.SMin</code> (spirv::GLSLSMinOp)</h3><p>Return minimum of two signed integer operands</p><p>Result is y if y &lt; x; otherwise result is x, where x and y are interpreted
as signed integers.</p><p>Result Type and the type of x and y must both be integer scalar or integer
vector types. Result Type and operand types must have the same number of
components with the same component width. Results are computed per
component.</p><h3 id=custom-assembly-format-12>Custom assembly format</h3><pre><code>integer-scalar-vector-type ::= integer-type |
                               `vector&lt;` integer-literal `x` integer-type `&gt;`
smin-op ::= ssa-id `=` `spv.GLSL.SMin` ssa-use `:`
            integer-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%2 = spv.GLSL.SMin %0, %1 : i32
%3 = spv.GLSL.SMin %0, %1 : vector&lt;3xi16&gt;
</code></pre><h4 id=operands-64>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr><tr><td align=center><code>rhs</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h4 id=results-64>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h3 id=spvglslssign-spirvglslssignop><code>spv.GLSL.SSign</code> (spirv::GLSLSSignOp)</h3><p>Returns the sign of the operand</p><p>Result is 1 if x > 0, 0 if x = 0, or -1 if x &lt; 0, where x is interpreted as
a signed integer.</p><p>Result Type and the type of x must both be integer scalar or integer vector
types. Result Type and operand types must have the same number of components
with the same component width. Results are computed per component.</p><h3 id=custom-assembly-format-13>Custom assembly format</h3><pre><code>integer-scalar-vector-type ::= integer-type |
                               `vector&lt;` integer-literal `x` integer-type `&gt;`
sign-op ::= ssa-id `=` `spv.GLSL.SSign` ssa-use `:`
            integer-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%2 = spv.GLSL.SSign %0 : i32
%3 = spv.GLSL.SSign %1 : vector&lt;3xi16&gt;
</code></pre><h4 id=operands-65>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h4 id=results-65>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h3 id=spvglslsin-spirvglslsinop><code>spv.GLSL.Sin</code> (spirv::GLSLSinOp)</h3><p>Sine of operand in radians</p><p>The standard trigonometric sine of x radians.</p><p>The operand x must be a scalar or vector whose component type is 16-bit or
32-bit floating-point.</p><p>Result Type and the type of x must be the same type. Results are computed
per component.</p><h3 id=custom-assembly-format-14>Custom assembly format</h3><pre><code>restricted-float-scalar-type ::=  `f16` | `f32`
restricted-float-scalar-vector-type ::=
  restricted-float-scalar-type |
  `vector&lt;` integer-literal `x` restricted-float-scalar-type `&gt;`
sin-op ::= ssa-id `=` `spv.GLSL.Sin` ssa-use `:`
           restricted-float-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%2 = spv.GLSL.Sin %0 : f32
%3 = spv.GLSL.Sin %1 : vector&lt;3xf16&gt;
</code></pre><h4 id=operands-66>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>16/32-bit float or vector of 16/32-bit float values of length 2/3/4</td></tr></tbody></table><h4 id=results-66>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>16/32-bit float or vector of 16/32-bit float values of length 2/3/4</td></tr></tbody></table><h3 id=spvglslsqrt-spirvglslsqrtop><code>spv.GLSL.Sqrt</code> (spirv::GLSLSqrtOp)</h3><p>Returns the square root of the operand</p><p>Result is the square root of x. Result is undefined if x &lt; 0.</p><p>The operand x must be a scalar or vector whose component type is
floating-point.</p><p>Result Type and the type of x must be the same type. Results are computed
per component.</p><h3 id=custom-assembly-format-15>Custom assembly format</h3><pre><code>float-scalar-vector-type ::= float-type |
                             `vector&lt;` integer-literal `x` float-type `&gt;`
sqrt-op ::= ssa-id `=` `spv.GLSL.Sqrt` ssa-use `:`
            float-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%2 = spv.GLSL.Sqrt %0 : f32
%3 = spv.GLSL.Sqrt %1 : vector&lt;3xf16&gt;
</code></pre><h4 id=operands-67>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h4 id=results-67>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h3 id=spvglsltanh-spirvglsltanhop><code>spv.GLSL.Tanh</code> (spirv::GLSLTanhOp)</h3><p>Hyperbolic tangent of operand in radians</p><p>Hyperbolic tangent of x radians.</p><p>The operand x must be a scalar or vector whose component type is 16-bit or
32-bit floating-point.</p><p>Result Type and the type of x must be the same type. Results are computed
per component.</p><h3 id=custom-assembly-format-16>Custom assembly format</h3><pre><code>restricted-float-scalar-type ::=  `f16` | `f32`
restricted-float-scalar-vector-type ::=
  restricted-float-scalar-type |
  `vector&lt;` integer-literal `x` restricted-float-scalar-type `&gt;`
tanh-op ::= ssa-id `=` `spv.GLSL.Tanh` ssa-use `:`
            restricted-float-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%2 = spv.GLSL.Tanh %0 : f32
%3 = spv.GLSL.Tanh %1 : vector&lt;3xf16&gt;
</code></pre><h4 id=operands-68>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>16/32-bit float or vector of 16/32-bit float values of length 2/3/4</td></tr></tbody></table><h4 id=results-68>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>16/32-bit float or vector of 16/32-bit float values of length 2/3/4</td></tr></tbody></table><h3 id=spvglobalvariable-spirvglobalvariableop><code>spv.globalVariable</code> (spirv::GlobalVariableOp)</h3><pre><code>Allocate an object in memory at module scope. The object is
referenced using a symbol name.
</code></pre><p>The variable type must be an OpTypePointer. Its type operand is the type of
object in memory.</p><p>Storage Class is the Storage Class of the memory holding the object. It
cannot be Generic. It must be the same as the Storage Class operand of
the variable types. Only those storage classes that are valid at module
scope (like Input, Output, StorageBuffer, etc.) are valid.</p><p>Initializer is optional. If Initializer is present, it will be
the initial value of the variable’s memory content. Initializer
must be an symbol defined from a constant instruction or other
<code>spv.globalVariable</code> operation in module scope. Initializer must
have the same type as the type of the defined symbol.</p><h3 id=custom-assembly-form-58>Custom assembly form</h3><pre><code>variable-op ::= `spv.globalVariable` spirv-type symbol-ref-id
                (`initializer(` symbol-ref-id `)`)?
                (`bind(` integer-literal, integer-literal `)`)?
                (`built_in(` string-literal `)`)?
                attribute-dict?
</code></pre><p>where <code>initializer</code> specifies initializer and <code>bind</code> specifies the
descriptor set and binding number. <code>built_in</code> specifies SPIR-V
BuiltIn decoration associated with the op.</p><p>For example:</p><pre><code>spv.globalVariable @var0 : !spv.ptr&lt;f32, Input&gt; @var0
spv.globalVariable @var1 initializer(@var0) : !spv.ptr&lt;f32, Output&gt;
spv.globalVariable @var2 bind(1, 2) : !spv.ptr&lt;f32, Uniform&gt;
spv.globalVariable @var3 built_in(&quot;GlobalInvocationId&quot;) : !spv.ptr&lt;vector&lt;3xi32&gt;, Input&gt;
</code></pre><h4 id=attributes-22>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>type</code></td><td align=center>TypeAttr</td><td>any type attribute</td></tr><tr><td align=center><code>sym_name</code></td><td align=center>StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>initializer</code></td><td align=center>FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></tbody></table><h3 id=spvgroupnonuniformballot-spirvgroupnonuniformballotop><code>spv.GroupNonUniformBallot</code> (spirv::GroupNonUniformBallotOp)</h3><pre><code>Returns a bitfield value combining the Predicate value from all
invocations in the group that execute the same dynamic instance of this
instruction. The bit is set to one if the corresponding invocation is
active and the Predicate for that invocation evaluated to true;
otherwise, it is set to zero.
</code></pre><p>Syntax:</p><pre><code>operation ::= `spv.GroupNonUniformBallot` $execution_scope $predicate attr-dict `:` type($result)
</code></pre><p>Result Type must be a vector of four components of integer type scalar,
whose Signedness operand is 0.</p><p>Result is a set of bitfields where the first invocation is represented
in the lowest bit of the first vector component and the last (up to the
size of the group) is the higher bit number of the last bitmask needed
to represent all bits of the group invocations.</p><p>Execution must be Workgroup or Subgroup Scope.</p><p>Predicate must be a Boolean type.</p><h3 id=custom-assembly-form-59>Custom assembly form</h3><pre><code>scope ::= `&quot;Workgroup&quot;` | `&quot;Subgroup&quot;`
non-uniform-ballot-op ::= ssa-id `=` `spv.GroupNonUniformBallot` scope
                          ssa-use `:` `vector` `&lt;` 4 `x` `integer-type` `&gt;`
</code></pre><p>For example:</p><pre><code>%0 = spv.GroupNonUniformBallot &quot;SubGroup&quot; %predicate : vector&lt;4xi32&gt;
</code></pre><h4 id=attributes-23>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>execution_scope</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V Scope</td></tr></tbody></table><h4 id=operands-69>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>predicate</code></td><td>bool</td></tr></tbody></table><h4 id=results-69>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>vector of 8/16/32/64-bit signless/unsigned integer values of length 4</td></tr></tbody></table><h3 id=spvgroupnonuniformelect-spirvgroupnonuniformelectop><code>spv.GroupNonUniformElect</code> (spirv::GroupNonUniformElectOp)</h3><pre><code>Result is true only in the active invocation with the lowest id in the
group, otherwise result is false.
</code></pre><p>Syntax:</p><pre><code>operation ::= `spv.GroupNonUniformElect` $execution_scope attr-dict `:` type($result)
</code></pre><p>Result Type must be a Boolean type.</p><p>Execution must be Workgroup or Subgroup Scope.</p><h3 id=custom-assembly-form-60>Custom assembly form</h3><pre><code>scope ::= `&quot;Workgroup&quot;` | `&quot;Subgroup&quot;`
non-uniform-elect-op ::= ssa-id `=` `spv.GroupNonUniformElect` scope
                         `:` `i1`
</code></pre><p>For example:</p><pre><code>%0 = spv.GroupNonUniformElect : i1
</code></pre><h4 id=attributes-24>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>execution_scope</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V Scope</td></tr></tbody></table><h4 id=results-70>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>bool</td></tr></tbody></table><h3 id=spvgroupnonuniformfadd-spirvgroupnonuniformfaddop><code>spv.GroupNonUniformFAdd</code> (spirv::GroupNonUniformFAddOp)</h3><pre><code>A floating point add group operation of all Value operands contributed
by active invocations in the group.
</code></pre><p>Result Type must be a scalar or vector of floating-point type.</p><p>Execution must be Workgroup or Subgroup Scope.</p><p>The identity I for Operation is 0. If Operation is ClusteredReduce,
ClusterSize must be specified.</p><p>The type of Value must be the same as Result Type. The method used to
perform the group operation on the contributed Value(s) from active
invocations is implementation defined.</p><p>ClusterSize is the size of cluster to use. ClusterSize must be a scalar
of integer type, whose Signedness operand is 0. ClusterSize must come
from a constant instruction. ClusterSize must be at least 1, and must be
a power of 2. If ClusterSize is greater than the declared SubGroupSize,
executing this instruction results in undefined behavior.</p><h3 id=custom-assembly-form-61>Custom assembly form</h3><pre><code>scope ::= `&quot;Workgroup&quot;` | `&quot;Subgroup&quot;`
operation ::= `&quot;Reduce&quot;` | `&quot;InclusiveScan&quot;` | `&quot;ExclusiveScan&quot;` | ...
float-scalar-vector-type ::= float-type |
                             `vector&lt;` integer-literal `x` float-type `&gt;`
non-uniform-fadd-op ::= ssa-id `=` `spv.GroupNonUniformFAdd` scope operation
                        ssa-use ( `cluster_size` `(` ssa_use `)` )?
                        `:` float-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%four = spv.constant 4 : i32
%scalar = ... : f32
%vector = ... : vector&lt;4xf32&gt;
%0 = spv.GroupNonUniformFAdd &quot;Workgroup&quot; &quot;Reduce&quot; %scalar : f32
%1 = spv.GroupNonUniformFAdd &quot;Subgroup&quot; &quot;ClusteredReduce&quot; %vector cluster_size(%four) : vector&lt;4xf32&gt;
</code></pre><h4 id=attributes-25>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>execution_scope</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V Scope</td></tr><tr><td align=center><code>group_operation</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V GroupOperation</td></tr></tbody></table><h4 id=operands-70>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr><tr><td align=center><code>cluster_size</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-71>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h3 id=spvgroupnonuniformfmax-spirvgroupnonuniformfmaxop><code>spv.GroupNonUniformFMax</code> (spirv::GroupNonUniformFMaxOp)</h3><pre><code>A floating point maximum group operation of all Value operands
contributed by active invocations in by group.
</code></pre><p>Result Type must be a scalar or vector of floating-point type.</p><p>Execution must be Workgroup or Subgroup Scope.</p><p>The identity I for Operation is -INF. If Operation is ClusteredReduce,
ClusterSize must be specified.</p><p>The type of Value must be the same as Result Type. The method used to
perform the group operation on the contributed Value(s) from active
invocations is implementation defined. From the set of Value(s) provided
by active invocations within a subgroup, if for any two Values one of
them is a NaN, the other is chosen. If all Value(s) that are used by the
current invocation are NaN, then the result is an undefined value.</p><p>ClusterSize is the size of cluster to use. ClusterSize must be a scalar
of integer type, whose Signedness operand is 0. ClusterSize must come
from a constant instruction. ClusterSize must be at least 1, and must be
a power of 2. If ClusterSize is greater than the declared SubGroupSize,
executing this instruction results in undefined behavior.</p><h3 id=custom-assembly-form-62>Custom assembly form</h3><pre><code>scope ::= `&quot;Workgroup&quot;` | `&quot;Subgroup&quot;`
operation ::= `&quot;Reduce&quot;` | `&quot;InclusiveScan&quot;` | `&quot;ExclusiveScan&quot;` | ...
float-scalar-vector-type ::= float-type |
                             `vector&lt;` integer-literal `x` float-type `&gt;`
non-uniform-fmax-op ::= ssa-id `=` `spv.GroupNonUniformFMax` scope operation
                        ssa-use ( `cluster_size` `(` ssa_use `)` )?
                        `:` float-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%four = spv.constant 4 : i32
%scalar = ... : f32
%vector = ... : vector&lt;4xf32&gt;
%0 = spv.GroupNonUniformFMax &quot;Workgroup&quot; &quot;Reduce&quot; %scalar : f32
%1 = spv.GroupNonUniformFMax &quot;Subgroup&quot; &quot;ClusteredReduce&quot; %vector cluster_size(%four) : vector&lt;4xf32&gt;
</code></pre><h4 id=attributes-26>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>execution_scope</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V Scope</td></tr><tr><td align=center><code>group_operation</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V GroupOperation</td></tr></tbody></table><h4 id=operands-71>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr><tr><td align=center><code>cluster_size</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-72>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h3 id=spvgroupnonuniformfmin-spirvgroupnonuniformfminop><code>spv.GroupNonUniformFMin</code> (spirv::GroupNonUniformFMinOp)</h3><pre><code>A floating point minimum group operation of all Value operands
contributed by active invocations in the group.
</code></pre><p>Result Type must be a scalar or vector of floating-point type.</p><p>Execution must be Workgroup or Subgroup Scope.</p><p>The identity I for Operation is +INF. If Operation is ClusteredReduce,
ClusterSize must be specified.</p><p>The type of Value must be the same as Result Type. The method used to
perform the group operation on the contributed Value(s) from active
invocations is implementation defined. From the set of Value(s) provided
by active invocations within a subgroup, if for any two Values one of
them is a NaN, the other is chosen. If all Value(s) that are used by the
current invocation are NaN, then the result is an undefined value.</p><p>ClusterSize is the size of cluster to use. ClusterSize must be a scalar
of integer type, whose Signedness operand is 0. ClusterSize must come
from a constant instruction. ClusterSize must be at least 1, and must be
a power of 2. If ClusterSize is greater than the declared SubGroupSize,
executing this instruction results in undefined behavior.</p><h3 id=custom-assembly-form-63>Custom assembly form</h3><pre><code>scope ::= `&quot;Workgroup&quot;` | `&quot;Subgroup&quot;`
operation ::= `&quot;Reduce&quot;` | `&quot;InclusiveScan&quot;` | `&quot;ExclusiveScan&quot;` | ...
float-scalar-vector-type ::= float-type |
                             `vector&lt;` integer-literal `x` float-type `&gt;`
non-uniform-fmin-op ::= ssa-id `=` `spv.GroupNonUniformFMin` scope operation
                        ssa-use ( `cluster_size` `(` ssa_use `)` )?
                        `:` float-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%four = spv.constant 4 : i32
%scalar = ... : f32
%vector = ... : vector&lt;4xf32&gt;
%0 = spv.GroupNonUniformFMin &quot;Workgroup&quot; &quot;Reduce&quot; %scalar : f32
%1 = spv.GroupNonUniformFMin &quot;Subgroup&quot; &quot;ClusteredReduce&quot; %vector cluster_size(%four) : vector&lt;4xf32&gt;
</code></pre><h4 id=attributes-27>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>execution_scope</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V Scope</td></tr><tr><td align=center><code>group_operation</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V GroupOperation</td></tr></tbody></table><h4 id=operands-72>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr><tr><td align=center><code>cluster_size</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-73>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h3 id=spvgroupnonuniformfmul-spirvgroupnonuniformfmulop><code>spv.GroupNonUniformFMul</code> (spirv::GroupNonUniformFMulOp)</h3><pre><code>A floating point multiply group operation of all Value operands
contributed by active invocations in the group.
</code></pre><p>Result Type must be a scalar or vector of floating-point type.</p><p>Execution must be Workgroup or Subgroup Scope.</p><p>The identity I for Operation is 1. If Operation is ClusteredReduce,
ClusterSize must be specified.</p><p>The type of Value must be the same as Result Type. The method used to
perform the group operation on the contributed Value(s) from active
invocations is implementation defined.</p><p>ClusterSize is the size of cluster to use. ClusterSize must be a scalar
of integer type, whose Signedness operand is 0. ClusterSize must come
from a constant instruction. ClusterSize must be at least 1, and must be
a power of 2. If ClusterSize is greater than the declared SubGroupSize,
executing this instruction results in undefined behavior.</p><h3 id=custom-assembly-form-64>Custom assembly form</h3><pre><code>scope ::= `&quot;Workgroup&quot;` | `&quot;Subgroup&quot;`
operation ::= `&quot;Reduce&quot;` | `&quot;InclusiveScan&quot;` | `&quot;ExclusiveScan&quot;` | ...
float-scalar-vector-type ::= float-type |
                             `vector&lt;` integer-literal `x` float-type `&gt;`
non-uniform-fmul-op ::= ssa-id `=` `spv.GroupNonUniformFMul` scope operation
                        ssa-use ( `cluster_size` `(` ssa_use `)` )?
                        `:` float-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%four = spv.constant 4 : i32
%scalar = ... : f32
%vector = ... : vector&lt;4xf32&gt;
%0 = spv.GroupNonUniformFMul &quot;Workgroup&quot; &quot;Reduce&quot; %scalar : f32
%1 = spv.GroupNonUniformFMul &quot;Subgroup&quot; &quot;ClusteredReduce&quot; %vector cluster_size(%four) : vector&lt;4xf32&gt;
</code></pre><h4 id=attributes-28>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>execution_scope</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V Scope</td></tr><tr><td align=center><code>group_operation</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V GroupOperation</td></tr></tbody></table><h4 id=operands-73>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr><tr><td align=center><code>cluster_size</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-74>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h3 id=spvgroupnonuniformiadd-spirvgroupnonuniformiaddop><code>spv.GroupNonUniformIAdd</code> (spirv::GroupNonUniformIAddOp)</h3><pre><code>An integer add group operation of all Value operands contributed active
by invocations in the group.
</code></pre><p>Result Type must be a scalar or vector of integer type.</p><p>Execution must be Workgroup or Subgroup Scope.</p><p>The identity I for Operation is 0. If Operation is ClusteredReduce,
ClusterSize must be specified.</p><p>The type of Value must be the same as Result Type.</p><p>ClusterSize is the size of cluster to use. ClusterSize must be a scalar
of integer type, whose Signedness operand is 0. ClusterSize must come
from a constant instruction. ClusterSize must be at least 1, and must be
a power of 2. If ClusterSize is greater than the declared SubGroupSize,
executing this instruction results in undefined behavior.</p><h3 id=custom-assembly-form-65>Custom assembly form</h3><pre><code>scope ::= `&quot;Workgroup&quot;` | `&quot;Subgroup&quot;`
operation ::= `&quot;Reduce&quot;` | `&quot;InclusiveScan&quot;` | `&quot;ExclusiveScan&quot;` | ...
integer-scalar-vector-type ::= integer-type |
                             `vector&lt;` integer-literal `x` integer-type `&gt;`
non-uniform-iadd-op ::= ssa-id `=` `spv.GroupNonUniformIAdd` scope operation
                        ssa-use ( `cluster_size` `(` ssa_use `)` )?
                        `:` integer-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%four = spv.constant 4 : i32
%scalar = ... : i32
%vector = ... : vector&lt;4xi32&gt;
%0 = spv.GroupNonUniformIAdd &quot;Workgroup&quot; &quot;Reduce&quot; %scalar : i32
%1 = spv.GroupNonUniformIAdd &quot;Subgroup&quot; &quot;ClusteredReduce&quot; %vector cluster_size(%four) : vector&lt;4xi32&gt;
</code></pre><h4 id=attributes-29>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>execution_scope</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V Scope</td></tr><tr><td align=center><code>group_operation</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V GroupOperation</td></tr></tbody></table><h4 id=operands-74>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr><tr><td align=center><code>cluster_size</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-75>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h3 id=spvgroupnonuniformimul-spirvgroupnonuniformimulop><code>spv.GroupNonUniformIMul</code> (spirv::GroupNonUniformIMulOp)</h3><pre><code>An integer multiply group operation of all Value operands contributed by
active invocations in the group.
</code></pre><p>Result Type must be a scalar or vector of integer type.</p><p>Execution must be Workgroup or Subgroup Scope.</p><p>The identity I for Operation is 1. If Operation is ClusteredReduce,
ClusterSize must be specified.</p><p>The type of Value must be the same as Result Type.</p><p>ClusterSize is the size of cluster to use. ClusterSize must be a scalar
of integer type, whose Signedness operand is 0. ClusterSize must come
from a constant instruction. ClusterSize must be at least 1, and must be
a power of 2. If ClusterSize is greater than the declared SubGroupSize,
executing this instruction results in undefined behavior.</p><h3 id=custom-assembly-form-66>Custom assembly form</h3><pre><code>scope ::= `&quot;Workgroup&quot;` | `&quot;Subgroup&quot;`
operation ::= `&quot;Reduce&quot;` | `&quot;InclusiveScan&quot;` | `&quot;ExclusiveScan&quot;` | ...
integer-scalar-vector-type ::= integer-type |
                             `vector&lt;` integer-literal `x` integer-type `&gt;`
non-uniform-imul-op ::= ssa-id `=` `spv.GroupNonUniformIMul` scope operation
                        ssa-use ( `cluster_size` `(` ssa_use `)` )?
                        `:` integer-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%four = spv.constant 4 : i32
%scalar = ... : i32
%vector = ... : vector&lt;4xi32&gt;
%0 = spv.GroupNonUniformIMul &quot;Workgroup&quot; &quot;Reduce&quot; %scalar : i32
%1 = spv.GroupNonUniformIMul &quot;Subgroup&quot; &quot;ClusteredReduce&quot; %vector cluster_size(%four) : vector&lt;4xi32&gt;
</code></pre><h4 id=attributes-30>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>execution_scope</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V Scope</td></tr><tr><td align=center><code>group_operation</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V GroupOperation</td></tr></tbody></table><h4 id=operands-75>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr><tr><td align=center><code>cluster_size</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-76>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h3 id=spvgroupnonuniformsmax-spirvgroupnonuniformsmaxop><code>spv.GroupNonUniformSMax</code> (spirv::GroupNonUniformSMaxOp)</h3><pre><code>A signed integer maximum group operation of all Value operands
contributed by active invocations in the group.
</code></pre><p>Result Type must be a scalar or vector of integer type.</p><p>Execution must be Workgroup or Subgroup Scope.</p><p>The identity I for Operation is INT_MIN. If Operation is
ClusteredReduce, ClusterSize must be specified.</p><p>The type of Value must be the same as Result Type.</p><p>ClusterSize is the size of cluster to use. ClusterSize must be a scalar
of integer type, whose Signedness operand is 0. ClusterSize must come
from a constant instruction. ClusterSize must be at least 1, and must be
a power of 2. If ClusterSize is greater than the declared SubGroupSize,
executing this instruction results in undefined behavior.</p><h3 id=custom-assembly-form-67>Custom assembly form</h3><pre><code>scope ::= `&quot;Workgroup&quot;` | `&quot;Subgroup&quot;`
operation ::= `&quot;Reduce&quot;` | `&quot;InclusiveScan&quot;` | `&quot;ExclusiveScan&quot;` | ...
integer-scalar-vector-type ::= integer-type |
                             `vector&lt;` integer-literal `x` integer-type `&gt;`
non-uniform-smax-op ::= ssa-id `=` `spv.GroupNonUniformSMax` scope operation
                        ssa-use ( `cluster_size` `(` ssa_use `)` )?
                        `:` integer-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%four = spv.constant 4 : i32
%scalar = ... : i32
%vector = ... : vector&lt;4xi32&gt;
%0 = spv.GroupNonUniformSMax &quot;Workgroup&quot; &quot;Reduce&quot; %scalar : i32
%1 = spv.GroupNonUniformSMax &quot;Subgroup&quot; &quot;ClusteredReduce&quot; %vector cluster_size(%four) : vector&lt;4xi32&gt;
</code></pre><h4 id=attributes-31>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>execution_scope</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V Scope</td></tr><tr><td align=center><code>group_operation</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V GroupOperation</td></tr></tbody></table><h4 id=operands-76>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr><tr><td align=center><code>cluster_size</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-77>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h3 id=spvgroupnonuniformsmin-spirvgroupnonuniformsminop><code>spv.GroupNonUniformSMin</code> (spirv::GroupNonUniformSMinOp)</h3><pre><code>A signed integer minimum group operation of all Value operands
contributed by active invocations in the group.
</code></pre><p>Result Type must be a scalar or vector of integer type.</p><p>Execution must be Workgroup or Subgroup Scope.</p><p>The identity I for Operation is INT_MAX. If Operation is
ClusteredReduce, ClusterSize must be specified.</p><p>The type of Value must be the same as Result Type.</p><p>ClusterSize is the size of cluster to use. ClusterSize must be a scalar
of integer type, whose Signedness operand is 0. ClusterSize must come
from a constant instruction. ClusterSize must be at least 1, and must be
a power of 2. If ClusterSize is greater than the declared SubGroupSize,
executing this instruction results in undefined behavior.</p><h3 id=custom-assembly-form-68>Custom assembly form</h3><pre><code>scope ::= `&quot;Workgroup&quot;` | `&quot;Subgroup&quot;`
operation ::= `&quot;Reduce&quot;` | `&quot;InclusiveScan&quot;` | `&quot;ExclusiveScan&quot;` | ...
integer-scalar-vector-type ::= integer-type |
                             `vector&lt;` integer-literal `x` integer-type `&gt;`
non-uniform-smin-op ::= ssa-id `=` `spv.GroupNonUniformSMin` scope operation
                        ssa-use ( `cluster_size` `(` ssa_use `)` )?
                        `:` integer-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%four = spv.constant 4 : i32
%scalar = ... : i32
%vector = ... : vector&lt;4xi32&gt;
%0 = spv.GroupNonUniformSMin &quot;Workgroup&quot; &quot;Reduce&quot; %scalar : i32
%1 = spv.GroupNonUniformSMin &quot;Subgroup&quot; &quot;ClusteredReduce&quot; %vector cluster_size(%four) : vector&lt;4xi32&gt;
</code></pre><h4 id=attributes-32>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>execution_scope</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V Scope</td></tr><tr><td align=center><code>group_operation</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V GroupOperation</td></tr></tbody></table><h4 id=operands-77>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr><tr><td align=center><code>cluster_size</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-78>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h3 id=spvgroupnonuniformumax-spirvgroupnonuniformumaxop><code>spv.GroupNonUniformUMax</code> (spirv::GroupNonUniformUMaxOp)</h3><pre><code>An unsigned integer maximum group operation of all Value operands
contributed by active invocations in the group.
</code></pre><p>Result Type must be a scalar or vector of integer type, whose
Signedness operand is 0.</p><p>Execution must be Workgroup or Subgroup Scope.</p><p>The identity I for Operation is 0. If Operation is ClusteredReduce,
ClusterSize must be specified.</p><p>The type of Value must be the same as Result Type.</p><p>ClusterSize is the size of cluster to use. ClusterSize must be a scalar
of integer type, whose Signedness operand is 0. ClusterSize must come
from a constant instruction. ClusterSize must be at least 1, and must be
a power of 2. If ClusterSize is greater than the declared SubGroupSize,
executing this instruction results in undefined behavior.</p><h3 id=custom-assembly-form-69>Custom assembly form</h3><pre><code>scope ::= `&quot;Workgroup&quot;` | `&quot;Subgroup&quot;`
operation ::= `&quot;Reduce&quot;` | `&quot;InclusiveScan&quot;` | `&quot;ExclusiveScan&quot;` | ...
integer-scalar-vector-type ::= integer-type |
                             `vector&lt;` integer-literal `x` integer-type `&gt;`
non-uniform-umax-op ::= ssa-id `=` `spv.GroupNonUniformUMax` scope operation
                        ssa-use ( `cluster_size` `(` ssa_use `)` )?
                        `:` integer-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%four = spv.constant 4 : i32
%scalar = ... : i32
%vector = ... : vector&lt;4xi32&gt;
%0 = spv.GroupNonUniformUMax &quot;Workgroup&quot; &quot;Reduce&quot; %scalar : i32
%1 = spv.GroupNonUniformUMax &quot;Subgroup&quot; &quot;ClusteredReduce&quot; %vector cluster_size(%four) : vector&lt;4xi32&gt;
</code></pre><h4 id=attributes-33>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>execution_scope</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V Scope</td></tr><tr><td align=center><code>group_operation</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V GroupOperation</td></tr></tbody></table><h4 id=operands-78>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr><tr><td align=center><code>cluster_size</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-79>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h3 id=spvgroupnonuniformumin-spirvgroupnonuniformuminop><code>spv.GroupNonUniformUMin</code> (spirv::GroupNonUniformUMinOp)</h3><pre><code>An unsigned integer minimum group operation of all Value operands
contributed by active invocations in the group.
</code></pre><p>Result Type must be a scalar or vector of integer type, whose
Signedness operand is 0.</p><p>Execution must be Workgroup or Subgroup Scope.</p><p>The identity I for Operation is UINT_MAX. If Operation is
ClusteredReduce, ClusterSize must be specified.</p><p>The type of Value must be the same as Result Type.</p><p>ClusterSize is the size of cluster to use. ClusterSize must be a scalar
of integer type, whose Signedness operand is 0. ClusterSize must come
from a constant instruction. ClusterSize must be at least 1, and must be
a power of 2. If ClusterSize is greater than the declared SubGroupSize,
executing this instruction results in undefined behavior.</p><h3 id=custom-assembly-form-70>Custom assembly form</h3><pre><code>scope ::= `&quot;Workgroup&quot;` | `&quot;Subgroup&quot;`
operation ::= `&quot;Reduce&quot;` | `&quot;InclusiveScan&quot;` | `&quot;ExclusiveScan&quot;` | ...
integer-scalar-vector-type ::= integer-type |
                             `vector&lt;` integer-literal `x` integer-type `&gt;`
non-uniform-umin-op ::= ssa-id `=` `spv.GroupNonUniformUMin` scope operation
                        ssa-use ( `cluster_size` `(` ssa_use `)` )?
                        `:` integer-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%four = spv.constant 4 : i32
%scalar = ... : i32
%vector = ... : vector&lt;4xi32&gt;
%0 = spv.GroupNonUniformUMin &quot;Workgroup&quot; &quot;Reduce&quot; %scalar : i32
%1 = spv.GroupNonUniformUMin &quot;Subgroup&quot; &quot;ClusteredReduce&quot; %vector cluster_size(%four) : vector&lt;4xi32&gt;
</code></pre><h4 id=attributes-34>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>execution_scope</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V Scope</td></tr><tr><td align=center><code>group_operation</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V GroupOperation</td></tr></tbody></table><h4 id=operands-79>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr><tr><td align=center><code>cluster_size</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-80>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h3 id=spviadd-spirviaddop><code>spv.IAdd</code> (spirv::IAddOp)</h3><p>Integer addition of Operand 1 and Operand 2.</p><p>Result Type must be a scalar or vector of integer type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
integer type. They must have the same number of components as Result
Type. They must have the same component width as Result Type.</p><p>The resulting value will equal the low-order N bits of the correct
result R, where N is the component width and R is computed with enough
precision to avoid overflow and underflow.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-71>Custom assembly form</h3><pre><code>integer-scalar-vector-type ::= integer-type |
                             `vector&lt;` integer-literal `x` integer-type `&gt;`
iadd-op ::= ssa-id `=` `spv.IAdd` ssa-use, ssa-use
                      `:` integer-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%4 = spv.IAdd %0, %1 : i32
%5 = spv.IAdd %2, %3 : vector&lt;4xi32&gt;

</code></pre><h4 id=operands-80>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h4 id=results-81>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h3 id=spviequal-spirviequalop><code>spv.IEqual</code> (spirv::IEqualOp)</h3><p>Integer comparison for equality.</p><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
integer type. They must have the same component width, and they must
have the same number of components as Result Type.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-72>Custom assembly form</h3><pre><code>integer-scalar-vector-type ::= integer-type |
                             `vector&lt;` integer-literal `x` integer-type `&gt;`
iequal-op ::= ssa-id `=` `spv.IEqual` ssa-use, ssa-use
                         `:` integer-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%4 = spv.IEqual %0, %1 : i32
%5 = spv.IEqual %2, %3 : vector&lt;4xi32&gt;

</code></pre><h4 id=operands-81>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h4 id=results-82>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>bool or vector of bool values of length 2/3/4</td></tr></tbody></table><h3 id=spvimul-spirvimulop><code>spv.IMul</code> (spirv::IMulOp)</h3><p>Integer multiplication of Operand 1 and Operand 2.</p><p>Result Type must be a scalar or vector of integer type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
integer type. They must have the same number of components as Result
Type. They must have the same component width as Result Type.</p><p>The resulting value will equal the low-order N bits of the correct
result R, where N is the component width and R is computed with enough
precision to avoid overflow and underflow.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-73>Custom assembly form</h3><pre><code>integer-scalar-vector-type ::= integer-type |
                             `vector&lt;` integer-literal `x` integer-type `&gt;`
imul-op ::= ssa-id `=` `spv.IMul` ssa-use, ssa-use
                      `:` integer-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%4 = spv.IMul %0, %1 : i32
%5 = spv.IMul %2, %3 : vector&lt;4xi32&gt;

</code></pre><h4 id=operands-82>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h4 id=results-83>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h3 id=spvinotequal-spirvinotequalop><code>spv.INotEqual</code> (spirv::INotEqualOp)</h3><p>Integer comparison for inequality.</p><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
integer type. They must have the same component width, and they must
have the same number of components as Result Type.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-74>Custom assembly form</h3><pre><code>integer-scalar-vector-type ::= integer-type |
                             `vector&lt;` integer-literal `x` integer-type `&gt;`
inot-equal-op ::= ssa-id `=` `spv.INotEqual` ssa-use, ssa-use
                             `:` integer-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%4 = spv.INotEqual %0, %1 : i32
%5 = spv.INotEqual %2, %3 : vector&lt;4xi32&gt;

</code></pre><h4 id=operands-83>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h4 id=results-84>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>bool or vector of bool values of length 2/3/4</td></tr></tbody></table><h3 id=spvisub-spirvisubop><code>spv.ISub</code> (spirv::ISubOp)</h3><p>Integer subtraction of Operand 2 from Operand 1.</p><p>Result Type must be a scalar or vector of integer type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
integer type. They must have the same number of components as Result
Type. They must have the same component width as Result Type.</p><p>The resulting value will equal the low-order N bits of the correct
result R, where N is the component width and R is computed with enough
precision to avoid overflow and underflow.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-75>Custom assembly form</h3><pre><code>integer-scalar-vector-type ::= integer-type |
                             `vector&lt;` integer-literal `x` integer-type `&gt;`
isub-op ::= `spv.ISub` ssa-use, ssa-use
                      `:` integer-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%4 = spv.ISub %0, %1 : i32
%5 = spv.ISub %2, %3 : vector&lt;4xi32&gt;

</code></pre><h4 id=operands-84>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h4 id=results-85>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h3 id=spvload-spirvloadop><code>spv.Load</code> (spirv::LoadOp)</h3><p>Load through a pointer.</p><p>Result Type is the type of the loaded object. It must be a type with
fixed size; i.e., it cannot be, nor include, any OpTypeRuntimeArray
types.</p><p>Pointer is the pointer to load through. Its type must be an
OpTypePointer whose Type operand is the same as Result Type.</p><p>If present, any Memory Operands must begin with a memory operand
literal. If not present, it is the same as specifying the memory operand
None.</p><h3 id=custom-assembly-form-76>Custom assembly form</h3><pre><code>memory-access ::= `&quot;None&quot;` | `&quot;Volatile&quot;` | `&quot;Aligned&quot;, ` integer-literal
                | `&quot;NonTemporal&quot;`

load-op ::= ssa-id ` = spv.Load ` storage-class ssa-use
            (`[` memory-access `]`)? ` : ` spirv-element-type
</code></pre><p>For example:</p><pre><code>%0 = spv.Variable : !spv.ptr&lt;f32, Function&gt;
%1 = spv.Load &quot;Function&quot; %0 : f32
%2 = spv.Load &quot;Function&quot; %0 [&quot;Volatile&quot;] : f32
%3 = spv.Load &quot;Function&quot; %0 [&quot;Aligned&quot;, 4] : f32
</code></pre><h4 id=attributes-35>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>memory_access</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V MemoryAccess</td></tr><tr><td align=center><code>alignment</code></td><td align=center>IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-85>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>ptr</code></td><td>any SPIR-V pointer type</td></tr></tbody></table><h4 id=results-86>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td>void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float values of length 2/3/4 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type</td></tr></tbody></table><h3 id=spvlogicaland-spirvlogicalandop><code>spv.LogicalAnd</code> (spirv::LogicalAndOp)</h3><pre><code>Result is true if both Operand 1 and Operand 2 are true. Result is false
if either Operand 1 or Operand 2 are false.
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 must be the same as Result Type.</p><p>The type of Operand 2 must be the same as Result Type.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-77>Custom assembly form</h3><pre><code>logical-and ::= `spv.LogicalAnd` ssa-use `,` ssa-use
                `:` operand-type
</code></pre><p>For example:</p><pre><code>%2 = spv.LogicalAnd %0, %1 : i1
%2 = spv.LogicalAnd %0, %1 : vector&lt;4xi1&gt;
</code></pre><h4 id=operands-86>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>bool or vector of bool values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>bool or vector of bool values of length 2/3/4</td></tr></tbody></table><h4 id=results-87>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>bool or vector of bool values of length 2/3/4</td></tr></tbody></table><h3 id=spvlogicalequal-spirvlogicalequalop><code>spv.LogicalEqual</code> (spirv::LogicalEqualOp)</h3><pre><code>Result is true if Operand 1 and Operand 2 have the same value. Result is
false if Operand 1 and Operand 2 have different values.
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 must be the same as Result Type.</p><p>The type of Operand 2 must be the same as Result Type.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-78>Custom assembly form</h3><pre><code>logical-equal ::= `spv.LogicalEqual` ssa-use `,` ssa-use
                  `:` operand-type
</code></pre><p>For example:</p><pre><code>%2 = spv.LogicalEqual %0, %1 : i1
%2 = spv.LogicalEqual %0, %1 : vector&lt;4xi1&gt;
</code></pre><h4 id=operands-87>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>bool or vector of bool values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>bool or vector of bool values of length 2/3/4</td></tr></tbody></table><h4 id=results-88>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>bool or vector of bool values of length 2/3/4</td></tr></tbody></table><h3 id=spvlogicalnotequal-spirvlogicalnotequalop><code>spv.LogicalNotEqual</code> (spirv::LogicalNotEqualOp)</h3><pre><code>Result is true if Operand 1 and Operand 2 have different values. Result
is false if Operand 1 and Operand 2 have the same value.
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 must be the same as Result Type.</p><p>The type of Operand 2 must be the same as Result Type.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-79>Custom assembly form</h3><pre><code>logical-not-equal ::= `spv.LogicalNotEqual` ssa-use `,` ssa-use
                      `:` operand-type
</code></pre><p>For example:</p><pre><code>%2 = spv.LogicalNotEqual %0, %1 : i1
%2 = spv.LogicalNotEqual %0, %1 : vector&lt;4xi1&gt;
</code></pre><h4 id=operands-88>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>bool or vector of bool values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>bool or vector of bool values of length 2/3/4</td></tr></tbody></table><h4 id=results-89>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>bool or vector of bool values of length 2/3/4</td></tr></tbody></table><h3 id=spvlogicalnot-spirvlogicalnotop><code>spv.LogicalNot</code> (spirv::LogicalNotOp)</h3><pre><code>Result is true if Operand is false.  Result is false if Operand is true.
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand must be the same as Result Type.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-80>Custom assembly form</h3><pre><code>logical-not ::= `spv.LogicalNot` ssa-use `:` operand-type
</code></pre><p>For example:</p><pre><code>%2 = spv.LogicalNot %0 : i1
%2 = spv.LogicalNot %0 : vector&lt;4xi1&gt;
</code></pre><h4 id=operands-89>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>bool or vector of bool values of length 2/3/4</td></tr></tbody></table><h4 id=results-90>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>bool or vector of bool values of length 2/3/4</td></tr></tbody></table><h3 id=spvlogicalor-spirvlogicalorop><code>spv.LogicalOr</code> (spirv::LogicalOrOp)</h3><pre><code>Result is true if either Operand 1 or Operand 2 is true. Result is false
if both Operand 1 and Operand 2 are false.
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 must be the same as Result Type.</p><p>The type of Operand 2 must be the same as Result Type.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-81>Custom assembly form</h3><pre><code>logical-or ::= `spv.LogicalOr` ssa-use `,` ssa-use
                `:` operand-type
</code></pre><p>For example:</p><pre><code>%2 = spv.LogicalOr %0, %1 : i1
%2 = spv.LogicalOr %0, %1 : vector&lt;4xi1&gt;
</code></pre><h4 id=operands-90>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>bool or vector of bool values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>bool or vector of bool values of length 2/3/4</td></tr></tbody></table><h4 id=results-91>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>bool or vector of bool values of length 2/3/4</td></tr></tbody></table><h3 id=spvloop-spirvloopop><code>spv.loop</code> (spirv::LoopOp)</h3><p>Define a structured loop.</p><p>SPIR-V can explicitly declare structured control-flow constructs using merge
instructions. These explicitly declare a header block before the control
flow diverges and a merge block where control flow subsequently converges.
These blocks delimit constructs that must nest, and can only be entered
and exited in structured ways. See &ldquo;2.11. Structured Control Flow&rdquo; of the
SPIR-V spec for more details.</p><p>Instead of having a <code>spv.LoopMerge</code> op to directly model loop merge
instruction for indicating the merge and continue target, we use regions
to delimit the boundary of the loop: the merge target is the next op
following the <code>spv.loop</code> op and the continue target is the block that
has a back-edge pointing to the entry block inside the <code>spv.loop</code>'s region.
This way it&rsquo;s easier to discover all blocks belonging to a construct and
it plays nicer with the MLIR system.</p><p>The <code>spv.loop</code> region should contain at least four blocks: one entry block,
one loop header block, one loop continue block, one loop merge block.
The entry block should be the first block and it should jump to the loop
header block, which is the second block. The loop merge block should be the
last block. The merge block should only contain a <code>spv._merge</code> op.
The continue block should be the second to last block and it should have a
branch to the loop header block. The loop continue block should be the only
block, except the entry block, branching to the header block.</p><h4 id=attributes-36>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>loop_control</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V LoopControl</td></tr></tbody></table><h3 id=spvmemorybarrier-spirvmemorybarrierop><code>spv.MemoryBarrier</code> (spirv::MemoryBarrierOp)</h3><p>Control the order that memory accesses are observed.</p><p>Syntax:</p><pre><code>operation ::= `spv.MemoryBarrier` $memory_scope `,` $memory_semantics attr-dict
</code></pre><p>Ensures that memory accesses issued before this instruction will be
observed before memory accesses issued after this instruction. This
control is ensured only for memory accesses issued by this invocation
and observed by another invocation executing within Memory scope. If the
Vulkan memory model is declared, this ordering only applies to memory
accesses that use the NonPrivatePointer memory operand or
NonPrivateTexel image operand.</p><p>Semantics declares what kind of memory is being controlled and what kind
of control to apply.</p><p>To execute both a memory barrier and a control barrier, see
OpControlBarrier.</p><h3 id=custom-assembly-form-82>Custom assembly form</h3><pre><code>scope ::= `&quot;CrossDevice&quot;` | `&quot;Device&quot;` | `&quot;Workgroup&quot;` | ...

memory-semantics ::= `&quot;None&quot;` | `&quot;Acquire&quot;` | `&quot;Release&quot;` | ...

memory-barrier-op ::= `spv.MemoryBarrier` scope, memory-semantics
</code></pre><p>For example:</p><pre><code>spv.MemoryBarrier &quot;Device&quot;, &quot;Acquire|UniformMemory&quot;

</code></pre><h4 id=attributes-37>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>memory_scope</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V Scope</td></tr><tr><td align=center><code>memory_semantics</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V MemorySemantics</td></tr></tbody></table><h3 id=spv_merge-spirvmergeop><code>spv._merge</code> (spirv::MergeOp)</h3><p>A special terminator for merging a structured selection/loop.</p><p>Syntax:</p><pre><code>operation ::= `spv._merge` attr-dict
</code></pre><p>We use <code>spv.selection</code>/<code>spv.loop</code> for modelling structured selection/loop.
This op is a terminator used inside their regions to mean jumping to the
merge point, which is the next op following the <code>spv.selection</code> or
<code>spv.loop</code> op. This op does not have a corresponding instruction in the
SPIR-V binary format; it&rsquo;s solely for structural purpose.</p><h3 id=spv_module_end-spirvmoduleendop><code>spv._module_end</code> (spirv::ModuleEndOp)</h3><p>The pseudo op that ends a SPIR-V module</p><p>Syntax:</p><pre><code>operation ::= `spv._module_end` attr-dict
</code></pre><p>This op terminates the only block inside a <code>spv.module</code>'s only region.
This op does not have a corresponding SPIR-V instruction and thus will
not be serialized into the binary format; it is used solely to satisfy
the structual requirement that an block must be ended with a terminator.</p><h3 id=spvmodule-spirvmoduleop><code>spv.module</code> (spirv::ModuleOp)</h3><p>The top-level op that defines a SPIR-V module</p><p>This op defines a SPIR-V module using a MLIR region. The region contains
one block. Module-level operations, including functions definitions,
are all placed in this block.</p><p>Using an op with a region to define a SPIR-V module enables &ldquo;embedding&rdquo;
SPIR-V modules in other dialects in a clean manner: this op guarantees
the validity and serializability of a SPIR-V module and thus serves as
a clear-cut boundary.</p><p>This op takes no operands and generates no results. This op should not
implicitly capture values from the enclosing environment.</p><p>This op has only one region, which only contains one block. The block
must be terminated via the <code>spv._module_end</code> op.</p><h3 id=custom-assembly-form-83>Custom assembly form</h3><pre><code>addressing-model ::= `Logical` | `Physical32` | `Physical64` | ...
memory-model ::= `Simple` | `GLSL450` | `OpenCL` | `Vulkan` | ...
spv-module-op ::= `spv.module` addressing-model memory-model
                  (requires  spirv-vce-attribute)?
                  (`attributes` attribute-dict)?
                  region
</code></pre><p>For example:</p><pre><code>spv.module Logical GLSL450  {}

spv.module Logical Vulkan
    requires #spv.vce&lt;v1.0, [Shader], [SPV_KHR_vulkan_memory_model]&gt;
    attributes { some_additional_attr = ... } {
  spv.func @do_nothing() -&gt; () {
    spv.Return
  }
}
</code></pre><h4 id=attributes-38>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>addressing_model</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V AddressingModel</td></tr><tr><td align=center><code>memory_model</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V MemoryModel</td></tr><tr><td align=center><code>vce_triple</code></td><td align=center>::mlir::spirv::VerCapExtAttr</td><td>version-capability-extension attribute</td></tr></tbody></table><h3 id=spvnot-spirvnotop><code>spv.Not</code> (spirv::NotOp)</h3><p>Complement the bits of Operand.</p><p>Results are computed per component, and within each component, per bit.</p><p>Result Type must be a scalar or vector of integer type.</p><p>Operand’s type must be a scalar or vector of integer type. It must
have the same number of components as Result Type. The component width
must equal the component width in Result Type.</p><h3 id=custom-assembly-form-84>Custom assembly form</h3><pre><code>integer-scalar-vector-type ::= integer-type |
                              `vector&lt;` integer-literal `x` integer-type `&gt;`
not-op ::= ssa-id `=` `spv.BitNot` ssa-use `:` integer-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%2 = spv.Not %0 : i32
%3 = spv.Not %1 : vector&lt;4xi32&gt;
</code></pre><h4 id=operands-91>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h4 id=results-92>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h3 id=spv_reference_of-spirvreferenceofop><code>spv._reference_of</code> (spirv::ReferenceOfOp)</h3><p>Reference a specialization constant.</p><p>Syntax:</p><pre><code>operation ::= `spv._reference_of` $spec_const attr-dict `:` type($reference)
</code></pre><p>Specialization constant in module scope are defined using symbol names.
This op generates an SSA value that can be used to refer to the symbol
within function scope for use in ops that expect an SSA value.
This operation has no corresponding SPIR-V instruction; it&rsquo;s merely used
for modelling purpose in the SPIR-V dialect. This op&rsquo;s return type is
the same as the specialization constant.</p><h3 id=custom-assembly-form-85>Custom assembly form</h3><pre><code>spv-reference-of-op ::= ssa-id `=` `spv._reference_of` symbol-ref-id
                                   `:` spirv-scalar-type
</code></pre><p>For example:</p><pre><code>%0 = spv._reference_of @spec_const : f32
</code></pre><h4 id=attributes-39>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>spec_const</code></td><td align=center>FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></tbody></table><h4 id=results-93>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>reference</code></td><td>void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float values of length 2/3/4 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type</td></tr></tbody></table><h3 id=spvreturn-spirvreturnop><code>spv.Return</code> (spirv::ReturnOp)</h3><p>Return with no value from a function with void return type.</p><p>Syntax:</p><pre><code>operation ::= `spv.Return` attr-dict
</code></pre><p>This instruction must be the last instruction in a block.</p><h3 id=custom-assembly-form-86>Custom assembly form</h3><pre><code>return-op ::= `spv.Return`
</code></pre><h3 id=spvreturnvalue-spirvreturnvalueop><code>spv.ReturnValue</code> (spirv::ReturnValueOp)</h3><p>Return a value from a function.</p><p>Syntax:</p><pre><code>operation ::= `spv.ReturnValue` $value attr-dict `:` type($value)
</code></pre><p>Value is the value returned, by copy, and must match the Return Type
operand of the OpTypeFunction type of the OpFunction body this return
instruction is in.</p><p>This instruction must be the last instruction in a block.</p><h3 id=custom-assembly-form-87>Custom assembly form</h3><pre><code>return-value-op ::= `spv.ReturnValue` ssa-use `:` spirv-type
</code></pre><p>For example:</p><pre><code>spv.ReturnValue %0 : f32
</code></pre><h4 id=operands-92>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td>void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float values of length 2/3/4 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type</td></tr></tbody></table><h3 id=spvsconvert-spirvsconvertop><code>spv.SConvert</code> (spirv::SConvertOp)</h3><pre><code>Convert signed width.  This is either a truncate or a sign extend.
</code></pre><p>Result Type must be a scalar or vector of integer type.</p><p>Signed Value must be a scalar or vector of integer type. It must have
the same number of components as Result Type. The component width
cannot equal the component width in Result Type.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-88>Custom assembly form</h3><pre><code>s-convert-op ::= ssa-id `=` `spv.SConvertOp` ssa-use
                 `:` operand-type `to` result-type
</code></pre><p>For example:</p><pre><code>%1 = spv.SConvertOp %0 : i32 to i64
%3 = spv.SConvertOp %2 : vector&lt;3xi32&gt; to vector&lt;3xi64&gt;
</code></pre><h4 id=operands-93>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h4 id=results-94>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h3 id=spvsdiv-spirvsdivop><code>spv.SDiv</code> (spirv::SDivOp)</h3><p>Signed-integer division of Operand 1 divided by Operand 2.</p><p>Result Type must be a scalar or vector of integer type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
integer type. They must have the same number of components as Result
Type. They must have the same component width as Result Type.</p><p>Results are computed per component. The resulting value is undefined
if Operand 2 is 0.</p><h3 id=custom-assembly-form-89>Custom assembly form</h3><pre><code>integer-scalar-vector-type ::= integer-type |
                             `vector&lt;` integer-literal `x` integer-type `&gt;`
sdiv-op ::= ssa-id `=` `spv.SDiv` ssa-use, ssa-use
                       `:` integer-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%4 = spv.SDiv %0, %1 : i32
%5 = spv.SDiv %2, %3 : vector&lt;4xi32&gt;

</code></pre><h4 id=operands-94>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h4 id=results-95>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h3 id=spvsgreaterthanequal-spirvsgreaterthanequalop><code>spv.SGreaterThanEqual</code> (spirv::SGreaterThanEqualOp)</h3><pre><code>Signed-integer comparison if Operand 1 is greater than or equal to
Operand 2.
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
integer type. They must have the same component width, and they must
have the same number of components as Result Type.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-90>Custom assembly form</h3><pre><code>integer-scalar-vector-type ::= integer-type |
                             `vector&lt;` integer-literal `x` integer-type `&gt;`
sgreater-than-equal-op ::= ssa-id `=` `spv.SGreaterThanEqual` ssa-use, ssa-use
                                      `:` integer-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%4 = spv.SGreaterThanEqual %0, %1 : i32
%5 = spv.SGreaterThanEqual %2, %3 : vector&lt;4xi32&gt;

</code></pre><h4 id=operands-95>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h4 id=results-96>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>bool or vector of bool values of length 2/3/4</td></tr></tbody></table><h3 id=spvsgreaterthan-spirvsgreaterthanop><code>spv.SGreaterThan</code> (spirv::SGreaterThanOp)</h3><pre><code>Signed-integer comparison if Operand 1 is greater than  Operand 2.
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
integer type. They must have the same component width, and they must
have the same number of components as Result Type.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-91>Custom assembly form</h3><pre><code>integer-scalar-vector-type ::= integer-type |
                             `vector&lt;` integer-literal `x` integer-type `&gt;`
sgreater-than-op ::= ssa-id `=` `spv.SGreaterThan` ssa-use, ssa-use
                                `:` integer-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%4 = spv.SGreaterThan %0, %1 : i32
%5 = spv.SGreaterThan %2, %3 : vector&lt;4xi32&gt;

</code></pre><h4 id=operands-96>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h4 id=results-97>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>bool or vector of bool values of length 2/3/4</td></tr></tbody></table><h3 id=spvslessthanequal-spirvslessthanequalop><code>spv.SLessThanEqual</code> (spirv::SLessThanEqualOp)</h3><pre><code>Signed-integer comparison if Operand 1 is less than or equal to Operand
2.
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
integer type. They must have the same component width, and they must
have the same number of components as Result Type.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-92>Custom assembly form</h3><pre><code>integer-scalar-vector-type ::= integer-type |
                             `vector&lt;` integer-literal `x` integer-type `&gt;`
sless-than-equal-op ::= ssa-id `=` `spv.SLessThanEqual` ssa-use, ssa-use
                                   `:` integer-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%4 = spv.SLessThanEqual %0, %1 : i32
%5 = spv.SLessThanEqual %2, %3 : vector&lt;4xi32&gt;

</code></pre><h4 id=operands-97>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h4 id=results-98>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>bool or vector of bool values of length 2/3/4</td></tr></tbody></table><h3 id=spvslessthan-spirvslessthanop><code>spv.SLessThan</code> (spirv::SLessThanOp)</h3><pre><code>Signed-integer comparison if Operand 1 is less than Operand 2.
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
integer type. They must have the same component width, and they must
have the same number of components as Result Type.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-93>Custom assembly form</h3><pre><code>integer-scalar-vector-type ::= integer-type |
                             `vector&lt;` integer-literal `x` integer-type `&gt;`
sless-than-op ::= ssa-id `=` `spv.SLessThan` ssa-use, ssa-use
                             `:` integer-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%4 = spv.SLessThan %0, %1 : i32
%5 = spv.SLessThan %2, %3 : vector&lt;4xi32&gt;

</code></pre><h4 id=operands-98>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h4 id=results-99>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>bool or vector of bool values of length 2/3/4</td></tr></tbody></table><h3 id=spvsmod-spirvsmodop><code>spv.SMod</code> (spirv::SModOp)</h3><pre><code>Signed remainder operation for the remainder whose sign matches the sign
of Operand 2.
</code></pre><p>Result Type must be a scalar or vector of integer type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
integer type. They must have the same number of components as Result
Type. They must have the same component width as Result Type.</p><p>Results are computed per component. The resulting value is undefined
if Operand 2 is 0. Otherwise, the result is the remainder r of Operand
1 divided by Operand 2 where if r ≠ 0, the sign of r is the same as the
sign of Operand 2.</p><h3 id=custom-assembly-form-94>Custom assembly form</h3><pre><code>integer-scalar-vector-type ::= integer-type |
                             `vector&lt;` integer-literal `x` integer-type `&gt;`
smod-op ::= ssa-id `=` `spv.SMod` ssa-use, ssa-use
                       `:` integer-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%4 = spv.SMod %0, %1 : i32
%5 = spv.SMod %2, %3 : vector&lt;4xi32&gt;

</code></pre><h4 id=operands-99>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h4 id=results-100>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h3 id=spvsrem-spirvsremop><code>spv.SRem</code> (spirv::SRemOp)</h3><pre><code>Signed remainder operation for the remainder whose sign matches the sign
of Operand 1.
</code></pre><p>Result Type must be a scalar or vector of integer type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
integer type. They must have the same number of components as Result
Type. They must have the same component width as Result Type.</p><p>Results are computed per component. The resulting value is undefined
if Operand 2 is 0. Otherwise, the result is the remainder r of Operand
1 divided by Operand 2 where if r ≠ 0, the sign of r is the same as the
sign of Operand 1.</p><h3 id=custom-assembly-form-95>Custom assembly form</h3><pre><code>integer-scalar-vector-type ::= integer-type |
                             `vector&lt;` integer-literal `x` integer-type `&gt;`
srem-op ::= ssa-id `=` `spv.SRem` ssa-use, ssa-use
                       `:` integer-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%4 = spv.SRem %0, %1 : i32
%5 = spv.SRem %2, %3 : vector&lt;4xi32&gt;

</code></pre><h4 id=operands-100>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h4 id=results-101>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h3 id=spvselect-spirvselectop><code>spv.Select</code> (spirv::SelectOp)</h3><pre><code>Select between two objects. Before version 1.4, results are only
computed per component.
</code></pre><p>Syntax:</p><pre><code>operation ::= `spv.Select` operands attr-dict `:` type($condition) `,` type($result)
</code></pre><p>Before version 1.4, Result Type must be a pointer, scalar, or vector.</p><p>The types of Object 1 and Object 2 must be the same as Result Type.</p><p>Condition must be a scalar or vector of Boolean type.</p><p>If Condition is a scalar and true, the result is Object 1. If Condition
is a scalar and false, the result is Object 2.</p><p>If Condition is a vector, Result Type must be a vector with the same
number of components as Condition and the result is a mix of Object 1
and Object 2: When a component of Condition is true, the corresponding
component in the result is taken from Object 1, otherwise it is taken
from Object 2.</p><h3 id=custom-assembly-form-96>Custom assembly form</h3><pre><code>scalar-type ::= integer-type | float-type | boolean-type
select-object-type ::= scalar-type
                       | `vector&lt;` integer-literal `x` scalar-type `&gt;`
                       | pointer-type
select-condition-type ::= boolean-type
                          | `vector&lt;` integer-literal `x` boolean-type `&gt;`
select-op ::= ssa-id `=` `spv.Select` ssa-use, ssa-use, ssa-use
              `:` select-condition-type `,` select-object-type
</code></pre><p>For example:</p><pre><code>%3 = spv.Select %0, %1, %2 : i1, f32
%3 = spv.Select %0, %1, %2 : i1, vector&lt;3xi32&gt;
%3 = spv.Select %0, %1, %2 : vector&lt;3xi1&gt;, vector&lt;3xf32&gt;
</code></pre><h4 id=operands-101>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>condition</code></td><td>bool or vector of bool values of length 2/3/4</td></tr><tr><td align=center><code>true_value</code></td><td>8/16/32/64-bit integer or 16/32/64-bit float or bool or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float values of length 2/3/4 or any SPIR-V pointer type</td></tr><tr><td align=center><code>false_value</code></td><td>8/16/32/64-bit integer or 16/32/64-bit float or bool or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float values of length 2/3/4 or any SPIR-V pointer type</td></tr></tbody></table><h4 id=results-102>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer or 16/32/64-bit float or bool or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float values of length 2/3/4 or any SPIR-V pointer type</td></tr></tbody></table><h3 id=spvselection-spirvselectionop><code>spv.selection</code> (spirv::SelectionOp)</h3><p>Define a structured selection.</p><p>SPIR-V can explicitly declare structured control-flow constructs using merge
instructions. These explicitly declare a header block before the control
flow diverges and a merge block where control flow subsequently converges.
These blocks delimit constructs that must nest, and can only be entered
and exited in structured ways. See &ldquo;2.11. Structured Control Flow&rdquo; of the
SPIR-V spec for more details.</p><p>Instead of having a <code>spv.SelectionMerge</code> op to directly model selection
merge instruction for indicating the merge target, we use regions to delimit
the boundary of the selection: the merge target is the next op following the
<code>spv.selection</code> op. This way it&rsquo;s easier to discover all blocks belonging to
the selection and it plays nicer with the MLIR system.</p><p>The <code>spv.selection</code> region should contain at least two blocks: one selection
header block, and one selection merge. The selection header block should be
the first block. The selection merge block should be the last block.
The merge block should only contain a <code>spv._merge</code> op.</p><h4 id=attributes-40>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>selection_control</code></td><td align=center>IntegerAttr</td><td>valid SPIR-V SelectionControl</td></tr></tbody></table><h3 id=spvshiftleftlogical-spirvshiftleftlogicalop><code>spv.ShiftLeftLogical</code> (spirv::ShiftLeftLogicalOp)</h3><pre><code>Shift the bits in Base left by the number of bits specified in Shift.
The least-significant bits will be zero filled.
</code></pre><p>Result Type must be a scalar or vector of integer type.</p><p>The type of each Base and Shift must be a scalar or vector of integer
type. Base and Shift must have the same number of components. The
number of components and bit width of the type of Base must be the same
as in Result Type.</p><p>Shift is treated as unsigned. The result is undefined if Shift is
greater than or equal to the bit width of the components of Base.</p><p>The number of components and bit width of Result Type must match those
Base type. All types must be integer types.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-97>Custom assembly form</h3><pre><code>integer-scalar-vector-type ::= integer-type |
                              `vector&lt;` integer-literal `x` integer-type `&gt;`
shift-left-logical-op ::= ssa-id `=` `spv.ShiftLeftLogical`
                                      ssa-use `,` ssa-use `:`
                                      integer-scalar-vector-type `,`
                                      integer-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%2 = spv.ShiftLeftLogical %0, %1 : i32, i16
%5 = spv.ShiftLeftLogical %3, %4 : vector&lt;3xi32&gt;, vector&lt;3xi16&gt;
</code></pre><h4 id=operands-102>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h4 id=results-103>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h3 id=spvshiftrightarithmetic-spirvshiftrightarithmeticop><code>spv.ShiftRightArithmetic</code> (spirv::ShiftRightArithmeticOp)</h3><pre><code>Shift the bits in Base right by the number of bits specified in Shift.
The most-significant bits will be filled with the sign bit from Base.
</code></pre><p>Result Type must be a scalar or vector of integer type.</p><p>The type of each Base and Shift must be a scalar or vector of integer
type. Base and Shift must have the same number of components. The
number of components and bit width of the type of Base must be the same
as in Result Type.</p><p>Shift is treated as unsigned. The result is undefined if Shift is
greater than or equal to the bit width of the components of Base.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-98>Custom assembly form</h3><pre><code>integer-scalar-vector-type ::= integer-type |
                              `vector&lt;` integer-literal `x` integer-type `&gt;`
shift-right-arithmetic-op ::= ssa-id `=` `spv.ShiftRightArithmetic`
                                          ssa-use `,` ssa-use `:`
                                          integer-scalar-vector-type `,`
                                          integer-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%2 = spv.ShiftRightArithmetic %0, %1 : i32, i16
%5 = spv.ShiftRightArithmetic %3, %4 : vector&lt;3xi32&gt;, vector&lt;3xi16&gt;
</code></pre><h4 id=operands-103>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h4 id=results-104>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h3 id=spvshiftrightlogical-spirvshiftrightlogicalop><code>spv.ShiftRightLogical</code> (spirv::ShiftRightLogicalOp)</h3><pre><code>Shift the bits in Base right by the number of bits specified in Shift.
The most-significant bits will be zero filled.
</code></pre><p>Result Type must be a scalar or vector of integer type.</p><p>The type of each Base and Shift must be a scalar or vector of integer
type. Base and Shift must have the same number of components. The
number of components and bit width of the type of Base must be the same
as in Result Type.</p><p>Shift is consumed as an unsigned integer. The result is undefined if
Shift is greater than or equal to the bit width of the components of
Base.</p><p>Results are computed per component.</p><h3 id=custom-assembly-form-99>Custom assembly form</h3><pre><code>integer-scalar-vector-type ::= integer-type |
                              `vector&lt;` integer-literal `x` integer-type `&gt;`
shift-right-logical-op ::= ssa-id `=` `spv.ShiftRightLogical`
                                       ssa-use `,` ssa-use `:`
                                       integer-scalar-vector-type `,`
                                       integer-scalar-vector-type
</code></pre><p>For example:</p><pre><code>%2 = spv.ShiftRightLogical %0, %1 : i32, i16
%5 = spv.ShiftRightLogical %3, %4 : vector&lt;3xi32&gt;, vector&lt;3xi16&gt;
</code></pre><h4 id=operands-104>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand1</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr><tr><td align=center><code>operand2</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h4 id=results-105>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4</td></tr></tbody></table><h3 id=spvspecconstant-spirvspecconstantop><code>spv.specConstant</code> (spirv::SpecConstantOp)</h3><p>The op that declares a SPIR-V specialization constant</p><p>This op declares a SPIR-V scalar specialization constant. SPIR-V has
multiple constant instructions covering different scalar types:</p><ul><li><code>OpSpecConstantTrue</code> and <code>OpSpecConstantFalse</code> for boolean constants</li><li><code>OpSpecConstant</code> for scalar constants</li></ul><p>Similar as <code>spv.constant</code>, this op represents all of the above cases.
<code>OpSpecConstantComposite</code> and <code>OpSpecConstantOp</code> are modelled with
separate ops.</p><h3 id=custom-assembly-form-100>Custom assembly form</h3><pre><code>spv-spec-constant-op ::= `spv.specConstant` symbol-ref-id
                         `spec_id(` integer `)`
                         `=` attribute-value (`:` spirv-type)?
</code></pre><p>where <code>spec_id</code> specifies the SPIR-V SpecId decoration associated with
the op.</p><p>For example:</p><pre><code>spv.specConstant @spec_const1 = true
spv.specConstant @spec_const2 spec_id(5) = 42 : i32
</code></pre><p>TODO(antiagainst): support composite spec constants with another op</p><h4 id=attributes-41>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>sym_name</code></td><td align=center>StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>default_value</code></td><td align=center>Attribute</td><td>any attribute</td></tr></tbody></table><h3 id=spvstore-spirvstoreop><code>spv.Store</code> (spirv::StoreOp)</h3><p>Store through a pointer.</p><p>Pointer is the pointer to store through. Its type must be an
OpTypePointer whose Type operand is the same as the type of Object.</p><p>Object is the object to store.</p><p>If present, any Memory Operands must begin with a memory operand
literal. If not present, it is the same as specifying the memory operand
None.</p><h3 id=custom-assembly-form-101>Custom assembly form</h3><pre><code>store-op ::= `spv.Store ` storage-class ssa-use `, ` ssa-use `, `
              (`[` memory-access `]`)? `:` spirv-element-type
</code></pre><p>For example:</p><pre><code>%0 = spv.Variable : !spv.ptr&lt;f32, Function&gt;
%1 = spv.FMul ... : f32
spv.Store &quot;Function&quot; %0, %1 : f32
spv.Store &quot;Function&quot; %0, %1 [&quot;Volatile&quot;] : f32
spv.Store &quot;Function&quot; %0, %1 [&quot;Aligned&quot;, 4] : f32

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`memory_access` | IntegerAttr | valid SPIR-V MemoryAccess
`alignment` | IntegerAttr | 32-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`ptr` | any SPIR-V pointer type
`value` | void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float values of length 2/3/4 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type

### `spv.SubgroupBallotKHR` (spirv::SubgroupBallotKHROp)

See extension SPV_KHR_shader_ballot

Syntax:

</code></pre><p>operation ::= <code>spv.SubgroupBallotKHR</code> $predicate attr-dict <code>:</code> type($result)</p><pre><code>

Computes a bitfield value combining the Predicate value from all invocations
in the current Subgroup that execute the same dynamic instance of this
instruction. The bit is set to one if the corresponding invocation is active
and the predicate is evaluated to true; otherwise, it is set to zero.

Predicate must be a Boolean type.

Result Type must be a 4 component vector of 32 bit integer types.

Result is a set of bitfields where the first invocation is represented in bit
0 of the first vector component and the last (up to SubgroupSize) is the
higher bit number of the last bitmask needed to represent all bits of the
subgroup invocations.

### Custom assembly form

</code></pre><p>subgroup-ballot-op ::= ssa-id <code>=</code> <code>spv.SubgroupBallotKHR</code>
ssa-use <code>:</code> <code>vector</code> <code>&lt;</code> 4 <code>x</code> <code>i32</code> <code>></code></p><pre><code>
For example:

</code></pre><p>%0 = spv.SubgroupBallotKHR %predicate : vector&lt;4xi32></p><pre><code>
#### Operands:

| Operand | Description |
| :-----: | ----------- |
`predicate` | bool

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | vector of 32-bit integer values of length 4

### `spv.UConvert` (spirv::UConvertOp)


    Convert unsigned width. This is either a truncate or a zero extend.
  

Result Type must be a scalar or vector of integer type, whose Signedness
operand is 0.

Unsigned Value must be a scalar or vector of integer type.  It must have
the same number of components as Result Type.  The component width
cannot equal the component width in Result Type.

 Results are computed per component.

### Custom assembly form

</code></pre><p>u-convert-op ::= ssa-id <code>=</code> <code>spv.UConvertOp</code> ssa-use
<code>:</code> operand-type <code>to</code> result-type</p><pre><code>
For example:

</code></pre><p>%1 = spv.UConvertOp %0 : i32 to i64
%3 = spv.UConvertOp %2 : vector&lt;3xi32> to vector&lt;3xi64></p><pre><code>
#### Operands:

| Operand | Description |
| :-----: | ----------- |
`operand` | 8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | 8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4

### `spv.UDiv` (spirv::UDivOp)

Unsigned-integer division of Operand 1 divided by Operand 2.

Result Type must be a scalar or vector of integer type, whose Signedness
operand is 0.

 The types of Operand 1 and Operand 2 both must be the same as Result
Type.

 Results are computed per component.  The resulting value is undefined
if Operand 2 is 0.

### Custom assembly form
</code></pre><p>integer-scalar-vector-type ::= integer-type |
<code>vector&lt;</code> integer-literal <code>x</code> integer-type <code>></code>
udiv-op ::= ssa-id <code>=</code> <code>spv.UDiv</code> ssa-use, ssa-use
<code>:</code> integer-scalar-vector-type</p><pre><code>For example:

</code></pre><p>%4 = spv.UDiv %0, %1 : i32
%5 = spv.UDiv %2, %3 : vector&lt;4xi32></p><pre><code>
#### Operands:

| Operand | Description |
| :-----: | ----------- |
`operand1` | 8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4
`operand2` | 8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | 8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4

### `spv.UGreaterThanEqual` (spirv::UGreaterThanEqualOp)


    Unsigned-integer comparison if Operand 1 is greater than or equal to
    Operand 2.
  

Result Type must be a scalar or vector of Boolean type.

 The type of Operand 1 and Operand 2  must be a scalar or vector of
integer type.  They must have the same component width, and they must
have the same number of components as Result Type.

 Results are computed per component.

### Custom assembly form
</code></pre><p>integer-scalar-vector-type ::= integer-type |
<code>vector&lt;</code> integer-literal <code>x</code> integer-type <code>></code>
ugreater-than-equal-op ::= ssa-id <code>=</code> <code>spv.UGreaterThanEqual</code> ssa-use, ssa-use
<code>:</code> integer-scalar-vector-type</p><pre><code>For example:

</code></pre><p>%4 = spv.UGreaterThanEqual %0, %1 : i32
%5 = spv.UGreaterThanEqual %2, %3 : vector&lt;4xi32></p><pre><code>
#### Operands:

| Operand | Description |
| :-----: | ----------- |
`operand1` | 8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4
`operand2` | 8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | bool or vector of bool values of length 2/3/4

### `spv.UGreaterThan` (spirv::UGreaterThanOp)


    Unsigned-integer comparison if Operand 1 is greater than  Operand 2.
  

Result Type must be a scalar or vector of Boolean type.

 The type of Operand 1 and Operand 2  must be a scalar or vector of
integer type.  They must have the same component width, and they must
have the same number of components as Result Type.

 Results are computed per component.

### Custom assembly form
</code></pre><p>integer-scalar-vector-type ::= integer-type |
<code>vector&lt;</code> integer-literal <code>x</code> integer-type <code>></code>
ugreater-than-op ::= ssa-id <code>=</code> <code>spv.UGreaterThan</code> ssa-use, ssa-use
<code>:</code> integer-scalar-vector-type</p><pre><code>For example:

</code></pre><p>%4 = spv.UGreaterThan %0, %1 : i32
%5 = spv.UGreaterThan %2, %3 : vector&lt;4xi32></p><pre><code>
#### Operands:

| Operand | Description |
| :-----: | ----------- |
`operand1` | 8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4
`operand2` | 8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | bool or vector of bool values of length 2/3/4

### `spv.ULessThanEqual` (spirv::ULessThanEqualOp)


    Unsigned-integer comparison if Operand 1 is less than or equal to
    Operand 2.
  

Result Type must be a scalar or vector of Boolean type.

 The type of Operand 1 and Operand 2  must be a scalar or vector of
integer type.  They must have the same component width, and they must
have the same number of components as Result Type.

 Results are computed per component.

### Custom assembly form
</code></pre><p>integer-scalar-vector-type ::= integer-type |
<code>vector&lt;</code> integer-literal <code>x</code> integer-type <code>></code>
uless-than-equal-op ::= ssa-id <code>=</code> <code>spv.ULessThanEqual</code> ssa-use, ssa-use
<code>:</code> integer-scalar-vector-type</p><pre><code>For example:

</code></pre><p>%4 = spv.ULessThanEqual %0, %1 : i32
%5 = spv.ULessThanEqual %2, %3 : vector&lt;4xi32></p><pre><code>
#### Operands:

| Operand | Description |
| :-----: | ----------- |
`operand1` | 8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4
`operand2` | 8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | bool or vector of bool values of length 2/3/4

### `spv.ULessThan` (spirv::ULessThanOp)


    Unsigned-integer comparison if Operand 1 is less than Operand 2.
  

Result Type must be a scalar or vector of Boolean type.

 The type of Operand 1 and Operand 2  must be a scalar or vector of
integer type.  They must have the same component width, and they must
have the same number of components as Result Type.

 Results are computed per component.

### Custom assembly form
</code></pre><p>integer-scalar-vector-type ::= integer-type |
<code>vector&lt;</code> integer-literal <code>x</code> integer-type <code>></code>
uless-than-op ::= ssa-id <code>=</code> <code>spv.ULessThan</code> ssa-use, ssa-use
<code>:</code> integer-scalar-vector-type</p><pre><code>For example:

</code></pre><p>%4 = spv.ULessThan %0, %1 : i32
%5 = spv.ULessThan %2, %3 : vector&lt;4xi32></p><pre><code>
#### Operands:

| Operand | Description |
| :-----: | ----------- |
`operand1` | 8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4
`operand2` | 8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | bool or vector of bool values of length 2/3/4

### `spv.UMod` (spirv::UModOp)

Unsigned modulo operation of Operand 1 modulo Operand 2.

Result Type must be a scalar or vector of integer type, whose Signedness
operand is 0.

 The types of Operand 1 and Operand 2 both must be the same as Result
Type.

 Results are computed per component.  The resulting value is undefined
if Operand 2 is 0.

### Custom assembly form
</code></pre><p>integer-scalar-vector-type ::= integer-type |
<code>vector&lt;</code> integer-literal <code>x</code> integer-type <code>></code>
umod-op ::= ssa-id <code>=</code> <code>spv.UMod</code> ssa-use, ssa-use
<code>:</code> integer-scalar-vector-type</p><pre><code>For example:

</code></pre><p>%4 = spv.UMod %0, %1 : i32
%5 = spv.UMod %2, %3 : vector&lt;4xi32></p><pre><code>
#### Operands:

| Operand | Description |
| :-----: | ----------- |
`operand1` | 8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4
`operand2` | 8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | 8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4

### `spv.undef` (spirv::UndefOp)

Make an intermediate object whose value is undefined.

Syntax:

</code></pre><p>operation ::= <code>spv.undef</code> attr-dict <code>:</code> type($result)</p><pre><code>

Result Type is the type of object to make.

Each consumption of Result &lt;id&gt; yields an arbitrary, possibly different
bit pattern or abstract value resulting in possibly different concrete,
abstract, or opaque values.

### Custom assembly form

</code></pre><p>undef-op ::= <code>spv.undef</code> <code>:</code> spirv-type</p><pre><code>
For example:

</code></pre><p>%0 = spv.undef : f32
%1 = spv.undef : !spv.struct&lt;!spv.array&lt;4 x vector&lt;4xi32&#187;></p><pre><code>
#### Results:

| Result | Description |
| :----: | ----------- |
`result` | void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float values of length 2/3/4 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type

### `spv.Unreachable` (spirv::UnreachableOp)

Declares that this block is not reachable in the CFG.

Syntax:

</code></pre><p>operation ::= <code>spv.Unreachable</code> attr-dict</p><pre><code>

This instruction must be the last instruction in a block.

### Custom assembly form

</code></pre><p>unreachable-op ::= <code>spv.Unreachable</code></p><pre><code>
### `spv.Variable` (spirv::VariableOp)


    Allocate an object in memory, resulting in a pointer to it, which can be
    used with OpLoad and OpStore.
  

Result Type must be an OpTypePointer. Its Type operand is the type of
object in memory.

Storage Class is the Storage Class of the memory holding the object. It
cannot be Generic. It must be the same as the Storage Class operand of
the Result Type.

Initializer is optional.  If Initializer is present, it will be the
initial value of the variable’s memory content. Initializer must be an
&lt;id&gt; from a constant instruction or a global (module scope) OpVariable
instruction. Initializer must have the same type as the type pointed to
by Result Type.

### Custom assembly form

</code></pre><p>variable-op ::= ssa-id <code>=</code> <code>spv.Variable</code> (<code>init(</code> ssa-use <code>)</code>)?
(<code>bind(</code> integer-literal, integer-literal <code>)</code>)?
(<code>built_in(</code> string-literal <code>)</code>)?
attribute-dict? <code>:</code> spirv-pointer-type</p><pre><code>
where `init` specifies initializer and `bind` specifies the
descriptor set and binding number. `built_in` specifies SPIR-V
BuiltIn decoration associated with the op.

For example:

</code></pre><p>%0 = spv.constant &mldr;</p><p>%1 = spv.Variable : !spv.ptr&lt;f32, Function>
%2 = spv.Variable init(%0): !spv.ptr&lt;f32, Private>
%3 = spv.Variable init(%0) bind(1, 2): !spv.ptr&lt;f32, Uniform>
%3 = spv.Variable built_in(&ldquo;GlobalInvocationID&rdquo;) : !spv.ptr&lt;vector&lt;3xi32>, Uniform></p><pre><code>
#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`storage_class` | IntegerAttr | valid SPIR-V StorageClass

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`initializer` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
`pointer` | any SPIR-V pointer type

</code></pre><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Dialects/SPIR-V/ title="'spv' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - 'spv' Dialect</a>
<a class="nav nav-next" href=/docs/Dialects/Standard/ title="'std' Dialect">Next - 'std' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class="parent has-sub-menu"><a href=/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=/docs/Dialects/FxpMathDialect/>'fxpmath' Dialect</a></li><li><a href=/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=/docs/Dialects/Linalg/>'linalg' Dialect</a></li><li><a href=/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=/docs/Dialects/LoopDialect/>'loop' Dialect</a></li><li><a href=/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>'spv' Dialect</a></li><li class=active><a href=/docs/Dialects/SPIRVDialect/>'spv' Dialect</a></li><li><a href=/docs/Dialects/Standard/>'std' Dialect</a></li><li><a href=/docs/Dialects/Vector/>'vector' Dialect</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Tutorial Introduction</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/EDSC/>Background: declarative builders API</a></li><li><a href=/docs/ConversionToLLVMDialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li><a href=/docs/Diagnostics/>Introduction and Usage Guide to MLIR's Diagnostics Infrastructure</a></li><li><a href=/docs/Interfaces/>Introduction to MLIR Interfaces</a></li><li><a href=/docs/Traits/>Introduction to MLIR Operation Traits</a></li><li><a href=/docs/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/GenericDAGRewriter/>MLIR Generic DAG Rewriter Infrastructure</a></li><li><a href=/docs/Passes/>MLIR Passes</a></li><li><a href=/docs/Quantization/>MLIR Quantization</a></li><li><a href=/docs/Rationale/>MLIR Rationale</a></li><li><a href=/docs/LangRef/>MLIR Specification</a></li><li><a href=/docs/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization in MLIR</a></li><li><a href=/docs/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li><a href=/docs/DefiningAttributesAndTypes/>Quickstart tutorial to defining custom dialect attributes and types</a></li><li><a href=/docs/ShapeInference/>Shape inference</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/OpDefinitions/>Table-driven Operation Definition Specification (ODS)</a></li><li><a href=/docs/UsageOfConst/>Usage of 'Const' in MLIR, for core IR types</a></li><li><a href=/docs/WritingAPass/>Writing a Pass</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>